function dT(n, e) {
    for (var t = 0; t < e.length; t++) {
        const i = e[t];
        if (typeof i != 'string' && !Array.isArray(i)) {
            for (const r in i)
                if (r !== 'default' && !(r in n)) {
                    const s = Object.getOwnPropertyDescriptor(i, r);
                    s &&
                        Object.defineProperty(
                            n,
                            r,
                            s.get ? s : { enumerable: !0, get: () => i[r] }
                        );
                }
        }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
}
(function () {
    const e = document.createElement('link').relList;
    if (e && e.supports && e.supports('modulepreload')) return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
    new MutationObserver((r) => {
        for (const s of r)
            if (s.type === 'childList')
                for (const o of s.addedNodes)
                    o.tagName === 'LINK' && o.rel === 'modulepreload' && i(o);
    }).observe(document, { childList: !0, subtree: !0 });
    function t(r) {
        const s = {};
        return (
            r.integrity && (s.integrity = r.integrity),
            r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === 'use-credentials'
                ? (s.credentials = 'include')
                : r.crossOrigin === 'anonymous'
                ? (s.credentials = 'omit')
                : (s.credentials = 'same-origin'),
            s
        );
    }
    function i(r) {
        if (r.ep) return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s);
    }
})();
function Nf(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default') ? n.default : n;
}
var hT = { exports: {} },
    lm = {},
    pT = { exports: {} },
    It = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Df = Symbol.for('react.element'),
    cP = Symbol.for('react.portal'),
    fP = Symbol.for('react.fragment'),
    dP = Symbol.for('react.strict_mode'),
    hP = Symbol.for('react.profiler'),
    pP = Symbol.for('react.provider'),
    mP = Symbol.for('react.context'),
    gP = Symbol.for('react.forward_ref'),
    vP = Symbol.for('react.suspense'),
    _P = Symbol.for('react.memo'),
    yP = Symbol.for('react.lazy'),
    HS = Symbol.iterator;
function xP(n) {
    return n === null || typeof n != 'object'
        ? null
        : ((n = (HS && n[HS]) || n['@@iterator']), typeof n == 'function' ? n : null);
}
var mT = {
        isMounted: function () {
            return !1;
        },
        enqueueForceUpdate: function () {},
        enqueueReplaceState: function () {},
        enqueueSetState: function () {},
    },
    gT = Object.assign,
    vT = {};
function Eu(n, e, t) {
    (this.props = n), (this.context = e), (this.refs = vT), (this.updater = t || mT);
}
Eu.prototype.isReactComponent = {};
Eu.prototype.setState = function (n, e) {
    if (typeof n != 'object' && typeof n != 'function' && n != null)
        throw Error(
            'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
        );
    this.updater.enqueueSetState(this, n, e, 'setState');
};
Eu.prototype.forceUpdate = function (n) {
    this.updater.enqueueForceUpdate(this, n, 'forceUpdate');
};
function _T() {}
_T.prototype = Eu.prototype;
function My(n, e, t) {
    (this.props = n), (this.context = e), (this.refs = vT), (this.updater = t || mT);
}
var wy = (My.prototype = new _T());
wy.constructor = My;
gT(wy, Eu.prototype);
wy.isPureReactComponent = !0;
var VS = Array.isArray,
    yT = Object.prototype.hasOwnProperty,
    Ey = { current: null },
    xT = { key: !0, ref: !0, __self: !0, __source: !0 };
function ST(n, e, t) {
    var i,
        r = {},
        s = null,
        o = null;
    if (e != null)
        for (i in (e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = '' + e.key), e))
            yT.call(e, i) && !xT.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1) r.children = t;
    else if (1 < a) {
        for (var c = Array(a), f = 0; f < a; f++) c[f] = arguments[f + 2];
        r.children = c;
    }
    if (n && n.defaultProps) for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
    return { $$typeof: Df, type: n, key: s, ref: o, props: r, _owner: Ey.current };
}
function SP(n, e) {
    return { $$typeof: Df, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner };
}
function Ty(n) {
    return typeof n == 'object' && n !== null && n.$$typeof === Df;
}
function MP(n) {
    var e = { '=': '=0', ':': '=2' };
    return (
        '$' +
        n.replace(/[=:]/g, function (t) {
            return e[t];
        })
    );
}
var GS = /\/+/g;
function ov(n, e) {
    return typeof n == 'object' && n !== null && n.key != null ? MP('' + n.key) : e.toString(36);
}
function sp(n, e, t, i, r) {
    var s = typeof n;
    (s === 'undefined' || s === 'boolean') && (n = null);
    var o = !1;
    if (n === null) o = !0;
    else
        switch (s) {
            case 'string':
            case 'number':
                o = !0;
                break;
            case 'object':
                switch (n.$$typeof) {
                    case Df:
                    case cP:
                        o = !0;
                }
        }
    if (o)
        return (
            (o = n),
            (r = r(o)),
            (n = i === '' ? '.' + ov(o, 0) : i),
            VS(r)
                ? ((t = ''),
                  n != null && (t = n.replace(GS, '$&/') + '/'),
                  sp(r, e, t, '', function (f) {
                      return f;
                  }))
                : r != null &&
                  (Ty(r) &&
                      (r = SP(
                          r,
                          t +
                              (!r.key || (o && o.key === r.key)
                                  ? ''
                                  : ('' + r.key).replace(GS, '$&/') + '/') +
                              n
                      )),
                  e.push(r)),
            1
        );
    if (((o = 0), (i = i === '' ? '.' : i + ':'), VS(n)))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var c = i + ov(s, a);
            o += sp(s, e, t, c, r);
        }
    else if (((c = xP(n)), typeof c == 'function'))
        for (n = c.call(n), a = 0; !(s = n.next()).done; )
            (s = s.value), (c = i + ov(s, a++)), (o += sp(s, e, t, c, r));
    else if (s === 'object')
        throw (
            ((e = String(n)),
            Error(
                'Objects are not valid as a React child (found: ' +
                    (e === '[object Object]'
                        ? 'object with keys {' + Object.keys(n).join(', ') + '}'
                        : e) +
                    '). If you meant to render a collection of children, use an array instead.'
            ))
        );
    return o;
}
function Wd(n, e, t) {
    if (n == null) return n;
    var i = [],
        r = 0;
    return (
        sp(n, i, '', '', function (s) {
            return e.call(t, s, r++);
        }),
        i
    );
}
function wP(n) {
    if (n._status === -1) {
        var e = n._result;
        (e = e()),
            e.then(
                function (t) {
                    (n._status === 0 || n._status === -1) && ((n._status = 1), (n._result = t));
                },
                function (t) {
                    (n._status === 0 || n._status === -1) && ((n._status = 2), (n._result = t));
                }
            ),
            n._status === -1 && ((n._status = 0), (n._result = e));
    }
    if (n._status === 1) return n._result.default;
    throw n._result;
}
var bi = { current: null },
    op = { transition: null },
    EP = { ReactCurrentDispatcher: bi, ReactCurrentBatchConfig: op, ReactCurrentOwner: Ey };
It.Children = {
    map: Wd,
    forEach: function (n, e, t) {
        Wd(
            n,
            function () {
                e.apply(this, arguments);
            },
            t
        );
    },
    count: function (n) {
        var e = 0;
        return (
            Wd(n, function () {
                e++;
            }),
            e
        );
    },
    toArray: function (n) {
        return (
            Wd(n, function (e) {
                return e;
            }) || []
        );
    },
    only: function (n) {
        if (!Ty(n))
            throw Error('React.Children.only expected to receive a single React element child.');
        return n;
    },
};
It.Component = Eu;
It.Fragment = fP;
It.Profiler = hP;
It.PureComponent = My;
It.StrictMode = dP;
It.Suspense = vP;
It.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = EP;
It.cloneElement = function (n, e, t) {
    if (n == null)
        throw Error(
            'React.cloneElement(...): The argument must be a React element, but you passed ' +
                n +
                '.'
        );
    var i = gT({}, n.props),
        r = n.key,
        s = n.ref,
        o = n._owner;
    if (e != null) {
        if (
            (e.ref !== void 0 && ((s = e.ref), (o = Ey.current)),
            e.key !== void 0 && (r = '' + e.key),
            n.type && n.type.defaultProps)
        )
            var a = n.type.defaultProps;
        for (c in e)
            yT.call(e, c) &&
                !xT.hasOwnProperty(c) &&
                (i[c] = e[c] === void 0 && a !== void 0 ? a[c] : e[c]);
    }
    var c = arguments.length - 2;
    if (c === 1) i.children = t;
    else if (1 < c) {
        a = Array(c);
        for (var f = 0; f < c; f++) a[f] = arguments[f + 2];
        i.children = a;
    }
    return { $$typeof: Df, type: n.type, key: r, ref: s, props: i, _owner: o };
};
It.createContext = function (n) {
    return (
        (n = {
            $$typeof: mP,
            _currentValue: n,
            _currentValue2: n,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null,
        }),
        (n.Provider = { $$typeof: pP, _context: n }),
        (n.Consumer = n)
    );
};
It.createElement = ST;
It.createFactory = function (n) {
    var e = ST.bind(null, n);
    return (e.type = n), e;
};
It.createRef = function () {
    return { current: null };
};
It.forwardRef = function (n) {
    return { $$typeof: gP, render: n };
};
It.isValidElement = Ty;
It.lazy = function (n) {
    return { $$typeof: yP, _payload: { _status: -1, _result: n }, _init: wP };
};
It.memo = function (n, e) {
    return { $$typeof: _P, type: n, compare: e === void 0 ? null : e };
};
It.startTransition = function (n) {
    var e = op.transition;
    op.transition = {};
    try {
        n();
    } finally {
        op.transition = e;
    }
};
It.unstable_act = function () {
    throw Error('act(...) is not supported in production builds of React.');
};
It.useCallback = function (n, e) {
    return bi.current.useCallback(n, e);
};
It.useContext = function (n) {
    return bi.current.useContext(n);
};
It.useDebugValue = function () {};
It.useDeferredValue = function (n) {
    return bi.current.useDeferredValue(n);
};
It.useEffect = function (n, e) {
    return bi.current.useEffect(n, e);
};
It.useId = function () {
    return bi.current.useId();
};
It.useImperativeHandle = function (n, e, t) {
    return bi.current.useImperativeHandle(n, e, t);
};
It.useInsertionEffect = function (n, e) {
    return bi.current.useInsertionEffect(n, e);
};
It.useLayoutEffect = function (n, e) {
    return bi.current.useLayoutEffect(n, e);
};
It.useMemo = function (n, e) {
    return bi.current.useMemo(n, e);
};
It.useReducer = function (n, e, t) {
    return bi.current.useReducer(n, e, t);
};
It.useRef = function (n) {
    return bi.current.useRef(n);
};
It.useState = function (n) {
    return bi.current.useState(n);
};
It.useSyncExternalStore = function (n, e, t) {
    return bi.current.useSyncExternalStore(n, e, t);
};
It.useTransition = function () {
    return bi.current.useTransition();
};
It.version = '18.2.0';
pT.exports = It;
var pe = pT.exports;
const Os = Nf(pe),
    TP = dT({ __proto__: null, default: Os }, [pe]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var AP = pe,
    CP = Symbol.for('react.element'),
    bP = Symbol.for('react.fragment'),
    RP = Object.prototype.hasOwnProperty,
    PP = AP.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    LP = { key: !0, ref: !0, __self: !0, __source: !0 };
function MT(n, e, t) {
    var i,
        r = {},
        s = null,
        o = null;
    t !== void 0 && (s = '' + t),
        e.key !== void 0 && (s = '' + e.key),
        e.ref !== void 0 && (o = e.ref);
    for (i in e) RP.call(e, i) && !LP.hasOwnProperty(i) && (r[i] = e[i]);
    if (n && n.defaultProps) for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
    return { $$typeof: CP, type: n, key: s, ref: o, props: r, _owner: PP.current };
}
lm.Fragment = bP;
lm.jsx = MT;
lm.jsxs = MT;
hT.exports = lm;
var X = hT.exports,
    I0 = {},
    wT = { exports: {} },
    ir = {},
    ET = { exports: {} },
    TT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
    function e(N, B) {
        var H = N.length;
        N.push(B);
        e: for (; 0 < H; ) {
            var K = (H - 1) >>> 1,
                le = N[K];
            if (0 < r(le, B)) (N[K] = B), (N[H] = le), (H = K);
            else break e;
        }
    }
    function t(N) {
        return N.length === 0 ? null : N[0];
    }
    function i(N) {
        if (N.length === 0) return null;
        var B = N[0],
            H = N.pop();
        if (H !== B) {
            N[0] = H;
            e: for (var K = 0, le = N.length, be = le >>> 1; K < be; ) {
                var Q = 2 * (K + 1) - 1,
                    me = N[Q],
                    Se = Q + 1,
                    ke = N[Se];
                if (0 > r(me, H))
                    Se < le && 0 > r(ke, me)
                        ? ((N[K] = ke), (N[Se] = H), (K = Se))
                        : ((N[K] = me), (N[Q] = H), (K = Q));
                else if (Se < le && 0 > r(ke, H)) (N[K] = ke), (N[Se] = H), (K = Se);
                else break e;
            }
        }
        return B;
    }
    function r(N, B) {
        var H = N.sortIndex - B.sortIndex;
        return H !== 0 ? H : N.id - B.id;
    }
    if (typeof performance == 'object' && typeof performance.now == 'function') {
        var s = performance;
        n.unstable_now = function () {
            return s.now();
        };
    } else {
        var o = Date,
            a = o.now();
        n.unstable_now = function () {
            return o.now() - a;
        };
    }
    var c = [],
        f = [],
        d = 1,
        h = null,
        p = 3,
        v = !1,
        _ = !1,
        w = !1,
        x = typeof setTimeout == 'function' ? setTimeout : null,
        g = typeof clearTimeout == 'function' ? clearTimeout : null,
        S = typeof setImmediate < 'u' ? setImmediate : null;
    typeof navigator < 'u' &&
        navigator.scheduling !== void 0 &&
        navigator.scheduling.isInputPending !== void 0 &&
        navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(N) {
        for (var B = t(f); B !== null; ) {
            if (B.callback === null) i(f);
            else if (B.startTime <= N) i(f), (B.sortIndex = B.expirationTime), e(c, B);
            else break;
            B = t(f);
        }
    }
    function T(N) {
        if (((w = !1), M(N), !_))
            if (t(c) !== null) (_ = !0), te(P);
            else {
                var B = t(f);
                B !== null && ae(T, B.startTime - N);
            }
    }
    function P(N, B) {
        (_ = !1), w && ((w = !1), g(D), (D = -1)), (v = !0);
        var H = p;
        try {
            for (M(B), h = t(c); h !== null && (!(h.expirationTime > B) || (N && !L())); ) {
                var K = h.callback;
                if (typeof K == 'function') {
                    (h.callback = null), (p = h.priorityLevel);
                    var le = K(h.expirationTime <= B);
                    (B = n.unstable_now()),
                        typeof le == 'function' ? (h.callback = le) : h === t(c) && i(c),
                        M(B);
                } else i(c);
                h = t(c);
            }
            if (h !== null) var be = !0;
            else {
                var Q = t(f);
                Q !== null && ae(T, Q.startTime - B), (be = !1);
            }
            return be;
        } finally {
            (h = null), (p = H), (v = !1);
        }
    }
    var A = !1,
        R = null,
        D = -1,
        G = 5,
        b = -1;
    function L() {
        return !(n.unstable_now() - b < G);
    }
    function ee() {
        if (R !== null) {
            var N = n.unstable_now();
            b = N;
            var B = !0;
            try {
                B = R(!0, N);
            } finally {
                B ? ie() : ((A = !1), (R = null));
            }
        } else A = !1;
    }
    var ie;
    if (typeof S == 'function')
        ie = function () {
            S(ee);
        };
    else if (typeof MessageChannel < 'u') {
        var j = new MessageChannel(),
            oe = j.port2;
        (j.port1.onmessage = ee),
            (ie = function () {
                oe.postMessage(null);
            });
    } else
        ie = function () {
            x(ee, 0);
        };
    function te(N) {
        (R = N), A || ((A = !0), ie());
    }
    function ae(N, B) {
        D = x(function () {
            N(n.unstable_now());
        }, B);
    }
    (n.unstable_IdlePriority = 5),
        (n.unstable_ImmediatePriority = 1),
        (n.unstable_LowPriority = 4),
        (n.unstable_NormalPriority = 3),
        (n.unstable_Profiling = null),
        (n.unstable_UserBlockingPriority = 2),
        (n.unstable_cancelCallback = function (N) {
            N.callback = null;
        }),
        (n.unstable_continueExecution = function () {
            _ || v || ((_ = !0), te(P));
        }),
        (n.unstable_forceFrameRate = function (N) {
            0 > N || 125 < N
                ? console.error(
                      'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                  )
                : (G = 0 < N ? Math.floor(1e3 / N) : 5);
        }),
        (n.unstable_getCurrentPriorityLevel = function () {
            return p;
        }),
        (n.unstable_getFirstCallbackNode = function () {
            return t(c);
        }),
        (n.unstable_next = function (N) {
            switch (p) {
                case 1:
                case 2:
                case 3:
                    var B = 3;
                    break;
                default:
                    B = p;
            }
            var H = p;
            p = B;
            try {
                return N();
            } finally {
                p = H;
            }
        }),
        (n.unstable_pauseExecution = function () {}),
        (n.unstable_requestPaint = function () {}),
        (n.unstable_runWithPriority = function (N, B) {
            switch (N) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    N = 3;
            }
            var H = p;
            p = N;
            try {
                return B();
            } finally {
                p = H;
            }
        }),
        (n.unstable_scheduleCallback = function (N, B, H) {
            var K = n.unstable_now();
            switch (
                (typeof H == 'object' && H !== null
                    ? ((H = H.delay), (H = typeof H == 'number' && 0 < H ? K + H : K))
                    : (H = K),
                N)
            ) {
                case 1:
                    var le = -1;
                    break;
                case 2:
                    le = 250;
                    break;
                case 5:
                    le = 1073741823;
                    break;
                case 4:
                    le = 1e4;
                    break;
                default:
                    le = 5e3;
            }
            return (
                (le = H + le),
                (N = {
                    id: d++,
                    callback: B,
                    priorityLevel: N,
                    startTime: H,
                    expirationTime: le,
                    sortIndex: -1,
                }),
                H > K
                    ? ((N.sortIndex = H),
                      e(f, N),
                      t(c) === null &&
                          N === t(f) &&
                          (w ? (g(D), (D = -1)) : (w = !0), ae(T, H - K)))
                    : ((N.sortIndex = le), e(c, N), _ || v || ((_ = !0), te(P))),
                N
            );
        }),
        (n.unstable_shouldYield = L),
        (n.unstable_wrapCallback = function (N) {
            var B = p;
            return function () {
                var H = p;
                p = B;
                try {
                    return N.apply(this, arguments);
                } finally {
                    p = H;
                }
            };
        });
})(TT);
ET.exports = TT;
var IP = ET.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var AT = pe,
    tr = IP;
function Te(n) {
    for (
        var e = 'https://reactjs.org/docs/error-decoder.html?invariant=' + n, t = 1;
        t < arguments.length;
        t++
    )
        e += '&args[]=' + encodeURIComponent(arguments[t]);
    return (
        'Minified React error #' +
        n +
        '; visit ' +
        e +
        ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    );
}
var CT = new Set(),
    Xc = {};
function ja(n, e) {
    fu(n, e), fu(n + 'Capture', e);
}
function fu(n, e) {
    for (Xc[n] = e, n = 0; n < e.length; n++) CT.add(e[n]);
}
var zs = !(
        typeof window > 'u' ||
        typeof window.document > 'u' ||
        typeof window.document.createElement > 'u'
    ),
    N0 = Object.prototype.hasOwnProperty,
    NP =
        /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    WS = {},
    jS = {};
function DP(n) {
    return N0.call(jS, n)
        ? !0
        : N0.call(WS, n)
        ? !1
        : NP.test(n)
        ? (jS[n] = !0)
        : ((WS[n] = !0), !1);
}
function UP(n, e, t, i) {
    if (t !== null && t.type === 0) return !1;
    switch (typeof e) {
        case 'function':
        case 'symbol':
            return !0;
        case 'boolean':
            return i
                ? !1
                : t !== null
                ? !t.acceptsBooleans
                : ((n = n.toLowerCase().slice(0, 5)), n !== 'data-' && n !== 'aria-');
        default:
            return !1;
    }
}
function OP(n, e, t, i) {
    if (e === null || typeof e > 'u' || UP(n, e, t, i)) return !0;
    if (i) return !1;
    if (t !== null)
        switch (t.type) {
            case 3:
                return !e;
            case 4:
                return e === !1;
            case 5:
                return isNaN(e);
            case 6:
                return isNaN(e) || 1 > e;
        }
    return !1;
}
function Ri(n, e, t, i, r, s, o) {
    (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
        (this.attributeName = i),
        (this.attributeNamespace = r),
        (this.mustUseProperty = t),
        (this.propertyName = n),
        (this.type = e),
        (this.sanitizeURL = s),
        (this.removeEmptyString = o);
}
var ni = {};
'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
    .split(' ')
    .forEach(function (n) {
        ni[n] = new Ri(n, 0, !1, n, null, !1, !1);
    });
[
    ['acceptCharset', 'accept-charset'],
    ['className', 'class'],
    ['htmlFor', 'for'],
    ['httpEquiv', 'http-equiv'],
].forEach(function (n) {
    var e = n[0];
    ni[e] = new Ri(e, 1, !1, n[1], null, !1, !1);
});
['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (n) {
    ni[n] = new Ri(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (n) {
    ni[n] = new Ri(n, 2, !1, n, null, !1, !1);
});
'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
    .split(' ')
    .forEach(function (n) {
        ni[n] = new Ri(n, 3, !1, n.toLowerCase(), null, !1, !1);
    });
['checked', 'multiple', 'muted', 'selected'].forEach(function (n) {
    ni[n] = new Ri(n, 3, !0, n, null, !1, !1);
});
['capture', 'download'].forEach(function (n) {
    ni[n] = new Ri(n, 4, !1, n, null, !1, !1);
});
['cols', 'rows', 'size', 'span'].forEach(function (n) {
    ni[n] = new Ri(n, 6, !1, n, null, !1, !1);
});
['rowSpan', 'start'].forEach(function (n) {
    ni[n] = new Ri(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var Ay = /[\-:]([a-z])/g;
function Cy(n) {
    return n[1].toUpperCase();
}
'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
    .split(' ')
    .forEach(function (n) {
        var e = n.replace(Ay, Cy);
        ni[e] = new Ri(e, 1, !1, n, null, !1, !1);
    });
'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
    .split(' ')
    .forEach(function (n) {
        var e = n.replace(Ay, Cy);
        ni[e] = new Ri(e, 1, !1, n, 'http://www.w3.org/1999/xlink', !1, !1);
    });
['xml:base', 'xml:lang', 'xml:space'].forEach(function (n) {
    var e = n.replace(Ay, Cy);
    ni[e] = new Ri(e, 1, !1, n, 'http://www.w3.org/XML/1998/namespace', !1, !1);
});
['tabIndex', 'crossOrigin'].forEach(function (n) {
    ni[n] = new Ri(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
ni.xlinkHref = new Ri('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1);
['src', 'href', 'action', 'formAction'].forEach(function (n) {
    ni[n] = new Ri(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function by(n, e, t, i) {
    var r = ni.hasOwnProperty(e) ? ni[e] : null;
    (r !== null
        ? r.type !== 0
        : i ||
          !(2 < e.length) ||
          (e[0] !== 'o' && e[0] !== 'O') ||
          (e[1] !== 'n' && e[1] !== 'N')) &&
        (OP(e, t, r, i) && (t = null),
        i || r === null
            ? DP(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, '' + t))
            : r.mustUseProperty
            ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : '') : t)
            : ((e = r.attributeName),
              (i = r.attributeNamespace),
              t === null
                  ? n.removeAttribute(e)
                  : ((r = r.type),
                    (t = r === 3 || (r === 4 && t === !0) ? '' : '' + t),
                    i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var Xs = AT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    jd = Symbol.for('react.element'),
    kl = Symbol.for('react.portal'),
    zl = Symbol.for('react.fragment'),
    Ry = Symbol.for('react.strict_mode'),
    D0 = Symbol.for('react.profiler'),
    bT = Symbol.for('react.provider'),
    RT = Symbol.for('react.context'),
    Py = Symbol.for('react.forward_ref'),
    U0 = Symbol.for('react.suspense'),
    O0 = Symbol.for('react.suspense_list'),
    Ly = Symbol.for('react.memo'),
    go = Symbol.for('react.lazy'),
    PT = Symbol.for('react.offscreen'),
    XS = Symbol.iterator;
function Qu(n) {
    return n === null || typeof n != 'object'
        ? null
        : ((n = (XS && n[XS]) || n['@@iterator']), typeof n == 'function' ? n : null);
}
var gn = Object.assign,
    av;
function Ac(n) {
    if (av === void 0)
        try {
            throw Error();
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            av = (e && e[1]) || '';
        }
    return (
        `
` +
        av +
        n
    );
}
var lv = !1;
function uv(n, e) {
    if (!n || lv) return '';
    lv = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (
                ((e = function () {
                    throw Error();
                }),
                Object.defineProperty(e.prototype, 'props', {
                    set: function () {
                        throw Error();
                    },
                }),
                typeof Reflect == 'object' && Reflect.construct)
            ) {
                try {
                    Reflect.construct(e, []);
                } catch (f) {
                    var i = f;
                }
                Reflect.construct(n, [], e);
            } else {
                try {
                    e.call();
                } catch (f) {
                    i = f;
                }
                n.call(e.prototype);
            }
        else {
            try {
                throw Error();
            } catch (f) {
                i = f;
            }
            n();
        }
    } catch (f) {
        if (f && i && typeof f.stack == 'string') {
            for (
                var r = f.stack.split(`
`),
                    s = i.stack.split(`
`),
                    o = r.length - 1,
                    a = s.length - 1;
                1 <= o && 0 <= a && r[o] !== s[a];

            )
                a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if ((o--, a--, 0 > a || r[o] !== s[a])) {
                                var c =
                                    `
` + r[o].replace(' at new ', ' at ');
                                return (
                                    n.displayName &&
                                        c.includes('<anonymous>') &&
                                        (c = c.replace('<anonymous>', n.displayName)),
                                    c
                                );
                            }
                        while (1 <= o && 0 <= a);
                    break;
                }
        }
    } finally {
        (lv = !1), (Error.prepareStackTrace = t);
    }
    return (n = n ? n.displayName || n.name : '') ? Ac(n) : '';
}
function FP(n) {
    switch (n.tag) {
        case 5:
            return Ac(n.type);
        case 16:
            return Ac('Lazy');
        case 13:
            return Ac('Suspense');
        case 19:
            return Ac('SuspenseList');
        case 0:
        case 2:
        case 15:
            return (n = uv(n.type, !1)), n;
        case 11:
            return (n = uv(n.type.render, !1)), n;
        case 1:
            return (n = uv(n.type, !0)), n;
        default:
            return '';
    }
}
function F0(n) {
    if (n == null) return null;
    if (typeof n == 'function') return n.displayName || n.name || null;
    if (typeof n == 'string') return n;
    switch (n) {
        case zl:
            return 'Fragment';
        case kl:
            return 'Portal';
        case D0:
            return 'Profiler';
        case Ry:
            return 'StrictMode';
        case U0:
            return 'Suspense';
        case O0:
            return 'SuspenseList';
    }
    if (typeof n == 'object')
        switch (n.$$typeof) {
            case RT:
                return (n.displayName || 'Context') + '.Consumer';
            case bT:
                return (n._context.displayName || 'Context') + '.Provider';
            case Py:
                var e = n.render;
                return (
                    (n = n.displayName),
                    n ||
                        ((n = e.displayName || e.name || ''),
                        (n = n !== '' ? 'ForwardRef(' + n + ')' : 'ForwardRef')),
                    n
                );
            case Ly:
                return (e = n.displayName || null), e !== null ? e : F0(n.type) || 'Memo';
            case go:
                (e = n._payload), (n = n._init);
                try {
                    return F0(n(e));
                } catch {}
        }
    return null;
}
function kP(n) {
    var e = n.type;
    switch (n.tag) {
        case 24:
            return 'Cache';
        case 9:
            return (e.displayName || 'Context') + '.Consumer';
        case 10:
            return (e._context.displayName || 'Context') + '.Provider';
        case 18:
            return 'DehydratedFragment';
        case 11:
            return (
                (n = e.render),
                (n = n.displayName || n.name || ''),
                e.displayName || (n !== '' ? 'ForwardRef(' + n + ')' : 'ForwardRef')
            );
        case 7:
            return 'Fragment';
        case 5:
            return e;
        case 4:
            return 'Portal';
        case 3:
            return 'Root';
        case 6:
            return 'Text';
        case 16:
            return F0(e);
        case 8:
            return e === Ry ? 'StrictMode' : 'Mode';
        case 22:
            return 'Offscreen';
        case 12:
            return 'Profiler';
        case 21:
            return 'Scope';
        case 13:
            return 'Suspense';
        case 19:
            return 'SuspenseList';
        case 25:
            return 'TracingMarker';
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof e == 'function') return e.displayName || e.name || null;
            if (typeof e == 'string') return e;
    }
    return null;
}
function Uo(n) {
    switch (typeof n) {
        case 'boolean':
        case 'number':
        case 'string':
        case 'undefined':
            return n;
        case 'object':
            return n;
        default:
            return '';
    }
}
function LT(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === 'input' && (e === 'checkbox' || e === 'radio');
}
function zP(n) {
    var e = LT(n) ? 'checked' : 'value',
        t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
        i = '' + n[e];
    if (
        !n.hasOwnProperty(e) &&
        typeof t < 'u' &&
        typeof t.get == 'function' &&
        typeof t.set == 'function'
    ) {
        var r = t.get,
            s = t.set;
        return (
            Object.defineProperty(n, e, {
                configurable: !0,
                get: function () {
                    return r.call(this);
                },
                set: function (o) {
                    (i = '' + o), s.call(this, o);
                },
            }),
            Object.defineProperty(n, e, { enumerable: t.enumerable }),
            {
                getValue: function () {
                    return i;
                },
                setValue: function (o) {
                    i = '' + o;
                },
                stopTracking: function () {
                    (n._valueTracker = null), delete n[e];
                },
            }
        );
    }
}
function Xd(n) {
    n._valueTracker || (n._valueTracker = zP(n));
}
function IT(n) {
    if (!n) return !1;
    var e = n._valueTracker;
    if (!e) return !0;
    var t = e.getValue(),
        i = '';
    return (
        n && (i = LT(n) ? (n.checked ? 'true' : 'false') : n.value),
        (n = i),
        n !== t ? (e.setValue(n), !0) : !1
    );
}
function Tp(n) {
    if (((n = n || (typeof document < 'u' ? document : void 0)), typeof n > 'u')) return null;
    try {
        return n.activeElement || n.body;
    } catch {
        return n.body;
    }
}
function k0(n, e) {
    var t = e.checked;
    return gn({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked,
    });
}
function YS(n, e) {
    var t = e.defaultValue == null ? '' : e.defaultValue,
        i = e.checked != null ? e.checked : e.defaultChecked;
    (t = Uo(e.value != null ? e.value : t)),
        (n._wrapperState = {
            initialChecked: i,
            initialValue: t,
            controlled:
                e.type === 'checkbox' || e.type === 'radio' ? e.checked != null : e.value != null,
        });
}
function NT(n, e) {
    (e = e.checked), e != null && by(n, 'checked', e, !1);
}
function z0(n, e) {
    NT(n, e);
    var t = Uo(e.value),
        i = e.type;
    if (t != null)
        i === 'number'
            ? ((t === 0 && n.value === '') || n.value != t) && (n.value = '' + t)
            : n.value !== '' + t && (n.value = '' + t);
    else if (i === 'submit' || i === 'reset') {
        n.removeAttribute('value');
        return;
    }
    e.hasOwnProperty('value')
        ? B0(n, e.type, t)
        : e.hasOwnProperty('defaultValue') && B0(n, e.type, Uo(e.defaultValue)),
        e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked);
}
function qS(n, e, t) {
    if (e.hasOwnProperty('value') || e.hasOwnProperty('defaultValue')) {
        var i = e.type;
        if (!((i !== 'submit' && i !== 'reset') || (e.value !== void 0 && e.value !== null)))
            return;
        (e = '' + n._wrapperState.initialValue),
            t || e === n.value || (n.value = e),
            (n.defaultValue = e);
    }
    (t = n.name),
        t !== '' && (n.name = ''),
        (n.defaultChecked = !!n._wrapperState.initialChecked),
        t !== '' && (n.name = t);
}
function B0(n, e, t) {
    (e !== 'number' || Tp(n.ownerDocument) !== n) &&
        (t == null
            ? (n.defaultValue = '' + n._wrapperState.initialValue)
            : n.defaultValue !== '' + t && (n.defaultValue = '' + t));
}
var Cc = Array.isArray;
function ru(n, e, t, i) {
    if (((n = n.options), e)) {
        e = {};
        for (var r = 0; r < t.length; r++) e['$' + t[r]] = !0;
        for (t = 0; t < n.length; t++)
            (r = e.hasOwnProperty('$' + n[t].value)),
                n[t].selected !== r && (n[t].selected = r),
                r && i && (n[t].defaultSelected = !0);
    } else {
        for (t = '' + Uo(t), e = null, r = 0; r < n.length; r++) {
            if (n[r].value === t) {
                (n[r].selected = !0), i && (n[r].defaultSelected = !0);
                return;
            }
            e !== null || n[r].disabled || (e = n[r]);
        }
        e !== null && (e.selected = !0);
    }
}
function H0(n, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(Te(91));
    return gn({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: '' + n._wrapperState.initialValue,
    });
}
function ZS(n, e) {
    var t = e.value;
    if (t == null) {
        if (((t = e.children), (e = e.defaultValue), t != null)) {
            if (e != null) throw Error(Te(92));
            if (Cc(t)) {
                if (1 < t.length) throw Error(Te(93));
                t = t[0];
            }
            e = t;
        }
        e == null && (e = ''), (t = e);
    }
    n._wrapperState = { initialValue: Uo(t) };
}
function DT(n, e) {
    var t = Uo(e.value),
        i = Uo(e.defaultValue);
    t != null &&
        ((t = '' + t),
        t !== n.value && (n.value = t),
        e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
        i != null && (n.defaultValue = '' + i);
}
function KS(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== '' && e !== null && (n.value = e);
}
function UT(n) {
    switch (n) {
        case 'svg':
            return 'http://www.w3.org/2000/svg';
        case 'math':
            return 'http://www.w3.org/1998/Math/MathML';
        default:
            return 'http://www.w3.org/1999/xhtml';
    }
}
function V0(n, e) {
    return n == null || n === 'http://www.w3.org/1999/xhtml'
        ? UT(e)
        : n === 'http://www.w3.org/2000/svg' && e === 'foreignObject'
        ? 'http://www.w3.org/1999/xhtml'
        : n;
}
var Yd,
    OT = (function (n) {
        return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
            ? function (e, t, i, r) {
                  MSApp.execUnsafeLocalFunction(function () {
                      return n(e, t, i, r);
                  });
              }
            : n;
    })(function (n, e) {
        if (n.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in n) n.innerHTML = e;
        else {
            for (
                Yd = Yd || document.createElement('div'),
                    Yd.innerHTML = '<svg>' + e.valueOf().toString() + '</svg>',
                    e = Yd.firstChild;
                n.firstChild;

            )
                n.removeChild(n.firstChild);
            for (; e.firstChild; ) n.appendChild(e.firstChild);
        }
    });
function Yc(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return;
        }
    }
    n.textContent = e;
}
var Lc = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0,
    },
    BP = ['Webkit', 'ms', 'Moz', 'O'];
Object.keys(Lc).forEach(function (n) {
    BP.forEach(function (e) {
        (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (Lc[e] = Lc[n]);
    });
});
function FT(n, e, t) {
    return e == null || typeof e == 'boolean' || e === ''
        ? ''
        : t || typeof e != 'number' || e === 0 || (Lc.hasOwnProperty(n) && Lc[n])
        ? ('' + e).trim()
        : e + 'px';
}
function kT(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var i = t.indexOf('--') === 0,
                r = FT(t, e[t], i);
            t === 'float' && (t = 'cssFloat'), i ? n.setProperty(t, r) : (n[t] = r);
        }
}
var HP = gn(
    { menuitem: !0 },
    {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0,
    }
);
function G0(n, e) {
    if (e) {
        if (HP[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(Te(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(Te(60));
            if (
                typeof e.dangerouslySetInnerHTML != 'object' ||
                !('__html' in e.dangerouslySetInnerHTML)
            )
                throw Error(Te(61));
        }
        if (e.style != null && typeof e.style != 'object') throw Error(Te(62));
    }
}
function W0(n, e) {
    if (n.indexOf('-') === -1) return typeof e.is == 'string';
    switch (n) {
        case 'annotation-xml':
        case 'color-profile':
        case 'font-face':
        case 'font-face-src':
        case 'font-face-uri':
        case 'font-face-format':
        case 'font-face-name':
        case 'missing-glyph':
            return !1;
        default:
            return !0;
    }
}
var j0 = null;
function Iy(n) {
    return (
        (n = n.target || n.srcElement || window),
        n.correspondingUseElement && (n = n.correspondingUseElement),
        n.nodeType === 3 ? n.parentNode : n
    );
}
var X0 = null,
    su = null,
    ou = null;
function JS(n) {
    if ((n = Ff(n))) {
        if (typeof X0 != 'function') throw Error(Te(280));
        var e = n.stateNode;
        e && ((e = hm(e)), X0(n.stateNode, n.type, e));
    }
}
function zT(n) {
    su ? (ou ? ou.push(n) : (ou = [n])) : (su = n);
}
function BT() {
    if (su) {
        var n = su,
            e = ou;
        if (((ou = su = null), JS(n), e)) for (n = 0; n < e.length; n++) JS(e[n]);
    }
}
function HT(n, e) {
    return n(e);
}
function VT() {}
var cv = !1;
function GT(n, e, t) {
    if (cv) return n(e, t);
    cv = !0;
    try {
        return HT(n, e, t);
    } finally {
        (cv = !1), (su !== null || ou !== null) && (VT(), BT());
    }
}
function qc(n, e) {
    var t = n.stateNode;
    if (t === null) return null;
    var i = hm(t);
    if (i === null) return null;
    t = i[e];
    e: switch (e) {
        case 'onClick':
        case 'onClickCapture':
        case 'onDoubleClick':
        case 'onDoubleClickCapture':
        case 'onMouseDown':
        case 'onMouseDownCapture':
        case 'onMouseMove':
        case 'onMouseMoveCapture':
        case 'onMouseUp':
        case 'onMouseUpCapture':
        case 'onMouseEnter':
            (i = !i.disabled) ||
                ((n = n.type),
                (i = !(n === 'button' || n === 'input' || n === 'select' || n === 'textarea'))),
                (n = !i);
            break e;
        default:
            n = !1;
    }
    if (n) return null;
    if (t && typeof t != 'function') throw Error(Te(231, e, typeof t));
    return t;
}
var Y0 = !1;
if (zs)
    try {
        var $u = {};
        Object.defineProperty($u, 'passive', {
            get: function () {
                Y0 = !0;
            },
        }),
            window.addEventListener('test', $u, $u),
            window.removeEventListener('test', $u, $u);
    } catch {
        Y0 = !1;
    }
function VP(n, e, t, i, r, s, o, a, c) {
    var f = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, f);
    } catch (d) {
        this.onError(d);
    }
}
var Ic = !1,
    Ap = null,
    Cp = !1,
    q0 = null,
    GP = {
        onError: function (n) {
            (Ic = !0), (Ap = n);
        },
    };
function WP(n, e, t, i, r, s, o, a, c) {
    (Ic = !1), (Ap = null), VP.apply(GP, arguments);
}
function jP(n, e, t, i, r, s, o, a, c) {
    if ((WP.apply(this, arguments), Ic)) {
        if (Ic) {
            var f = Ap;
            (Ic = !1), (Ap = null);
        } else throw Error(Te(198));
        Cp || ((Cp = !0), (q0 = f));
    }
}
function Xa(n) {
    var e = n,
        t = n;
    if (n.alternate) for (; e.return; ) e = e.return;
    else {
        n = e;
        do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
        while (n);
    }
    return e.tag === 3 ? t : null;
}
function WT(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if ((e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)), e !== null))
            return e.dehydrated;
    }
    return null;
}
function QS(n) {
    if (Xa(n) !== n) throw Error(Te(188));
}
function XP(n) {
    var e = n.alternate;
    if (!e) {
        if (((e = Xa(n)), e === null)) throw Error(Te(188));
        return e !== n ? null : n;
    }
    for (var t = n, i = e; ; ) {
        var r = t.return;
        if (r === null) break;
        var s = r.alternate;
        if (s === null) {
            if (((i = r.return), i !== null)) {
                t = i;
                continue;
            }
            break;
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === t) return QS(r), n;
                if (s === i) return QS(r), e;
                s = s.sibling;
            }
            throw Error(Te(188));
        }
        if (t.return !== i.return) (t = r), (i = s);
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === t) {
                    (o = !0), (t = r), (i = s);
                    break;
                }
                if (a === i) {
                    (o = !0), (i = r), (t = s);
                    break;
                }
                a = a.sibling;
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        (o = !0), (t = s), (i = r);
                        break;
                    }
                    if (a === i) {
                        (o = !0), (i = s), (t = r);
                        break;
                    }
                    a = a.sibling;
                }
                if (!o) throw Error(Te(189));
            }
        }
        if (t.alternate !== i) throw Error(Te(190));
    }
    if (t.tag !== 3) throw Error(Te(188));
    return t.stateNode.current === t ? n : e;
}
function jT(n) {
    return (n = XP(n)), n !== null ? XT(n) : null;
}
function XT(n) {
    if (n.tag === 5 || n.tag === 6) return n;
    for (n = n.child; n !== null; ) {
        var e = XT(n);
        if (e !== null) return e;
        n = n.sibling;
    }
    return null;
}
var YT = tr.unstable_scheduleCallback,
    $S = tr.unstable_cancelCallback,
    YP = tr.unstable_shouldYield,
    qP = tr.unstable_requestPaint,
    Rn = tr.unstable_now,
    ZP = tr.unstable_getCurrentPriorityLevel,
    Ny = tr.unstable_ImmediatePriority,
    qT = tr.unstable_UserBlockingPriority,
    bp = tr.unstable_NormalPriority,
    KP = tr.unstable_LowPriority,
    ZT = tr.unstable_IdlePriority,
    um = null,
    us = null;
function JP(n) {
    if (us && typeof us.onCommitFiberRoot == 'function')
        try {
            us.onCommitFiberRoot(um, n, void 0, (n.current.flags & 128) === 128);
        } catch {}
}
var zr = Math.clz32 ? Math.clz32 : e3,
    QP = Math.log,
    $P = Math.LN2;
function e3(n) {
    return (n >>>= 0), n === 0 ? 32 : (31 - ((QP(n) / $P) | 0)) | 0;
}
var qd = 64,
    Zd = 4194304;
function bc(n) {
    switch (n & -n) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return n & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return n & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return n;
    }
}
function Rp(n, e) {
    var t = n.pendingLanes;
    if (t === 0) return 0;
    var i = 0,
        r = n.suspendedLanes,
        s = n.pingedLanes,
        o = t & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? (i = bc(a)) : ((s &= o), s !== 0 && (i = bc(s)));
    } else (o = t & ~r), o !== 0 ? (i = bc(o)) : s !== 0 && (i = bc(s));
    if (i === 0) return 0;
    if (
        e !== 0 &&
        e !== i &&
        !(e & r) &&
        ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
    )
        return e;
    if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
        for (n = n.entanglements, e &= i; 0 < e; )
            (t = 31 - zr(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
    return i;
}
function t3(n, e) {
    switch (n) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1;
    }
}
function n3(n, e) {
    for (
        var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes;
        0 < s;

    ) {
        var o = 31 - zr(s),
            a = 1 << o,
            c = r[o];
        c === -1 ? (!(a & t) || a & i) && (r[o] = t3(a, e)) : c <= e && (n.expiredLanes |= a),
            (s &= ~a);
    }
}
function Z0(n) {
    return (n = n.pendingLanes & -1073741825), n !== 0 ? n : n & 1073741824 ? 1073741824 : 0;
}
function KT() {
    var n = qd;
    return (qd <<= 1), !(qd & 4194240) && (qd = 64), n;
}
function fv(n) {
    for (var e = [], t = 0; 31 > t; t++) e.push(n);
    return e;
}
function Uf(n, e, t) {
    (n.pendingLanes |= e),
        e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
        (n = n.eventTimes),
        (e = 31 - zr(e)),
        (n[e] = t);
}
function i3(n, e) {
    var t = n.pendingLanes & ~e;
    (n.pendingLanes = e),
        (n.suspendedLanes = 0),
        (n.pingedLanes = 0),
        (n.expiredLanes &= e),
        (n.mutableReadLanes &= e),
        (n.entangledLanes &= e),
        (e = n.entanglements);
    var i = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var r = 31 - zr(t),
            s = 1 << r;
        (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
    }
}
function Dy(n, e) {
    var t = (n.entangledLanes |= e);
    for (n = n.entanglements; t; ) {
        var i = 31 - zr(t),
            r = 1 << i;
        (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
    }
}
var jt = 0;
function JT(n) {
    return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var QT,
    Uy,
    $T,
    eA,
    tA,
    K0 = !1,
    Kd = [],
    Eo = null,
    To = null,
    Ao = null,
    Zc = new Map(),
    Kc = new Map(),
    yo = [],
    r3 =
        'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
            ' '
        );
function eM(n, e) {
    switch (n) {
        case 'focusin':
        case 'focusout':
            Eo = null;
            break;
        case 'dragenter':
        case 'dragleave':
            To = null;
            break;
        case 'mouseover':
        case 'mouseout':
            Ao = null;
            break;
        case 'pointerover':
        case 'pointerout':
            Zc.delete(e.pointerId);
            break;
        case 'gotpointercapture':
        case 'lostpointercapture':
            Kc.delete(e.pointerId);
    }
}
function ec(n, e, t, i, r, s) {
    return n === null || n.nativeEvent !== s
        ? ((n = {
              blockedOn: e,
              domEventName: t,
              eventSystemFlags: i,
              nativeEvent: s,
              targetContainers: [r],
          }),
          e !== null && ((e = Ff(e)), e !== null && Uy(e)),
          n)
        : ((n.eventSystemFlags |= i),
          (e = n.targetContainers),
          r !== null && e.indexOf(r) === -1 && e.push(r),
          n);
}
function s3(n, e, t, i, r) {
    switch (e) {
        case 'focusin':
            return (Eo = ec(Eo, n, e, t, i, r)), !0;
        case 'dragenter':
            return (To = ec(To, n, e, t, i, r)), !0;
        case 'mouseover':
            return (Ao = ec(Ao, n, e, t, i, r)), !0;
        case 'pointerover':
            var s = r.pointerId;
            return Zc.set(s, ec(Zc.get(s) || null, n, e, t, i, r)), !0;
        case 'gotpointercapture':
            return (s = r.pointerId), Kc.set(s, ec(Kc.get(s) || null, n, e, t, i, r)), !0;
    }
    return !1;
}
function nA(n) {
    var e = Sa(n.target);
    if (e !== null) {
        var t = Xa(e);
        if (t !== null) {
            if (((e = t.tag), e === 13)) {
                if (((e = WT(t)), e !== null)) {
                    (n.blockedOn = e),
                        tA(n.priority, function () {
                            $T(t);
                        });
                    return;
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return;
            }
        }
    }
    n.blockedOn = null;
}
function ap(n) {
    if (n.blockedOn !== null) return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = J0(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var i = new t.constructor(t.type, t);
            (j0 = i), t.target.dispatchEvent(i), (j0 = null);
        } else return (e = Ff(t)), e !== null && Uy(e), (n.blockedOn = t), !1;
        e.shift();
    }
    return !0;
}
function tM(n, e, t) {
    ap(n) && t.delete(e);
}
function o3() {
    (K0 = !1),
        Eo !== null && ap(Eo) && (Eo = null),
        To !== null && ap(To) && (To = null),
        Ao !== null && ap(Ao) && (Ao = null),
        Zc.forEach(tM),
        Kc.forEach(tM);
}
function tc(n, e) {
    n.blockedOn === e &&
        ((n.blockedOn = null),
        K0 || ((K0 = !0), tr.unstable_scheduleCallback(tr.unstable_NormalPriority, o3)));
}
function Jc(n) {
    function e(r) {
        return tc(r, n);
    }
    if (0 < Kd.length) {
        tc(Kd[0], n);
        for (var t = 1; t < Kd.length; t++) {
            var i = Kd[t];
            i.blockedOn === n && (i.blockedOn = null);
        }
    }
    for (
        Eo !== null && tc(Eo, n),
            To !== null && tc(To, n),
            Ao !== null && tc(Ao, n),
            Zc.forEach(e),
            Kc.forEach(e),
            t = 0;
        t < yo.length;
        t++
    )
        (i = yo[t]), i.blockedOn === n && (i.blockedOn = null);
    for (; 0 < yo.length && ((t = yo[0]), t.blockedOn === null); )
        nA(t), t.blockedOn === null && yo.shift();
}
var au = Xs.ReactCurrentBatchConfig,
    Pp = !0;
function a3(n, e, t, i) {
    var r = jt,
        s = au.transition;
    au.transition = null;
    try {
        (jt = 1), Oy(n, e, t, i);
    } finally {
        (jt = r), (au.transition = s);
    }
}
function l3(n, e, t, i) {
    var r = jt,
        s = au.transition;
    au.transition = null;
    try {
        (jt = 4), Oy(n, e, t, i);
    } finally {
        (jt = r), (au.transition = s);
    }
}
function Oy(n, e, t, i) {
    if (Pp) {
        var r = J0(n, e, t, i);
        if (r === null) Sv(n, e, i, Lp, t), eM(n, i);
        else if (s3(r, n, e, t, i)) i.stopPropagation();
        else if ((eM(n, i), e & 4 && -1 < r3.indexOf(n))) {
            for (; r !== null; ) {
                var s = Ff(r);
                if (
                    (s !== null && QT(s),
                    (s = J0(n, e, t, i)),
                    s === null && Sv(n, e, i, Lp, t),
                    s === r)
                )
                    break;
                r = s;
            }
            r !== null && i.stopPropagation();
        } else Sv(n, e, i, null, t);
    }
}
var Lp = null;
function J0(n, e, t, i) {
    if (((Lp = null), (n = Iy(i)), (n = Sa(n)), n !== null))
        if (((e = Xa(n)), e === null)) n = null;
        else if (((t = e.tag), t === 13)) {
            if (((n = WT(e)), n !== null)) return n;
            n = null;
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null;
        } else e !== n && (n = null);
    return (Lp = n), null;
}
function iA(n) {
    switch (n) {
        case 'cancel':
        case 'click':
        case 'close':
        case 'contextmenu':
        case 'copy':
        case 'cut':
        case 'auxclick':
        case 'dblclick':
        case 'dragend':
        case 'dragstart':
        case 'drop':
        case 'focusin':
        case 'focusout':
        case 'input':
        case 'invalid':
        case 'keydown':
        case 'keypress':
        case 'keyup':
        case 'mousedown':
        case 'mouseup':
        case 'paste':
        case 'pause':
        case 'play':
        case 'pointercancel':
        case 'pointerdown':
        case 'pointerup':
        case 'ratechange':
        case 'reset':
        case 'resize':
        case 'seeked':
        case 'submit':
        case 'touchcancel':
        case 'touchend':
        case 'touchstart':
        case 'volumechange':
        case 'change':
        case 'selectionchange':
        case 'textInput':
        case 'compositionstart':
        case 'compositionend':
        case 'compositionupdate':
        case 'beforeblur':
        case 'afterblur':
        case 'beforeinput':
        case 'blur':
        case 'fullscreenchange':
        case 'focus':
        case 'hashchange':
        case 'popstate':
        case 'select':
        case 'selectstart':
            return 1;
        case 'drag':
        case 'dragenter':
        case 'dragexit':
        case 'dragleave':
        case 'dragover':
        case 'mousemove':
        case 'mouseout':
        case 'mouseover':
        case 'pointermove':
        case 'pointerout':
        case 'pointerover':
        case 'scroll':
        case 'toggle':
        case 'touchmove':
        case 'wheel':
        case 'mouseenter':
        case 'mouseleave':
        case 'pointerenter':
        case 'pointerleave':
            return 4;
        case 'message':
            switch (ZP()) {
                case Ny:
                    return 1;
                case qT:
                    return 4;
                case bp:
                case KP:
                    return 16;
                case ZT:
                    return 536870912;
                default:
                    return 16;
            }
        default:
            return 16;
    }
}
var Mo = null,
    Fy = null,
    lp = null;
function rA() {
    if (lp) return lp;
    var n,
        e = Fy,
        t = e.length,
        i,
        r = 'value' in Mo ? Mo.value : Mo.textContent,
        s = r.length;
    for (n = 0; n < t && e[n] === r[n]; n++);
    var o = t - n;
    for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
    return (lp = r.slice(n, 1 < i ? 1 - i : void 0));
}
function up(n) {
    var e = n.keyCode;
    return (
        'charCode' in n ? ((n = n.charCode), n === 0 && e === 13 && (n = 13)) : (n = e),
        n === 10 && (n = 13),
        32 <= n || n === 13 ? n : 0
    );
}
function Jd() {
    return !0;
}
function nM() {
    return !1;
}
function rr(n) {
    function e(t, i, r, s, o) {
        (this._reactName = t),
            (this._targetInst = r),
            (this.type = i),
            (this.nativeEvent = s),
            (this.target = o),
            (this.currentTarget = null);
        for (var a in n) n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
        return (
            (this.isDefaultPrevented = (
                s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
            )
                ? Jd
                : nM),
            (this.isPropagationStopped = nM),
            this
        );
    }
    return (
        gn(e.prototype, {
            preventDefault: function () {
                this.defaultPrevented = !0;
                var t = this.nativeEvent;
                t &&
                    (t.preventDefault
                        ? t.preventDefault()
                        : typeof t.returnValue != 'unknown' && (t.returnValue = !1),
                    (this.isDefaultPrevented = Jd));
            },
            stopPropagation: function () {
                var t = this.nativeEvent;
                t &&
                    (t.stopPropagation
                        ? t.stopPropagation()
                        : typeof t.cancelBubble != 'unknown' && (t.cancelBubble = !0),
                    (this.isPropagationStopped = Jd));
            },
            persist: function () {},
            isPersistent: Jd,
        }),
        e
    );
}
var Tu = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (n) {
            return n.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0,
    },
    ky = rr(Tu),
    Of = gn({}, Tu, { view: 0, detail: 0 }),
    u3 = rr(Of),
    dv,
    hv,
    nc,
    cm = gn({}, Of, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: zy,
        button: 0,
        buttons: 0,
        relatedTarget: function (n) {
            return n.relatedTarget === void 0
                ? n.fromElement === n.srcElement
                    ? n.toElement
                    : n.fromElement
                : n.relatedTarget;
        },
        movementX: function (n) {
            return 'movementX' in n
                ? n.movementX
                : (n !== nc &&
                      (nc && n.type === 'mousemove'
                          ? ((dv = n.screenX - nc.screenX), (hv = n.screenY - nc.screenY))
                          : (hv = dv = 0),
                      (nc = n)),
                  dv);
        },
        movementY: function (n) {
            return 'movementY' in n ? n.movementY : hv;
        },
    }),
    iM = rr(cm),
    c3 = gn({}, cm, { dataTransfer: 0 }),
    f3 = rr(c3),
    d3 = gn({}, Of, { relatedTarget: 0 }),
    pv = rr(d3),
    h3 = gn({}, Tu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    p3 = rr(h3),
    m3 = gn({}, Tu, {
        clipboardData: function (n) {
            return 'clipboardData' in n ? n.clipboardData : window.clipboardData;
        },
    }),
    g3 = rr(m3),
    v3 = gn({}, Tu, { data: 0 }),
    rM = rr(v3),
    _3 = {
        Esc: 'Escape',
        Spacebar: ' ',
        Left: 'ArrowLeft',
        Up: 'ArrowUp',
        Right: 'ArrowRight',
        Down: 'ArrowDown',
        Del: 'Delete',
        Win: 'OS',
        Menu: 'ContextMenu',
        Apps: 'ContextMenu',
        Scroll: 'ScrollLock',
        MozPrintableKey: 'Unidentified',
    },
    y3 = {
        8: 'Backspace',
        9: 'Tab',
        12: 'Clear',
        13: 'Enter',
        16: 'Shift',
        17: 'Control',
        18: 'Alt',
        19: 'Pause',
        20: 'CapsLock',
        27: 'Escape',
        32: ' ',
        33: 'PageUp',
        34: 'PageDown',
        35: 'End',
        36: 'Home',
        37: 'ArrowLeft',
        38: 'ArrowUp',
        39: 'ArrowRight',
        40: 'ArrowDown',
        45: 'Insert',
        46: 'Delete',
        112: 'F1',
        113: 'F2',
        114: 'F3',
        115: 'F4',
        116: 'F5',
        117: 'F6',
        118: 'F7',
        119: 'F8',
        120: 'F9',
        121: 'F10',
        122: 'F11',
        123: 'F12',
        144: 'NumLock',
        145: 'ScrollLock',
        224: 'Meta',
    },
    x3 = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' };
function S3(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = x3[n]) ? !!e[n] : !1;
}
function zy() {
    return S3;
}
var M3 = gn({}, Of, {
        key: function (n) {
            if (n.key) {
                var e = _3[n.key] || n.key;
                if (e !== 'Unidentified') return e;
            }
            return n.type === 'keypress'
                ? ((n = up(n)), n === 13 ? 'Enter' : String.fromCharCode(n))
                : n.type === 'keydown' || n.type === 'keyup'
                ? y3[n.keyCode] || 'Unidentified'
                : '';
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: zy,
        charCode: function (n) {
            return n.type === 'keypress' ? up(n) : 0;
        },
        keyCode: function (n) {
            return n.type === 'keydown' || n.type === 'keyup' ? n.keyCode : 0;
        },
        which: function (n) {
            return n.type === 'keypress'
                ? up(n)
                : n.type === 'keydown' || n.type === 'keyup'
                ? n.keyCode
                : 0;
        },
    }),
    w3 = rr(M3),
    E3 = gn({}, cm, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0,
    }),
    sM = rr(E3),
    T3 = gn({}, Of, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: zy,
    }),
    A3 = rr(T3),
    C3 = gn({}, Tu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    b3 = rr(C3),
    R3 = gn({}, cm, {
        deltaX: function (n) {
            return 'deltaX' in n ? n.deltaX : 'wheelDeltaX' in n ? -n.wheelDeltaX : 0;
        },
        deltaY: function (n) {
            return 'deltaY' in n
                ? n.deltaY
                : 'wheelDeltaY' in n
                ? -n.wheelDeltaY
                : 'wheelDelta' in n
                ? -n.wheelDelta
                : 0;
        },
        deltaZ: 0,
        deltaMode: 0,
    }),
    P3 = rr(R3),
    L3 = [9, 13, 27, 32],
    By = zs && 'CompositionEvent' in window,
    Nc = null;
zs && 'documentMode' in document && (Nc = document.documentMode);
var I3 = zs && 'TextEvent' in window && !Nc,
    sA = zs && (!By || (Nc && 8 < Nc && 11 >= Nc)),
    oM = String.fromCharCode(32),
    aM = !1;
function oA(n, e) {
    switch (n) {
        case 'keyup':
            return L3.indexOf(e.keyCode) !== -1;
        case 'keydown':
            return e.keyCode !== 229;
        case 'keypress':
        case 'mousedown':
        case 'focusout':
            return !0;
        default:
            return !1;
    }
}
function aA(n) {
    return (n = n.detail), typeof n == 'object' && 'data' in n ? n.data : null;
}
var Bl = !1;
function N3(n, e) {
    switch (n) {
        case 'compositionend':
            return aA(e);
        case 'keypress':
            return e.which !== 32 ? null : ((aM = !0), oM);
        case 'textInput':
            return (n = e.data), n === oM && aM ? null : n;
        default:
            return null;
    }
}
function D3(n, e) {
    if (Bl)
        return n === 'compositionend' || (!By && oA(n, e))
            ? ((n = rA()), (lp = Fy = Mo = null), (Bl = !1), n)
            : null;
    switch (n) {
        case 'paste':
            return null;
        case 'keypress':
            if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
                if (e.char && 1 < e.char.length) return e.char;
                if (e.which) return String.fromCharCode(e.which);
            }
            return null;
        case 'compositionend':
            return sA && e.locale !== 'ko' ? null : e.data;
        default:
            return null;
    }
}
var U3 = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
};
function lM(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === 'input' ? !!U3[n.type] : e === 'textarea';
}
function lA(n, e, t, i) {
    zT(i),
        (e = Ip(e, 'onChange')),
        0 < e.length &&
            ((t = new ky('onChange', 'change', null, t, i)), n.push({ event: t, listeners: e }));
}
var Dc = null,
    Qc = null;
function O3(n) {
    yA(n, 0);
}
function fm(n) {
    var e = Gl(n);
    if (IT(e)) return n;
}
function F3(n, e) {
    if (n === 'change') return e;
}
var uA = !1;
if (zs) {
    var mv;
    if (zs) {
        var gv = 'oninput' in document;
        if (!gv) {
            var uM = document.createElement('div');
            uM.setAttribute('oninput', 'return;'), (gv = typeof uM.oninput == 'function');
        }
        mv = gv;
    } else mv = !1;
    uA = mv && (!document.documentMode || 9 < document.documentMode);
}
function cM() {
    Dc && (Dc.detachEvent('onpropertychange', cA), (Qc = Dc = null));
}
function cA(n) {
    if (n.propertyName === 'value' && fm(Qc)) {
        var e = [];
        lA(e, Qc, n, Iy(n)), GT(O3, e);
    }
}
function k3(n, e, t) {
    n === 'focusin'
        ? (cM(), (Dc = e), (Qc = t), Dc.attachEvent('onpropertychange', cA))
        : n === 'focusout' && cM();
}
function z3(n) {
    if (n === 'selectionchange' || n === 'keyup' || n === 'keydown') return fm(Qc);
}
function B3(n, e) {
    if (n === 'click') return fm(e);
}
function H3(n, e) {
    if (n === 'input' || n === 'change') return fm(e);
}
function V3(n, e) {
    return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var Hr = typeof Object.is == 'function' ? Object.is : V3;
function $c(n, e) {
    if (Hr(n, e)) return !0;
    if (typeof n != 'object' || n === null || typeof e != 'object' || e === null) return !1;
    var t = Object.keys(n),
        i = Object.keys(e);
    if (t.length !== i.length) return !1;
    for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (!N0.call(e, r) || !Hr(n[r], e[r])) return !1;
    }
    return !0;
}
function fM(n) {
    for (; n && n.firstChild; ) n = n.firstChild;
    return n;
}
function dM(n, e) {
    var t = fM(n);
    n = 0;
    for (var i; t; ) {
        if (t.nodeType === 3) {
            if (((i = n + t.textContent.length), n <= e && i >= e))
                return { node: t, offset: e - n };
            n = i;
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e;
                }
                t = t.parentNode;
            }
            t = void 0;
        }
        t = fM(t);
    }
}
function fA(n, e) {
    return n && e
        ? n === e
            ? !0
            : n && n.nodeType === 3
            ? !1
            : e && e.nodeType === 3
            ? fA(n, e.parentNode)
            : 'contains' in n
            ? n.contains(e)
            : n.compareDocumentPosition
            ? !!(n.compareDocumentPosition(e) & 16)
            : !1
        : !1;
}
function dA() {
    for (var n = window, e = Tp(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == 'string';
        } catch {
            t = !1;
        }
        if (t) n = e.contentWindow;
        else break;
        e = Tp(n.document);
    }
    return e;
}
function Hy(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return (
        e &&
        ((e === 'input' &&
            (n.type === 'text' ||
                n.type === 'search' ||
                n.type === 'tel' ||
                n.type === 'url' ||
                n.type === 'password')) ||
            e === 'textarea' ||
            n.contentEditable === 'true')
    );
}
function G3(n) {
    var e = dA(),
        t = n.focusedElem,
        i = n.selectionRange;
    if (e !== t && t && t.ownerDocument && fA(t.ownerDocument.documentElement, t)) {
        if (i !== null && Hy(t)) {
            if (((e = i.start), (n = i.end), n === void 0 && (n = e), 'selectionStart' in t))
                (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
            else if (
                ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
                n.getSelection)
            ) {
                n = n.getSelection();
                var r = t.textContent.length,
                    s = Math.min(i.start, r);
                (i = i.end === void 0 ? s : Math.min(i.end, r)),
                    !n.extend && s > i && ((r = i), (i = s), (s = r)),
                    (r = dM(t, s));
                var o = dM(t, i);
                r &&
                    o &&
                    (n.rangeCount !== 1 ||
                        n.anchorNode !== r.node ||
                        n.anchorOffset !== r.offset ||
                        n.focusNode !== o.node ||
                        n.focusOffset !== o.offset) &&
                    ((e = e.createRange()),
                    e.setStart(r.node, r.offset),
                    n.removeAllRanges(),
                    s > i
                        ? (n.addRange(e), n.extend(o.node, o.offset))
                        : (e.setEnd(o.node, o.offset), n.addRange(e)));
            }
        }
        for (e = [], n = t; (n = n.parentNode); )
            n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
        for (typeof t.focus == 'function' && t.focus(), t = 0; t < e.length; t++)
            (n = e[t]), (n.element.scrollLeft = n.left), (n.element.scrollTop = n.top);
    }
}
var W3 = zs && 'documentMode' in document && 11 >= document.documentMode,
    Hl = null,
    Q0 = null,
    Uc = null,
    $0 = !1;
function hM(n, e, t) {
    var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    $0 ||
        Hl == null ||
        Hl !== Tp(i) ||
        ((i = Hl),
        'selectionStart' in i && Hy(i)
            ? (i = { start: i.selectionStart, end: i.selectionEnd })
            : ((i = ((i.ownerDocument && i.ownerDocument.defaultView) || window).getSelection()),
              (i = {
                  anchorNode: i.anchorNode,
                  anchorOffset: i.anchorOffset,
                  focusNode: i.focusNode,
                  focusOffset: i.focusOffset,
              })),
        (Uc && $c(Uc, i)) ||
            ((Uc = i),
            (i = Ip(Q0, 'onSelect')),
            0 < i.length &&
                ((e = new ky('onSelect', 'select', null, e, t)),
                n.push({ event: e, listeners: i }),
                (e.target = Hl))));
}
function Qd(n, e) {
    var t = {};
    return (
        (t[n.toLowerCase()] = e.toLowerCase()),
        (t['Webkit' + n] = 'webkit' + e),
        (t['Moz' + n] = 'moz' + e),
        t
    );
}
var Vl = {
        animationend: Qd('Animation', 'AnimationEnd'),
        animationiteration: Qd('Animation', 'AnimationIteration'),
        animationstart: Qd('Animation', 'AnimationStart'),
        transitionend: Qd('Transition', 'TransitionEnd'),
    },
    vv = {},
    hA = {};
zs &&
    ((hA = document.createElement('div').style),
    'AnimationEvent' in window ||
        (delete Vl.animationend.animation,
        delete Vl.animationiteration.animation,
        delete Vl.animationstart.animation),
    'TransitionEvent' in window || delete Vl.transitionend.transition);
function dm(n) {
    if (vv[n]) return vv[n];
    if (!Vl[n]) return n;
    var e = Vl[n],
        t;
    for (t in e) if (e.hasOwnProperty(t) && t in hA) return (vv[n] = e[t]);
    return n;
}
var pA = dm('animationend'),
    mA = dm('animationiteration'),
    gA = dm('animationstart'),
    vA = dm('transitionend'),
    _A = new Map(),
    pM =
        'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
            ' '
        );
function zo(n, e) {
    _A.set(n, e), ja(e, [n]);
}
for (var _v = 0; _v < pM.length; _v++) {
    var yv = pM[_v],
        j3 = yv.toLowerCase(),
        X3 = yv[0].toUpperCase() + yv.slice(1);
    zo(j3, 'on' + X3);
}
zo(pA, 'onAnimationEnd');
zo(mA, 'onAnimationIteration');
zo(gA, 'onAnimationStart');
zo('dblclick', 'onDoubleClick');
zo('focusin', 'onFocus');
zo('focusout', 'onBlur');
zo(vA, 'onTransitionEnd');
fu('onMouseEnter', ['mouseout', 'mouseover']);
fu('onMouseLeave', ['mouseout', 'mouseover']);
fu('onPointerEnter', ['pointerout', 'pointerover']);
fu('onPointerLeave', ['pointerout', 'pointerover']);
ja('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '));
ja(
    'onSelect',
    'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
        ' '
    )
);
ja('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
ja('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '));
ja('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' '));
ja('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' '));
var Rc =
        'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
            ' '
        ),
    Y3 = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Rc));
function mM(n, e, t) {
    var i = n.type || 'unknown-event';
    (n.currentTarget = t), jP(i, e, void 0, n), (n.currentTarget = null);
}
function yA(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var i = n[t],
            r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o],
                        c = a.instance,
                        f = a.currentTarget;
                    if (((a = a.listener), c !== s && r.isPropagationStopped())) break e;
                    mM(r, a, f), (s = c);
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (
                        ((a = i[o]),
                        (c = a.instance),
                        (f = a.currentTarget),
                        (a = a.listener),
                        c !== s && r.isPropagationStopped())
                    )
                        break e;
                    mM(r, a, f), (s = c);
                }
        }
    }
    if (Cp) throw ((n = q0), (Cp = !1), (q0 = null), n);
}
function en(n, e) {
    var t = e[r_];
    t === void 0 && (t = e[r_] = new Set());
    var i = n + '__bubble';
    t.has(i) || (xA(e, n, 2, !1), t.add(i));
}
function xv(n, e, t) {
    var i = 0;
    e && (i |= 4), xA(t, n, i, e);
}
var $d = '_reactListening' + Math.random().toString(36).slice(2);
function ef(n) {
    if (!n[$d]) {
        (n[$d] = !0),
            CT.forEach(function (t) {
                t !== 'selectionchange' && (Y3.has(t) || xv(t, !1, n), xv(t, !0, n));
            });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[$d] || ((e[$d] = !0), xv('selectionchange', !1, e));
    }
}
function xA(n, e, t, i) {
    switch (iA(e)) {
        case 1:
            var r = a3;
            break;
        case 4:
            r = l3;
            break;
        default:
            r = Oy;
    }
    (t = r.bind(null, e, t, n)),
        (r = void 0),
        !Y0 || (e !== 'touchstart' && e !== 'touchmove' && e !== 'wheel') || (r = !0),
        i
            ? r !== void 0
                ? n.addEventListener(e, t, { capture: !0, passive: r })
                : n.addEventListener(e, t, !0)
            : r !== void 0
            ? n.addEventListener(e, t, { passive: r })
            : n.addEventListener(e, t, !1);
}
function Sv(n, e, t, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null)
        e: for (;;) {
            if (i === null) return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var c = o.tag;
                        if (
                            (c === 3 || c === 4) &&
                            ((c = o.stateNode.containerInfo),
                            c === r || (c.nodeType === 8 && c.parentNode === r))
                        )
                            return;
                        o = o.return;
                    }
                for (; a !== null; ) {
                    if (((o = Sa(a)), o === null)) return;
                    if (((c = o.tag), c === 5 || c === 6)) {
                        i = s = o;
                        continue e;
                    }
                    a = a.parentNode;
                }
            }
            i = i.return;
        }
    GT(function () {
        var f = s,
            d = Iy(t),
            h = [];
        e: {
            var p = _A.get(n);
            if (p !== void 0) {
                var v = ky,
                    _ = n;
                switch (n) {
                    case 'keypress':
                        if (up(t) === 0) break e;
                    case 'keydown':
                    case 'keyup':
                        v = w3;
                        break;
                    case 'focusin':
                        (_ = 'focus'), (v = pv);
                        break;
                    case 'focusout':
                        (_ = 'blur'), (v = pv);
                        break;
                    case 'beforeblur':
                    case 'afterblur':
                        v = pv;
                        break;
                    case 'click':
                        if (t.button === 2) break e;
                    case 'auxclick':
                    case 'dblclick':
                    case 'mousedown':
                    case 'mousemove':
                    case 'mouseup':
                    case 'mouseout':
                    case 'mouseover':
                    case 'contextmenu':
                        v = iM;
                        break;
                    case 'drag':
                    case 'dragend':
                    case 'dragenter':
                    case 'dragexit':
                    case 'dragleave':
                    case 'dragover':
                    case 'dragstart':
                    case 'drop':
                        v = f3;
                        break;
                    case 'touchcancel':
                    case 'touchend':
                    case 'touchmove':
                    case 'touchstart':
                        v = A3;
                        break;
                    case pA:
                    case mA:
                    case gA:
                        v = p3;
                        break;
                    case vA:
                        v = b3;
                        break;
                    case 'scroll':
                        v = u3;
                        break;
                    case 'wheel':
                        v = P3;
                        break;
                    case 'copy':
                    case 'cut':
                    case 'paste':
                        v = g3;
                        break;
                    case 'gotpointercapture':
                    case 'lostpointercapture':
                    case 'pointercancel':
                    case 'pointerdown':
                    case 'pointermove':
                    case 'pointerout':
                    case 'pointerover':
                    case 'pointerup':
                        v = sM;
                }
                var w = (e & 4) !== 0,
                    x = !w && n === 'scroll',
                    g = w ? (p !== null ? p + 'Capture' : null) : p;
                w = [];
                for (var S = f, M; S !== null; ) {
                    M = S;
                    var T = M.stateNode;
                    if (
                        (M.tag === 5 &&
                            T !== null &&
                            ((M = T),
                            g !== null && ((T = qc(S, g)), T != null && w.push(tf(S, T, M)))),
                        x)
                    )
                        break;
                    S = S.return;
                }
                0 < w.length && ((p = new v(p, _, null, t, d)), h.push({ event: p, listeners: w }));
            }
        }
        if (!(e & 7)) {
            e: {
                if (
                    ((p = n === 'mouseover' || n === 'pointerover'),
                    (v = n === 'mouseout' || n === 'pointerout'),
                    p && t !== j0 && (_ = t.relatedTarget || t.fromElement) && (Sa(_) || _[Bs]))
                )
                    break e;
                if (
                    (v || p) &&
                    ((p =
                        d.window === d
                            ? d
                            : (p = d.ownerDocument)
                            ? p.defaultView || p.parentWindow
                            : window),
                    v
                        ? ((_ = t.relatedTarget || t.toElement),
                          (v = f),
                          (_ = _ ? Sa(_) : null),
                          _ !== null &&
                              ((x = Xa(_)), _ !== x || (_.tag !== 5 && _.tag !== 6)) &&
                              (_ = null))
                        : ((v = null), (_ = f)),
                    v !== _)
                ) {
                    if (
                        ((w = iM),
                        (T = 'onMouseLeave'),
                        (g = 'onMouseEnter'),
                        (S = 'mouse'),
                        (n === 'pointerout' || n === 'pointerover') &&
                            ((w = sM),
                            (T = 'onPointerLeave'),
                            (g = 'onPointerEnter'),
                            (S = 'pointer')),
                        (x = v == null ? p : Gl(v)),
                        (M = _ == null ? p : Gl(_)),
                        (p = new w(T, S + 'leave', v, t, d)),
                        (p.target = x),
                        (p.relatedTarget = M),
                        (T = null),
                        Sa(d) === f &&
                            ((w = new w(g, S + 'enter', _, t, d)),
                            (w.target = M),
                            (w.relatedTarget = x),
                            (T = w)),
                        (x = T),
                        v && _)
                    )
                        t: {
                            for (w = v, g = _, S = 0, M = w; M; M = fl(M)) S++;
                            for (M = 0, T = g; T; T = fl(T)) M++;
                            for (; 0 < S - M; ) (w = fl(w)), S--;
                            for (; 0 < M - S; ) (g = fl(g)), M--;
                            for (; S--; ) {
                                if (w === g || (g !== null && w === g.alternate)) break t;
                                (w = fl(w)), (g = fl(g));
                            }
                            w = null;
                        }
                    else w = null;
                    v !== null && gM(h, p, v, w, !1),
                        _ !== null && x !== null && gM(h, x, _, w, !0);
                }
            }
            e: {
                if (
                    ((p = f ? Gl(f) : window),
                    (v = p.nodeName && p.nodeName.toLowerCase()),
                    v === 'select' || (v === 'input' && p.type === 'file'))
                )
                    var P = F3;
                else if (lM(p))
                    if (uA) P = H3;
                    else {
                        P = z3;
                        var A = k3;
                    }
                else
                    (v = p.nodeName) &&
                        v.toLowerCase() === 'input' &&
                        (p.type === 'checkbox' || p.type === 'radio') &&
                        (P = B3);
                if (P && (P = P(n, f))) {
                    lA(h, P, t, d);
                    break e;
                }
                A && A(n, p, f),
                    n === 'focusout' &&
                        (A = p._wrapperState) &&
                        A.controlled &&
                        p.type === 'number' &&
                        B0(p, 'number', p.value);
            }
            switch (((A = f ? Gl(f) : window), n)) {
                case 'focusin':
                    (lM(A) || A.contentEditable === 'true') && ((Hl = A), (Q0 = f), (Uc = null));
                    break;
                case 'focusout':
                    Uc = Q0 = Hl = null;
                    break;
                case 'mousedown':
                    $0 = !0;
                    break;
                case 'contextmenu':
                case 'mouseup':
                case 'dragend':
                    ($0 = !1), hM(h, t, d);
                    break;
                case 'selectionchange':
                    if (W3) break;
                case 'keydown':
                case 'keyup':
                    hM(h, t, d);
            }
            var R;
            if (By)
                e: {
                    switch (n) {
                        case 'compositionstart':
                            var D = 'onCompositionStart';
                            break e;
                        case 'compositionend':
                            D = 'onCompositionEnd';
                            break e;
                        case 'compositionupdate':
                            D = 'onCompositionUpdate';
                            break e;
                    }
                    D = void 0;
                }
            else
                Bl
                    ? oA(n, t) && (D = 'onCompositionEnd')
                    : n === 'keydown' && t.keyCode === 229 && (D = 'onCompositionStart');
            D &&
                (sA &&
                    t.locale !== 'ko' &&
                    (Bl || D !== 'onCompositionStart'
                        ? D === 'onCompositionEnd' && Bl && (R = rA())
                        : ((Mo = d), (Fy = 'value' in Mo ? Mo.value : Mo.textContent), (Bl = !0))),
                (A = Ip(f, D)),
                0 < A.length &&
                    ((D = new rM(D, n, null, t, d)),
                    h.push({ event: D, listeners: A }),
                    R ? (D.data = R) : ((R = aA(t)), R !== null && (D.data = R)))),
                (R = I3 ? N3(n, t) : D3(n, t)) &&
                    ((f = Ip(f, 'onBeforeInput')),
                    0 < f.length &&
                        ((d = new rM('onBeforeInput', 'beforeinput', null, t, d)),
                        h.push({ event: d, listeners: f }),
                        (d.data = R)));
        }
        yA(h, e);
    });
}
function tf(n, e, t) {
    return { instance: n, listener: e, currentTarget: t };
}
function Ip(n, e) {
    for (var t = e + 'Capture', i = []; n !== null; ) {
        var r = n,
            s = r.stateNode;
        r.tag === 5 &&
            s !== null &&
            ((r = s),
            (s = qc(n, t)),
            s != null && i.unshift(tf(n, s, r)),
            (s = qc(n, e)),
            s != null && i.push(tf(n, s, r))),
            (n = n.return);
    }
    return i;
}
function fl(n) {
    if (n === null) return null;
    do n = n.return;
    while (n && n.tag !== 5);
    return n || null;
}
function gM(n, e, t, i, r) {
    for (var s = e._reactName, o = []; t !== null && t !== i; ) {
        var a = t,
            c = a.alternate,
            f = a.stateNode;
        if (c !== null && c === i) break;
        a.tag === 5 &&
            f !== null &&
            ((a = f),
            r
                ? ((c = qc(t, s)), c != null && o.unshift(tf(t, c, a)))
                : r || ((c = qc(t, s)), c != null && o.push(tf(t, c, a)))),
            (t = t.return);
    }
    o.length !== 0 && n.push({ event: e, listeners: o });
}
var q3 = /\r\n?/g,
    Z3 = /\u0000|\uFFFD/g;
function vM(n) {
    return (typeof n == 'string' ? n : '' + n)
        .replace(
            q3,
            `
`
        )
        .replace(Z3, '');
}
function eh(n, e, t) {
    if (((e = vM(e)), vM(n) !== e && t)) throw Error(Te(425));
}
function Np() {}
var e_ = null,
    t_ = null;
function n_(n, e) {
    return (
        n === 'textarea' ||
        n === 'noscript' ||
        typeof e.children == 'string' ||
        typeof e.children == 'number' ||
        (typeof e.dangerouslySetInnerHTML == 'object' &&
            e.dangerouslySetInnerHTML !== null &&
            e.dangerouslySetInnerHTML.__html != null)
    );
}
var i_ = typeof setTimeout == 'function' ? setTimeout : void 0,
    K3 = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    _M = typeof Promise == 'function' ? Promise : void 0,
    J3 =
        typeof queueMicrotask == 'function'
            ? queueMicrotask
            : typeof _M < 'u'
            ? function (n) {
                  return _M.resolve(null).then(n).catch(Q3);
              }
            : i_;
function Q3(n) {
    setTimeout(function () {
        throw n;
    });
}
function Mv(n, e) {
    var t = e,
        i = 0;
    do {
        var r = t.nextSibling;
        if ((n.removeChild(t), r && r.nodeType === 8))
            if (((t = r.data), t === '/$')) {
                if (i === 0) {
                    n.removeChild(r), Jc(e);
                    return;
                }
                i--;
            } else (t !== '$' && t !== '$?' && t !== '$!') || i++;
        t = r;
    } while (t);
    Jc(e);
}
function Co(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
            if (((e = n.data), e === '$' || e === '$!' || e === '$?')) break;
            if (e === '/$') return null;
        }
    }
    return n;
}
function yM(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === '$' || t === '$!' || t === '$?') {
                if (e === 0) return n;
                e--;
            } else t === '/$' && e++;
        }
        n = n.previousSibling;
    }
    return null;
}
var Au = Math.random().toString(36).slice(2),
    ss = '__reactFiber$' + Au,
    nf = '__reactProps$' + Au,
    Bs = '__reactContainer$' + Au,
    r_ = '__reactEvents$' + Au,
    $3 = '__reactListeners$' + Au,
    eL = '__reactHandles$' + Au;
function Sa(n) {
    var e = n[ss];
    if (e) return e;
    for (var t = n.parentNode; t; ) {
        if ((e = t[Bs] || t[ss])) {
            if (((t = e.alternate), e.child !== null || (t !== null && t.child !== null)))
                for (n = yM(n); n !== null; ) {
                    if ((t = n[ss])) return t;
                    n = yM(n);
                }
            return e;
        }
        (n = t), (t = n.parentNode);
    }
    return null;
}
function Ff(n) {
    return (
        (n = n[ss] || n[Bs]),
        !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
    );
}
function Gl(n) {
    if (n.tag === 5 || n.tag === 6) return n.stateNode;
    throw Error(Te(33));
}
function hm(n) {
    return n[nf] || null;
}
var s_ = [],
    Wl = -1;
function Bo(n) {
    return { current: n };
}
function tn(n) {
    0 > Wl || ((n.current = s_[Wl]), (s_[Wl] = null), Wl--);
}
function Qt(n, e) {
    Wl++, (s_[Wl] = n.current), (n.current = e);
}
var Oo = {},
    gi = Bo(Oo),
    Fi = Bo(!1),
    Fa = Oo;
function du(n, e) {
    var t = n.type.contextTypes;
    if (!t) return Oo;
    var i = n.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {},
        s;
    for (s in t) r[s] = e[s];
    return (
        i &&
            ((n = n.stateNode),
            (n.__reactInternalMemoizedUnmaskedChildContext = e),
            (n.__reactInternalMemoizedMaskedChildContext = r)),
        r
    );
}
function ki(n) {
    return (n = n.childContextTypes), n != null;
}
function Dp() {
    tn(Fi), tn(gi);
}
function xM(n, e, t) {
    if (gi.current !== Oo) throw Error(Te(168));
    Qt(gi, e), Qt(Fi, t);
}
function SA(n, e, t) {
    var i = n.stateNode;
    if (((e = e.childContextTypes), typeof i.getChildContext != 'function')) return t;
    i = i.getChildContext();
    for (var r in i) if (!(r in e)) throw Error(Te(108, kP(n) || 'Unknown', r));
    return gn({}, t, i);
}
function Up(n) {
    return (
        (n = ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Oo),
        (Fa = gi.current),
        Qt(gi, n),
        Qt(Fi, Fi.current),
        !0
    );
}
function SM(n, e, t) {
    var i = n.stateNode;
    if (!i) throw Error(Te(169));
    t
        ? ((n = SA(n, e, Fa)),
          (i.__reactInternalMemoizedMergedChildContext = n),
          tn(Fi),
          tn(gi),
          Qt(gi, n))
        : tn(Fi),
        Qt(Fi, t);
}
var Rs = null,
    pm = !1,
    wv = !1;
function MA(n) {
    Rs === null ? (Rs = [n]) : Rs.push(n);
}
function tL(n) {
    (pm = !0), MA(n);
}
function Ho() {
    if (!wv && Rs !== null) {
        wv = !0;
        var n = 0,
            e = jt;
        try {
            var t = Rs;
            for (jt = 1; n < t.length; n++) {
                var i = t[n];
                do i = i(!0);
                while (i !== null);
            }
            (Rs = null), (pm = !1);
        } catch (r) {
            throw (Rs !== null && (Rs = Rs.slice(n + 1)), YT(Ny, Ho), r);
        } finally {
            (jt = e), (wv = !1);
        }
    }
    return null;
}
var jl = [],
    Xl = 0,
    Op = null,
    Fp = 0,
    yr = [],
    xr = 0,
    ka = null,
    Is = 1,
    Ns = '';
function ma(n, e) {
    (jl[Xl++] = Fp), (jl[Xl++] = Op), (Op = n), (Fp = e);
}
function wA(n, e, t) {
    (yr[xr++] = Is), (yr[xr++] = Ns), (yr[xr++] = ka), (ka = n);
    var i = Is;
    n = Ns;
    var r = 32 - zr(i) - 1;
    (i &= ~(1 << r)), (t += 1);
    var s = 32 - zr(e) + r;
    if (30 < s) {
        var o = r - (r % 5);
        (s = (i & ((1 << o) - 1)).toString(32)),
            (i >>= o),
            (r -= o),
            (Is = (1 << (32 - zr(e) + r)) | (t << r) | i),
            (Ns = s + n);
    } else (Is = (1 << s) | (t << r) | i), (Ns = n);
}
function Vy(n) {
    n.return !== null && (ma(n, 1), wA(n, 1, 0));
}
function Gy(n) {
    for (; n === Op; ) (Op = jl[--Xl]), (jl[Xl] = null), (Fp = jl[--Xl]), (jl[Xl] = null);
    for (; n === ka; )
        (ka = yr[--xr]),
            (yr[xr] = null),
            (Ns = yr[--xr]),
            (yr[xr] = null),
            (Is = yr[--xr]),
            (yr[xr] = null);
}
var $i = null,
    Qi = null,
    an = !1,
    Fr = null;
function EA(n, e) {
    var t = Sr(5, null, null, 0);
    (t.elementType = 'DELETED'),
        (t.stateNode = e),
        (t.return = n),
        (e = n.deletions),
        e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function MM(n, e) {
    switch (n.tag) {
        case 5:
            var t = n.type;
            return (
                (e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e),
                e !== null ? ((n.stateNode = e), ($i = n), (Qi = Co(e.firstChild)), !0) : !1
            );
        case 6:
            return (
                (e = n.pendingProps === '' || e.nodeType !== 3 ? null : e),
                e !== null ? ((n.stateNode = e), ($i = n), (Qi = null), !0) : !1
            );
        case 13:
            return (
                (e = e.nodeType !== 8 ? null : e),
                e !== null
                    ? ((t = ka !== null ? { id: Is, overflow: Ns } : null),
                      (n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }),
                      (t = Sr(18, null, null, 0)),
                      (t.stateNode = e),
                      (t.return = n),
                      (n.child = t),
                      ($i = n),
                      (Qi = null),
                      !0)
                    : !1
            );
        default:
            return !1;
    }
}
function o_(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function a_(n) {
    if (an) {
        var e = Qi;
        if (e) {
            var t = e;
            if (!MM(n, e)) {
                if (o_(n)) throw Error(Te(418));
                e = Co(t.nextSibling);
                var i = $i;
                e && MM(n, e) ? EA(i, t) : ((n.flags = (n.flags & -4097) | 2), (an = !1), ($i = n));
            }
        } else {
            if (o_(n)) throw Error(Te(418));
            (n.flags = (n.flags & -4097) | 2), (an = !1), ($i = n);
        }
    }
}
function wM(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; ) n = n.return;
    $i = n;
}
function th(n) {
    if (n !== $i) return !1;
    if (!an) return wM(n), (an = !0), !1;
    var e;
    if (
        ((e = n.tag !== 3) &&
            !(e = n.tag !== 5) &&
            ((e = n.type), (e = e !== 'head' && e !== 'body' && !n_(n.type, n.memoizedProps))),
        e && (e = Qi))
    ) {
        if (o_(n)) throw (TA(), Error(Te(418)));
        for (; e; ) EA(n, e), (e = Co(e.nextSibling));
    }
    if ((wM(n), n.tag === 13)) {
        if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
            throw Error(Te(317));
        e: {
            for (n = n.nextSibling, e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === '/$') {
                        if (e === 0) {
                            Qi = Co(n.nextSibling);
                            break e;
                        }
                        e--;
                    } else (t !== '$' && t !== '$!' && t !== '$?') || e++;
                }
                n = n.nextSibling;
            }
            Qi = null;
        }
    } else Qi = $i ? Co(n.stateNode.nextSibling) : null;
    return !0;
}
function TA() {
    for (var n = Qi; n; ) n = Co(n.nextSibling);
}
function hu() {
    (Qi = $i = null), (an = !1);
}
function Wy(n) {
    Fr === null ? (Fr = [n]) : Fr.push(n);
}
var nL = Xs.ReactCurrentBatchConfig;
function Nr(n, e) {
    if (n && n.defaultProps) {
        (e = gn({}, e)), (n = n.defaultProps);
        for (var t in n) e[t] === void 0 && (e[t] = n[t]);
        return e;
    }
    return e;
}
var kp = Bo(null),
    zp = null,
    Yl = null,
    jy = null;
function Xy() {
    jy = Yl = zp = null;
}
function Yy(n) {
    var e = kp.current;
    tn(kp), (n._currentValue = e);
}
function l_(n, e, t) {
    for (; n !== null; ) {
        var i = n.alternate;
        if (
            ((n.childLanes & e) !== e
                ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
                : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
            n === t)
        )
            break;
        n = n.return;
    }
}
function lu(n, e) {
    (zp = n),
        (jy = Yl = null),
        (n = n.dependencies),
        n !== null &&
            n.firstContext !== null &&
            (n.lanes & e && (Oi = !0), (n.firstContext = null));
}
function wr(n) {
    var e = n._currentValue;
    if (jy !== n)
        if (((n = { context: n, memoizedValue: e, next: null }), Yl === null)) {
            if (zp === null) throw Error(Te(308));
            (Yl = n), (zp.dependencies = { lanes: 0, firstContext: n });
        } else Yl = Yl.next = n;
    return e;
}
var Ma = null;
function qy(n) {
    Ma === null ? (Ma = [n]) : Ma.push(n);
}
function AA(n, e, t, i) {
    var r = e.interleaved;
    return (
        r === null ? ((t.next = t), qy(e)) : ((t.next = r.next), (r.next = t)),
        (e.interleaved = t),
        Hs(n, i)
    );
}
function Hs(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
        (n.childLanes |= e),
            (t = n.alternate),
            t !== null && (t.childLanes |= e),
            (t = n),
            (n = n.return);
    return t.tag === 3 ? t.stateNode : null;
}
var vo = !1;
function Zy(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, interleaved: null, lanes: 0 },
        effects: null,
    };
}
function CA(n, e) {
    (n = n.updateQueue),
        e.updateQueue === n &&
            (e.updateQueue = {
                baseState: n.baseState,
                firstBaseUpdate: n.firstBaseUpdate,
                lastBaseUpdate: n.lastBaseUpdate,
                shared: n.shared,
                effects: n.effects,
            });
}
function Fs(n, e) {
    return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null };
}
function bo(n, e, t) {
    var i = n.updateQueue;
    if (i === null) return null;
    if (((i = i.shared), Ot & 2)) {
        var r = i.pending;
        return (
            r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)), (i.pending = e), Hs(n, t)
        );
    }
    return (
        (r = i.interleaved),
        r === null ? ((e.next = e), qy(i)) : ((e.next = r.next), (r.next = e)),
        (i.interleaved = e),
        Hs(n, t)
    );
}
function cp(n, e, t) {
    if (((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))) {
        var i = e.lanes;
        (i &= n.pendingLanes), (t |= i), (e.lanes = t), Dy(n, t);
    }
}
function EM(n, e) {
    var t = n.updateQueue,
        i = n.alternate;
    if (i !== null && ((i = i.updateQueue), t === i)) {
        var r = null,
            s = null;
        if (((t = t.firstBaseUpdate), t !== null)) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null,
                };
                s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
            } while (t !== null);
            s === null ? (r = s = e) : (s = s.next = e);
        } else r = s = e;
        (t = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects,
        }),
            (n.updateQueue = t);
        return;
    }
    (n = t.lastBaseUpdate),
        n === null ? (t.firstBaseUpdate = e) : (n.next = e),
        (t.lastBaseUpdate = e);
}
function Bp(n, e, t, i) {
    var r = n.updateQueue;
    vo = !1;
    var s = r.firstBaseUpdate,
        o = r.lastBaseUpdate,
        a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var c = a,
            f = c.next;
        (c.next = null), o === null ? (s = f) : (o.next = f), (o = c);
        var d = n.alternate;
        d !== null &&
            ((d = d.updateQueue),
            (a = d.lastBaseUpdate),
            a !== o &&
                (a === null ? (d.firstBaseUpdate = f) : (a.next = f), (d.lastBaseUpdate = c)));
    }
    if (s !== null) {
        var h = r.baseState;
        (o = 0), (d = f = c = null), (a = s);
        do {
            var p = a.lane,
                v = a.eventTime;
            if ((i & p) === p) {
                d !== null &&
                    (d = d.next =
                        {
                            eventTime: v,
                            lane: 0,
                            tag: a.tag,
                            payload: a.payload,
                            callback: a.callback,
                            next: null,
                        });
                e: {
                    var _ = n,
                        w = a;
                    switch (((p = e), (v = t), w.tag)) {
                        case 1:
                            if (((_ = w.payload), typeof _ == 'function')) {
                                h = _.call(v, h, p);
                                break e;
                            }
                            h = _;
                            break e;
                        case 3:
                            _.flags = (_.flags & -65537) | 128;
                        case 0:
                            if (
                                ((_ = w.payload),
                                (p = typeof _ == 'function' ? _.call(v, h, p) : _),
                                p == null)
                            )
                                break e;
                            h = gn({}, h, p);
                            break e;
                        case 2:
                            vo = !0;
                    }
                }
                a.callback !== null &&
                    a.lane !== 0 &&
                    ((n.flags |= 64), (p = r.effects), p === null ? (r.effects = [a]) : p.push(a));
            } else
                (v = {
                    eventTime: v,
                    lane: p,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null,
                }),
                    d === null ? ((f = d = v), (c = h)) : (d = d.next = v),
                    (o |= p);
            if (((a = a.next), a === null)) {
                if (((a = r.shared.pending), a === null)) break;
                (p = a),
                    (a = p.next),
                    (p.next = null),
                    (r.lastBaseUpdate = p),
                    (r.shared.pending = null);
            }
        } while (1);
        if (
            (d === null && (c = h),
            (r.baseState = c),
            (r.firstBaseUpdate = f),
            (r.lastBaseUpdate = d),
            (e = r.shared.interleaved),
            e !== null)
        ) {
            r = e;
            do (o |= r.lane), (r = r.next);
            while (r !== e);
        } else s === null && (r.shared.lanes = 0);
        (Ba |= o), (n.lanes = o), (n.memoizedState = h);
    }
}
function TM(n, e, t) {
    if (((n = e.effects), (e.effects = null), n !== null))
        for (e = 0; e < n.length; e++) {
            var i = n[e],
                r = i.callback;
            if (r !== null) {
                if (((i.callback = null), (i = t), typeof r != 'function')) throw Error(Te(191, r));
                r.call(i);
            }
        }
}
var bA = new AT.Component().refs;
function u_(n, e, t, i) {
    (e = n.memoizedState),
        (t = t(i, e)),
        (t = t == null ? e : gn({}, e, t)),
        (n.memoizedState = t),
        n.lanes === 0 && (n.updateQueue.baseState = t);
}
var mm = {
    isMounted: function (n) {
        return (n = n._reactInternals) ? Xa(n) === n : !1;
    },
    enqueueSetState: function (n, e, t) {
        n = n._reactInternals;
        var i = Ti(),
            r = Po(n),
            s = Fs(i, r);
        (s.payload = e),
            t != null && (s.callback = t),
            (e = bo(n, s, r)),
            e !== null && (Br(e, n, r, i), cp(e, n, r));
    },
    enqueueReplaceState: function (n, e, t) {
        n = n._reactInternals;
        var i = Ti(),
            r = Po(n),
            s = Fs(i, r);
        (s.tag = 1),
            (s.payload = e),
            t != null && (s.callback = t),
            (e = bo(n, s, r)),
            e !== null && (Br(e, n, r, i), cp(e, n, r));
    },
    enqueueForceUpdate: function (n, e) {
        n = n._reactInternals;
        var t = Ti(),
            i = Po(n),
            r = Fs(t, i);
        (r.tag = 2),
            e != null && (r.callback = e),
            (e = bo(n, r, i)),
            e !== null && (Br(e, n, i, t), cp(e, n, i));
    },
};
function AM(n, e, t, i, r, s, o) {
    return (
        (n = n.stateNode),
        typeof n.shouldComponentUpdate == 'function'
            ? n.shouldComponentUpdate(i, s, o)
            : e.prototype && e.prototype.isPureReactComponent
            ? !$c(t, i) || !$c(r, s)
            : !0
    );
}
function RA(n, e, t) {
    var i = !1,
        r = Oo,
        s = e.contextType;
    return (
        typeof s == 'object' && s !== null
            ? (s = wr(s))
            : ((r = ki(e) ? Fa : gi.current),
              (i = e.contextTypes),
              (s = (i = i != null) ? du(n, r) : Oo)),
        (e = new e(t, s)),
        (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
        (e.updater = mm),
        (n.stateNode = e),
        (e._reactInternals = n),
        i &&
            ((n = n.stateNode),
            (n.__reactInternalMemoizedUnmaskedChildContext = r),
            (n.__reactInternalMemoizedMaskedChildContext = s)),
        e
    );
}
function CM(n, e, t, i) {
    (n = e.state),
        typeof e.componentWillReceiveProps == 'function' && e.componentWillReceiveProps(t, i),
        typeof e.UNSAFE_componentWillReceiveProps == 'function' &&
            e.UNSAFE_componentWillReceiveProps(t, i),
        e.state !== n && mm.enqueueReplaceState(e, e.state, null);
}
function c_(n, e, t, i) {
    var r = n.stateNode;
    (r.props = t), (r.state = n.memoizedState), (r.refs = bA), Zy(n);
    var s = e.contextType;
    typeof s == 'object' && s !== null
        ? (r.context = wr(s))
        : ((s = ki(e) ? Fa : gi.current), (r.context = du(n, s))),
        (r.state = n.memoizedState),
        (s = e.getDerivedStateFromProps),
        typeof s == 'function' && (u_(n, e, s, t), (r.state = n.memoizedState)),
        typeof e.getDerivedStateFromProps == 'function' ||
            typeof r.getSnapshotBeforeUpdate == 'function' ||
            (typeof r.UNSAFE_componentWillMount != 'function' &&
                typeof r.componentWillMount != 'function') ||
            ((e = r.state),
            typeof r.componentWillMount == 'function' && r.componentWillMount(),
            typeof r.UNSAFE_componentWillMount == 'function' && r.UNSAFE_componentWillMount(),
            e !== r.state && mm.enqueueReplaceState(r, r.state, null),
            Bp(n, t, r, i),
            (r.state = n.memoizedState)),
        typeof r.componentDidMount == 'function' && (n.flags |= 4194308);
}
function ic(n, e, t) {
    if (((n = t.ref), n !== null && typeof n != 'function' && typeof n != 'object')) {
        if (t._owner) {
            if (((t = t._owner), t)) {
                if (t.tag !== 1) throw Error(Te(309));
                var i = t.stateNode;
            }
            if (!i) throw Error(Te(147, n));
            var r = i,
                s = '' + n;
            return e !== null &&
                e.ref !== null &&
                typeof e.ref == 'function' &&
                e.ref._stringRef === s
                ? e.ref
                : ((e = function (o) {
                      var a = r.refs;
                      a === bA && (a = r.refs = {}), o === null ? delete a[s] : (a[s] = o);
                  }),
                  (e._stringRef = s),
                  e);
        }
        if (typeof n != 'string') throw Error(Te(284));
        if (!t._owner) throw Error(Te(290, n));
    }
    return n;
}
function nh(n, e) {
    throw (
        ((n = Object.prototype.toString.call(e)),
        Error(
            Te(
                31,
                n === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : n
            )
        ))
    );
}
function bM(n) {
    var e = n._init;
    return e(n._payload);
}
function PA(n) {
    function e(g, S) {
        if (n) {
            var M = g.deletions;
            M === null ? ((g.deletions = [S]), (g.flags |= 16)) : M.push(S);
        }
    }
    function t(g, S) {
        if (!n) return null;
        for (; S !== null; ) e(g, S), (S = S.sibling);
        return null;
    }
    function i(g, S) {
        for (g = new Map(); S !== null; )
            S.key !== null ? g.set(S.key, S) : g.set(S.index, S), (S = S.sibling);
        return g;
    }
    function r(g, S) {
        return (g = Lo(g, S)), (g.index = 0), (g.sibling = null), g;
    }
    function s(g, S, M) {
        return (
            (g.index = M),
            n
                ? ((M = g.alternate),
                  M !== null
                      ? ((M = M.index), M < S ? ((g.flags |= 2), S) : M)
                      : ((g.flags |= 2), S))
                : ((g.flags |= 1048576), S)
        );
    }
    function o(g) {
        return n && g.alternate === null && (g.flags |= 2), g;
    }
    function a(g, S, M, T) {
        return S === null || S.tag !== 6
            ? ((S = Pv(M, g.mode, T)), (S.return = g), S)
            : ((S = r(S, M)), (S.return = g), S);
    }
    function c(g, S, M, T) {
        var P = M.type;
        return P === zl
            ? d(g, S, M.props.children, T, M.key)
            : S !== null &&
              (S.elementType === P ||
                  (typeof P == 'object' && P !== null && P.$$typeof === go && bM(P) === S.type))
            ? ((T = r(S, M.props)), (T.ref = ic(g, S, M)), (T.return = g), T)
            : ((T = gp(M.type, M.key, M.props, null, g.mode, T)),
              (T.ref = ic(g, S, M)),
              (T.return = g),
              T);
    }
    function f(g, S, M, T) {
        return S === null ||
            S.tag !== 4 ||
            S.stateNode.containerInfo !== M.containerInfo ||
            S.stateNode.implementation !== M.implementation
            ? ((S = Lv(M, g.mode, T)), (S.return = g), S)
            : ((S = r(S, M.children || [])), (S.return = g), S);
    }
    function d(g, S, M, T, P) {
        return S === null || S.tag !== 7
            ? ((S = La(M, g.mode, T, P)), (S.return = g), S)
            : ((S = r(S, M)), (S.return = g), S);
    }
    function h(g, S, M) {
        if ((typeof S == 'string' && S !== '') || typeof S == 'number')
            return (S = Pv('' + S, g.mode, M)), (S.return = g), S;
        if (typeof S == 'object' && S !== null) {
            switch (S.$$typeof) {
                case jd:
                    return (
                        (M = gp(S.type, S.key, S.props, null, g.mode, M)),
                        (M.ref = ic(g, null, S)),
                        (M.return = g),
                        M
                    );
                case kl:
                    return (S = Lv(S, g.mode, M)), (S.return = g), S;
                case go:
                    var T = S._init;
                    return h(g, T(S._payload), M);
            }
            if (Cc(S) || Qu(S)) return (S = La(S, g.mode, M, null)), (S.return = g), S;
            nh(g, S);
        }
        return null;
    }
    function p(g, S, M, T) {
        var P = S !== null ? S.key : null;
        if ((typeof M == 'string' && M !== '') || typeof M == 'number')
            return P !== null ? null : a(g, S, '' + M, T);
        if (typeof M == 'object' && M !== null) {
            switch (M.$$typeof) {
                case jd:
                    return M.key === P ? c(g, S, M, T) : null;
                case kl:
                    return M.key === P ? f(g, S, M, T) : null;
                case go:
                    return (P = M._init), p(g, S, P(M._payload), T);
            }
            if (Cc(M) || Qu(M)) return P !== null ? null : d(g, S, M, T, null);
            nh(g, M);
        }
        return null;
    }
    function v(g, S, M, T, P) {
        if ((typeof T == 'string' && T !== '') || typeof T == 'number')
            return (g = g.get(M) || null), a(S, g, '' + T, P);
        if (typeof T == 'object' && T !== null) {
            switch (T.$$typeof) {
                case jd:
                    return (g = g.get(T.key === null ? M : T.key) || null), c(S, g, T, P);
                case kl:
                    return (g = g.get(T.key === null ? M : T.key) || null), f(S, g, T, P);
                case go:
                    var A = T._init;
                    return v(g, S, M, A(T._payload), P);
            }
            if (Cc(T) || Qu(T)) return (g = g.get(M) || null), d(S, g, T, P, null);
            nh(S, T);
        }
        return null;
    }
    function _(g, S, M, T) {
        for (
            var P = null, A = null, R = S, D = (S = 0), G = null;
            R !== null && D < M.length;
            D++
        ) {
            R.index > D ? ((G = R), (R = null)) : (G = R.sibling);
            var b = p(g, R, M[D], T);
            if (b === null) {
                R === null && (R = G);
                break;
            }
            n && R && b.alternate === null && e(g, R),
                (S = s(b, S, D)),
                A === null ? (P = b) : (A.sibling = b),
                (A = b),
                (R = G);
        }
        if (D === M.length) return t(g, R), an && ma(g, D), P;
        if (R === null) {
            for (; D < M.length; D++)
                (R = h(g, M[D], T)),
                    R !== null &&
                        ((S = s(R, S, D)), A === null ? (P = R) : (A.sibling = R), (A = R));
            return an && ma(g, D), P;
        }
        for (R = i(g, R); D < M.length; D++)
            (G = v(R, g, D, M[D], T)),
                G !== null &&
                    (n && G.alternate !== null && R.delete(G.key === null ? D : G.key),
                    (S = s(G, S, D)),
                    A === null ? (P = G) : (A.sibling = G),
                    (A = G));
        return (
            n &&
                R.forEach(function (L) {
                    return e(g, L);
                }),
            an && ma(g, D),
            P
        );
    }
    function w(g, S, M, T) {
        var P = Qu(M);
        if (typeof P != 'function') throw Error(Te(150));
        if (((M = P.call(M)), M == null)) throw Error(Te(151));
        for (
            var A = (P = null), R = S, D = (S = 0), G = null, b = M.next();
            R !== null && !b.done;
            D++, b = M.next()
        ) {
            R.index > D ? ((G = R), (R = null)) : (G = R.sibling);
            var L = p(g, R, b.value, T);
            if (L === null) {
                R === null && (R = G);
                break;
            }
            n && R && L.alternate === null && e(g, R),
                (S = s(L, S, D)),
                A === null ? (P = L) : (A.sibling = L),
                (A = L),
                (R = G);
        }
        if (b.done) return t(g, R), an && ma(g, D), P;
        if (R === null) {
            for (; !b.done; D++, b = M.next())
                (b = h(g, b.value, T)),
                    b !== null &&
                        ((S = s(b, S, D)), A === null ? (P = b) : (A.sibling = b), (A = b));
            return an && ma(g, D), P;
        }
        for (R = i(g, R); !b.done; D++, b = M.next())
            (b = v(R, g, D, b.value, T)),
                b !== null &&
                    (n && b.alternate !== null && R.delete(b.key === null ? D : b.key),
                    (S = s(b, S, D)),
                    A === null ? (P = b) : (A.sibling = b),
                    (A = b));
        return (
            n &&
                R.forEach(function (ee) {
                    return e(g, ee);
                }),
            an && ma(g, D),
            P
        );
    }
    function x(g, S, M, T) {
        if (
            (typeof M == 'object' &&
                M !== null &&
                M.type === zl &&
                M.key === null &&
                (M = M.props.children),
            typeof M == 'object' && M !== null)
        ) {
            switch (M.$$typeof) {
                case jd:
                    e: {
                        for (var P = M.key, A = S; A !== null; ) {
                            if (A.key === P) {
                                if (((P = M.type), P === zl)) {
                                    if (A.tag === 7) {
                                        t(g, A.sibling),
                                            (S = r(A, M.props.children)),
                                            (S.return = g),
                                            (g = S);
                                        break e;
                                    }
                                } else if (
                                    A.elementType === P ||
                                    (typeof P == 'object' &&
                                        P !== null &&
                                        P.$$typeof === go &&
                                        bM(P) === A.type)
                                ) {
                                    t(g, A.sibling),
                                        (S = r(A, M.props)),
                                        (S.ref = ic(g, A, M)),
                                        (S.return = g),
                                        (g = S);
                                    break e;
                                }
                                t(g, A);
                                break;
                            } else e(g, A);
                            A = A.sibling;
                        }
                        M.type === zl
                            ? ((S = La(M.props.children, g.mode, T, M.key)),
                              (S.return = g),
                              (g = S))
                            : ((T = gp(M.type, M.key, M.props, null, g.mode, T)),
                              (T.ref = ic(g, S, M)),
                              (T.return = g),
                              (g = T));
                    }
                    return o(g);
                case kl:
                    e: {
                        for (A = M.key; S !== null; ) {
                            if (S.key === A)
                                if (
                                    S.tag === 4 &&
                                    S.stateNode.containerInfo === M.containerInfo &&
                                    S.stateNode.implementation === M.implementation
                                ) {
                                    t(g, S.sibling),
                                        (S = r(S, M.children || [])),
                                        (S.return = g),
                                        (g = S);
                                    break e;
                                } else {
                                    t(g, S);
                                    break;
                                }
                            else e(g, S);
                            S = S.sibling;
                        }
                        (S = Lv(M, g.mode, T)), (S.return = g), (g = S);
                    }
                    return o(g);
                case go:
                    return (A = M._init), x(g, S, A(M._payload), T);
            }
            if (Cc(M)) return _(g, S, M, T);
            if (Qu(M)) return w(g, S, M, T);
            nh(g, M);
        }
        return (typeof M == 'string' && M !== '') || typeof M == 'number'
            ? ((M = '' + M),
              S !== null && S.tag === 6
                  ? (t(g, S.sibling), (S = r(S, M)), (S.return = g), (g = S))
                  : (t(g, S), (S = Pv(M, g.mode, T)), (S.return = g), (g = S)),
              o(g))
            : t(g, S);
    }
    return x;
}
var pu = PA(!0),
    LA = PA(!1),
    kf = {},
    cs = Bo(kf),
    rf = Bo(kf),
    sf = Bo(kf);
function wa(n) {
    if (n === kf) throw Error(Te(174));
    return n;
}
function Ky(n, e) {
    switch ((Qt(sf, e), Qt(rf, n), Qt(cs, kf), (n = e.nodeType), n)) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : V0(null, '');
            break;
        default:
            (n = n === 8 ? e.parentNode : e),
                (e = n.namespaceURI || null),
                (n = n.tagName),
                (e = V0(e, n));
    }
    tn(cs), Qt(cs, e);
}
function mu() {
    tn(cs), tn(rf), tn(sf);
}
function IA(n) {
    wa(sf.current);
    var e = wa(cs.current),
        t = V0(e, n.type);
    e !== t && (Qt(rf, n), Qt(cs, t));
}
function Jy(n) {
    rf.current === n && (tn(cs), tn(rf));
}
var fn = Bo(0);
function Hp(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (
                t !== null &&
                ((t = t.dehydrated), t === null || t.data === '$?' || t.data === '$!')
            )
                return e;
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e;
        } else if (e.child !== null) {
            (e.child.return = e), (e = e.child);
            continue;
        }
        if (e === n) break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n) return null;
            e = e.return;
        }
        (e.sibling.return = e.return), (e = e.sibling);
    }
    return null;
}
var Ev = [];
function Qy() {
    for (var n = 0; n < Ev.length; n++) Ev[n]._workInProgressVersionPrimary = null;
    Ev.length = 0;
}
var fp = Xs.ReactCurrentDispatcher,
    Tv = Xs.ReactCurrentBatchConfig,
    za = 0,
    pn = null,
    kn = null,
    qn = null,
    Vp = !1,
    Oc = !1,
    of = 0,
    iL = 0;
function li() {
    throw Error(Te(321));
}
function $y(n, e) {
    if (e === null) return !1;
    for (var t = 0; t < e.length && t < n.length; t++) if (!Hr(n[t], e[t])) return !1;
    return !0;
}
function ex(n, e, t, i, r, s) {
    if (
        ((za = s),
        (pn = e),
        (e.memoizedState = null),
        (e.updateQueue = null),
        (e.lanes = 0),
        (fp.current = n === null || n.memoizedState === null ? aL : lL),
        (n = t(i, r)),
        Oc)
    ) {
        s = 0;
        do {
            if (((Oc = !1), (of = 0), 25 <= s)) throw Error(Te(301));
            (s += 1), (qn = kn = null), (e.updateQueue = null), (fp.current = uL), (n = t(i, r));
        } while (Oc);
    }
    if (
        ((fp.current = Gp),
        (e = kn !== null && kn.next !== null),
        (za = 0),
        (qn = kn = pn = null),
        (Vp = !1),
        e)
    )
        throw Error(Te(300));
    return n;
}
function tx() {
    var n = of !== 0;
    return (of = 0), n;
}
function rs() {
    var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return qn === null ? (pn.memoizedState = qn = n) : (qn = qn.next = n), qn;
}
function Er() {
    if (kn === null) {
        var n = pn.alternate;
        n = n !== null ? n.memoizedState : null;
    } else n = kn.next;
    var e = qn === null ? pn.memoizedState : qn.next;
    if (e !== null) (qn = e), (kn = n);
    else {
        if (n === null) throw Error(Te(310));
        (kn = n),
            (n = {
                memoizedState: kn.memoizedState,
                baseState: kn.baseState,
                baseQueue: kn.baseQueue,
                queue: kn.queue,
                next: null,
            }),
            qn === null ? (pn.memoizedState = qn = n) : (qn = qn.next = n);
    }
    return qn;
}
function af(n, e) {
    return typeof e == 'function' ? e(n) : e;
}
function Av(n) {
    var e = Er(),
        t = e.queue;
    if (t === null) throw Error(Te(311));
    t.lastRenderedReducer = n;
    var i = kn,
        r = i.baseQueue,
        s = t.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            (r.next = s.next), (s.next = o);
        }
        (i.baseQueue = r = s), (t.pending = null);
    }
    if (r !== null) {
        (s = r.next), (i = i.baseState);
        var a = (o = null),
            c = null,
            f = s;
        do {
            var d = f.lane;
            if ((za & d) === d)
                c !== null &&
                    (c = c.next =
                        {
                            lane: 0,
                            action: f.action,
                            hasEagerState: f.hasEagerState,
                            eagerState: f.eagerState,
                            next: null,
                        }),
                    (i = f.hasEagerState ? f.eagerState : n(i, f.action));
            else {
                var h = {
                    lane: d,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null,
                };
                c === null ? ((a = c = h), (o = i)) : (c = c.next = h), (pn.lanes |= d), (Ba |= d);
            }
            f = f.next;
        } while (f !== null && f !== s);
        c === null ? (o = i) : (c.next = a),
            Hr(i, e.memoizedState) || (Oi = !0),
            (e.memoizedState = i),
            (e.baseState = o),
            (e.baseQueue = c),
            (t.lastRenderedState = i);
    }
    if (((n = t.interleaved), n !== null)) {
        r = n;
        do (s = r.lane), (pn.lanes |= s), (Ba |= s), (r = r.next);
        while (r !== n);
    } else r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch];
}
function Cv(n) {
    var e = Er(),
        t = e.queue;
    if (t === null) throw Error(Te(311));
    t.lastRenderedReducer = n;
    var i = t.dispatch,
        r = t.pending,
        s = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var o = (r = r.next);
        do (s = n(s, o.action)), (o = o.next);
        while (o !== r);
        Hr(s, e.memoizedState) || (Oi = !0),
            (e.memoizedState = s),
            e.baseQueue === null && (e.baseState = s),
            (t.lastRenderedState = s);
    }
    return [s, i];
}
function NA() {}
function DA(n, e) {
    var t = pn,
        i = Er(),
        r = e(),
        s = !Hr(i.memoizedState, r);
    if (
        (s && ((i.memoizedState = r), (Oi = !0)),
        (i = i.queue),
        nx(FA.bind(null, t, i, n), [n]),
        i.getSnapshot !== e || s || (qn !== null && qn.memoizedState.tag & 1))
    ) {
        if (((t.flags |= 2048), lf(9, OA.bind(null, t, i, r, e), void 0, null), Kn === null))
            throw Error(Te(349));
        za & 30 || UA(t, e, r);
    }
    return r;
}
function UA(n, e, t) {
    (n.flags |= 16384),
        (n = { getSnapshot: e, value: t }),
        (e = pn.updateQueue),
        e === null
            ? ((e = { lastEffect: null, stores: null }), (pn.updateQueue = e), (e.stores = [n]))
            : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function OA(n, e, t, i) {
    (e.value = t), (e.getSnapshot = i), kA(e) && zA(n);
}
function FA(n, e, t) {
    return t(function () {
        kA(e) && zA(n);
    });
}
function kA(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !Hr(n, t);
    } catch {
        return !0;
    }
}
function zA(n) {
    var e = Hs(n, 1);
    e !== null && Br(e, n, 1, -1);
}
function RM(n) {
    var e = rs();
    return (
        typeof n == 'function' && (n = n()),
        (e.memoizedState = e.baseState = n),
        (n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: af,
            lastRenderedState: n,
        }),
        (e.queue = n),
        (n = n.dispatch = oL.bind(null, pn, n)),
        [e.memoizedState, n]
    );
}
function lf(n, e, t, i) {
    return (
        (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
        (e = pn.updateQueue),
        e === null
            ? ((e = { lastEffect: null, stores: null }),
              (pn.updateQueue = e),
              (e.lastEffect = n.next = n))
            : ((t = e.lastEffect),
              t === null
                  ? (e.lastEffect = n.next = n)
                  : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
        n
    );
}
function BA() {
    return Er().memoizedState;
}
function dp(n, e, t, i) {
    var r = rs();
    (pn.flags |= n), (r.memoizedState = lf(1 | e, t, void 0, i === void 0 ? null : i));
}
function gm(n, e, t, i) {
    var r = Er();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (kn !== null) {
        var o = kn.memoizedState;
        if (((s = o.destroy), i !== null && $y(i, o.deps))) {
            r.memoizedState = lf(e, t, s, i);
            return;
        }
    }
    (pn.flags |= n), (r.memoizedState = lf(1 | e, t, s, i));
}
function PM(n, e) {
    return dp(8390656, 8, n, e);
}
function nx(n, e) {
    return gm(2048, 8, n, e);
}
function HA(n, e) {
    return gm(4, 2, n, e);
}
function VA(n, e) {
    return gm(4, 4, n, e);
}
function GA(n, e) {
    if (typeof e == 'function')
        return (
            (n = n()),
            e(n),
            function () {
                e(null);
            }
        );
    if (e != null)
        return (
            (n = n()),
            (e.current = n),
            function () {
                e.current = null;
            }
        );
}
function WA(n, e, t) {
    return (t = t != null ? t.concat([n]) : null), gm(4, 4, GA.bind(null, e, n), t);
}
function ix() {}
function jA(n, e) {
    var t = Er();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && $y(e, i[1]) ? i[0] : ((t.memoizedState = [n, e]), n);
}
function XA(n, e) {
    var t = Er();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && $y(e, i[1])
        ? i[0]
        : ((n = n()), (t.memoizedState = [n, e]), n);
}
function YA(n, e, t) {
    return za & 21
        ? (Hr(t, e) || ((t = KT()), (pn.lanes |= t), (Ba |= t), (n.baseState = !0)), e)
        : (n.baseState && ((n.baseState = !1), (Oi = !0)), (n.memoizedState = t));
}
function rL(n, e) {
    var t = jt;
    (jt = t !== 0 && 4 > t ? t : 4), n(!0);
    var i = Tv.transition;
    Tv.transition = {};
    try {
        n(!1), e();
    } finally {
        (jt = t), (Tv.transition = i);
    }
}
function qA() {
    return Er().memoizedState;
}
function sL(n, e, t) {
    var i = Po(n);
    if (((t = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }), ZA(n)))
        KA(e, t);
    else if (((t = AA(n, e, t, i)), t !== null)) {
        var r = Ti();
        Br(t, n, i, r), JA(t, e, i);
    }
}
function oL(n, e, t) {
    var i = Po(n),
        r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
    if (ZA(n)) KA(e, r);
    else {
        var s = n.alternate;
        if (
            n.lanes === 0 &&
            (s === null || s.lanes === 0) &&
            ((s = e.lastRenderedReducer), s !== null)
        )
            try {
                var o = e.lastRenderedState,
                    a = s(o, t);
                if (((r.hasEagerState = !0), (r.eagerState = a), Hr(a, o))) {
                    var c = e.interleaved;
                    c === null ? ((r.next = r), qy(e)) : ((r.next = c.next), (c.next = r)),
                        (e.interleaved = r);
                    return;
                }
            } catch {
            } finally {
            }
        (t = AA(n, e, r, i)), t !== null && ((r = Ti()), Br(t, n, i, r), JA(t, e, i));
    }
}
function ZA(n) {
    var e = n.alternate;
    return n === pn || (e !== null && e === pn);
}
function KA(n, e) {
    Oc = Vp = !0;
    var t = n.pending;
    t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)), (n.pending = e);
}
function JA(n, e, t) {
    if (t & 4194240) {
        var i = e.lanes;
        (i &= n.pendingLanes), (t |= i), (e.lanes = t), Dy(n, t);
    }
}
var Gp = {
        readContext: wr,
        useCallback: li,
        useContext: li,
        useEffect: li,
        useImperativeHandle: li,
        useInsertionEffect: li,
        useLayoutEffect: li,
        useMemo: li,
        useReducer: li,
        useRef: li,
        useState: li,
        useDebugValue: li,
        useDeferredValue: li,
        useTransition: li,
        useMutableSource: li,
        useSyncExternalStore: li,
        useId: li,
        unstable_isNewReconciler: !1,
    },
    aL = {
        readContext: wr,
        useCallback: function (n, e) {
            return (rs().memoizedState = [n, e === void 0 ? null : e]), n;
        },
        useContext: wr,
        useEffect: PM,
        useImperativeHandle: function (n, e, t) {
            return (t = t != null ? t.concat([n]) : null), dp(4194308, 4, GA.bind(null, e, n), t);
        },
        useLayoutEffect: function (n, e) {
            return dp(4194308, 4, n, e);
        },
        useInsertionEffect: function (n, e) {
            return dp(4, 2, n, e);
        },
        useMemo: function (n, e) {
            var t = rs();
            return (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n;
        },
        useReducer: function (n, e, t) {
            var i = rs();
            return (
                (e = t !== void 0 ? t(e) : e),
                (i.memoizedState = i.baseState = e),
                (n = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: n,
                    lastRenderedState: e,
                }),
                (i.queue = n),
                (n = n.dispatch = sL.bind(null, pn, n)),
                [i.memoizedState, n]
            );
        },
        useRef: function (n) {
            var e = rs();
            return (n = { current: n }), (e.memoizedState = n);
        },
        useState: RM,
        useDebugValue: ix,
        useDeferredValue: function (n) {
            return (rs().memoizedState = n);
        },
        useTransition: function () {
            var n = RM(!1),
                e = n[0];
            return (n = rL.bind(null, n[1])), (rs().memoizedState = n), [e, n];
        },
        useMutableSource: function () {},
        useSyncExternalStore: function (n, e, t) {
            var i = pn,
                r = rs();
            if (an) {
                if (t === void 0) throw Error(Te(407));
                t = t();
            } else {
                if (((t = e()), Kn === null)) throw Error(Te(349));
                za & 30 || UA(i, e, t);
            }
            r.memoizedState = t;
            var s = { value: t, getSnapshot: e };
            return (
                (r.queue = s),
                PM(FA.bind(null, i, s, n), [n]),
                (i.flags |= 2048),
                lf(9, OA.bind(null, i, s, t, e), void 0, null),
                t
            );
        },
        useId: function () {
            var n = rs(),
                e = Kn.identifierPrefix;
            if (an) {
                var t = Ns,
                    i = Is;
                (t = (i & ~(1 << (32 - zr(i) - 1))).toString(32) + t),
                    (e = ':' + e + 'R' + t),
                    (t = of++),
                    0 < t && (e += 'H' + t.toString(32)),
                    (e += ':');
            } else (t = iL++), (e = ':' + e + 'r' + t.toString(32) + ':');
            return (n.memoizedState = e);
        },
        unstable_isNewReconciler: !1,
    },
    lL = {
        readContext: wr,
        useCallback: jA,
        useContext: wr,
        useEffect: nx,
        useImperativeHandle: WA,
        useInsertionEffect: HA,
        useLayoutEffect: VA,
        useMemo: XA,
        useReducer: Av,
        useRef: BA,
        useState: function () {
            return Av(af);
        },
        useDebugValue: ix,
        useDeferredValue: function (n) {
            var e = Er();
            return YA(e, kn.memoizedState, n);
        },
        useTransition: function () {
            var n = Av(af)[0],
                e = Er().memoizedState;
            return [n, e];
        },
        useMutableSource: NA,
        useSyncExternalStore: DA,
        useId: qA,
        unstable_isNewReconciler: !1,
    },
    uL = {
        readContext: wr,
        useCallback: jA,
        useContext: wr,
        useEffect: nx,
        useImperativeHandle: WA,
        useInsertionEffect: HA,
        useLayoutEffect: VA,
        useMemo: XA,
        useReducer: Cv,
        useRef: BA,
        useState: function () {
            return Cv(af);
        },
        useDebugValue: ix,
        useDeferredValue: function (n) {
            var e = Er();
            return kn === null ? (e.memoizedState = n) : YA(e, kn.memoizedState, n);
        },
        useTransition: function () {
            var n = Cv(af)[0],
                e = Er().memoizedState;
            return [n, e];
        },
        useMutableSource: NA,
        useSyncExternalStore: DA,
        useId: qA,
        unstable_isNewReconciler: !1,
    };
function gu(n, e) {
    try {
        var t = '',
            i = e;
        do (t += FP(i)), (i = i.return);
        while (i);
        var r = t;
    } catch (s) {
        r =
            `
Error generating stack: ` +
            s.message +
            `
` +
            s.stack;
    }
    return { value: n, source: e, stack: r, digest: null };
}
function bv(n, e, t) {
    return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function f_(n, e) {
    try {
        console.error(e.value);
    } catch (t) {
        setTimeout(function () {
            throw t;
        });
    }
}
var cL = typeof WeakMap == 'function' ? WeakMap : Map;
function QA(n, e, t) {
    (t = Fs(-1, t)), (t.tag = 3), (t.payload = { element: null });
    var i = e.value;
    return (
        (t.callback = function () {
            jp || ((jp = !0), (S_ = i)), f_(n, e);
        }),
        t
    );
}
function $A(n, e, t) {
    (t = Fs(-1, t)), (t.tag = 3);
    var i = n.type.getDerivedStateFromError;
    if (typeof i == 'function') {
        var r = e.value;
        (t.payload = function () {
            return i(r);
        }),
            (t.callback = function () {
                f_(n, e);
            });
    }
    var s = n.stateNode;
    return (
        s !== null &&
            typeof s.componentDidCatch == 'function' &&
            (t.callback = function () {
                f_(n, e),
                    typeof i != 'function' && (Ro === null ? (Ro = new Set([this])) : Ro.add(this));
                var o = e.stack;
                this.componentDidCatch(e.value, { componentStack: o !== null ? o : '' });
            }),
        t
    );
}
function LM(n, e, t) {
    var i = n.pingCache;
    if (i === null) {
        i = n.pingCache = new cL();
        var r = new Set();
        i.set(e, r);
    } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
    r.has(t) || (r.add(t), (n = EL.bind(null, n, e, t)), e.then(n, n));
}
function IM(n) {
    do {
        var e;
        if (
            ((e = n.tag === 13) &&
                ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
            e)
        )
            return n;
        n = n.return;
    } while (n !== null);
    return null;
}
function NM(n, e, t, i, r) {
    return n.mode & 1
        ? ((n.flags |= 65536), (n.lanes = r), n)
        : (n === e
              ? (n.flags |= 65536)
              : ((n.flags |= 128),
                (t.flags |= 131072),
                (t.flags &= -52805),
                t.tag === 1 &&
                    (t.alternate === null
                        ? (t.tag = 17)
                        : ((e = Fs(-1, 1)), (e.tag = 2), bo(t, e, 1))),
                (t.lanes |= 1)),
          n);
}
var fL = Xs.ReactCurrentOwner,
    Oi = !1;
function Mi(n, e, t, i) {
    e.child = n === null ? LA(e, null, t, i) : pu(e, n.child, t, i);
}
function DM(n, e, t, i, r) {
    t = t.render;
    var s = e.ref;
    return (
        lu(e, r),
        (i = ex(n, e, t, i, s, r)),
        (t = tx()),
        n !== null && !Oi
            ? ((e.updateQueue = n.updateQueue), (e.flags &= -2053), (n.lanes &= ~r), Vs(n, e, r))
            : (an && t && Vy(e), (e.flags |= 1), Mi(n, e, i, r), e.child)
    );
}
function UM(n, e, t, i, r) {
    if (n === null) {
        var s = t.type;
        return typeof s == 'function' &&
            !fx(s) &&
            s.defaultProps === void 0 &&
            t.compare === null &&
            t.defaultProps === void 0
            ? ((e.tag = 15), (e.type = s), e2(n, e, s, i, r))
            : ((n = gp(t.type, null, i, e, e.mode, r)),
              (n.ref = e.ref),
              (n.return = e),
              (e.child = n));
    }
    if (((s = n.child), !(n.lanes & r))) {
        var o = s.memoizedProps;
        if (((t = t.compare), (t = t !== null ? t : $c), t(o, i) && n.ref === e.ref))
            return Vs(n, e, r);
    }
    return (e.flags |= 1), (n = Lo(s, i)), (n.ref = e.ref), (n.return = e), (e.child = n);
}
function e2(n, e, t, i, r) {
    if (n !== null) {
        var s = n.memoizedProps;
        if ($c(s, i) && n.ref === e.ref)
            if (((Oi = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
                n.flags & 131072 && (Oi = !0);
            else return (e.lanes = n.lanes), Vs(n, e, r);
    }
    return d_(n, e, t, i, r);
}
function t2(n, e, t) {
    var i = e.pendingProps,
        r = i.children,
        s = n !== null ? n.memoizedState : null;
    if (i.mode === 'hidden')
        if (!(e.mode & 1))
            (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
                Qt(Zl, Zi),
                (Zi |= t);
        else {
            if (!(t & 1073741824))
                return (
                    (n = s !== null ? s.baseLanes | t : t),
                    (e.lanes = e.childLanes = 1073741824),
                    (e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }),
                    (e.updateQueue = null),
                    Qt(Zl, Zi),
                    (Zi |= n),
                    null
                );
            (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
                (i = s !== null ? s.baseLanes : t),
                Qt(Zl, Zi),
                (Zi |= i);
        }
    else
        s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
            Qt(Zl, Zi),
            (Zi |= i);
    return Mi(n, e, r, t), e.child;
}
function n2(n, e) {
    var t = e.ref;
    ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
        ((e.flags |= 512), (e.flags |= 2097152));
}
function d_(n, e, t, i, r) {
    var s = ki(t) ? Fa : gi.current;
    return (
        (s = du(e, s)),
        lu(e, r),
        (t = ex(n, e, t, i, s, r)),
        (i = tx()),
        n !== null && !Oi
            ? ((e.updateQueue = n.updateQueue), (e.flags &= -2053), (n.lanes &= ~r), Vs(n, e, r))
            : (an && i && Vy(e), (e.flags |= 1), Mi(n, e, t, r), e.child)
    );
}
function OM(n, e, t, i, r) {
    if (ki(t)) {
        var s = !0;
        Up(e);
    } else s = !1;
    if ((lu(e, r), e.stateNode === null)) hp(n, e), RA(e, t, i), c_(e, t, i, r), (i = !0);
    else if (n === null) {
        var o = e.stateNode,
            a = e.memoizedProps;
        o.props = a;
        var c = o.context,
            f = t.contextType;
        typeof f == 'object' && f !== null
            ? (f = wr(f))
            : ((f = ki(t) ? Fa : gi.current), (f = du(e, f)));
        var d = t.getDerivedStateFromProps,
            h = typeof d == 'function' || typeof o.getSnapshotBeforeUpdate == 'function';
        h ||
            (typeof o.UNSAFE_componentWillReceiveProps != 'function' &&
                typeof o.componentWillReceiveProps != 'function') ||
            ((a !== i || c !== f) && CM(e, o, i, f)),
            (vo = !1);
        var p = e.memoizedState;
        (o.state = p),
            Bp(e, i, o, r),
            (c = e.memoizedState),
            a !== i || p !== c || Fi.current || vo
                ? (typeof d == 'function' && (u_(e, t, d, i), (c = e.memoizedState)),
                  (a = vo || AM(e, t, a, i, p, c, f))
                      ? (h ||
                            (typeof o.UNSAFE_componentWillMount != 'function' &&
                                typeof o.componentWillMount != 'function') ||
                            (typeof o.componentWillMount == 'function' && o.componentWillMount(),
                            typeof o.UNSAFE_componentWillMount == 'function' &&
                                o.UNSAFE_componentWillMount()),
                        typeof o.componentDidMount == 'function' && (e.flags |= 4194308))
                      : (typeof o.componentDidMount == 'function' && (e.flags |= 4194308),
                        (e.memoizedProps = i),
                        (e.memoizedState = c)),
                  (o.props = i),
                  (o.state = c),
                  (o.context = f),
                  (i = a))
                : (typeof o.componentDidMount == 'function' && (e.flags |= 4194308), (i = !1));
    } else {
        (o = e.stateNode),
            CA(n, e),
            (a = e.memoizedProps),
            (f = e.type === e.elementType ? a : Nr(e.type, a)),
            (o.props = f),
            (h = e.pendingProps),
            (p = o.context),
            (c = t.contextType),
            typeof c == 'object' && c !== null
                ? (c = wr(c))
                : ((c = ki(t) ? Fa : gi.current), (c = du(e, c)));
        var v = t.getDerivedStateFromProps;
        (d = typeof v == 'function' || typeof o.getSnapshotBeforeUpdate == 'function') ||
            (typeof o.UNSAFE_componentWillReceiveProps != 'function' &&
                typeof o.componentWillReceiveProps != 'function') ||
            ((a !== h || p !== c) && CM(e, o, i, c)),
            (vo = !1),
            (p = e.memoizedState),
            (o.state = p),
            Bp(e, i, o, r);
        var _ = e.memoizedState;
        a !== h || p !== _ || Fi.current || vo
            ? (typeof v == 'function' && (u_(e, t, v, i), (_ = e.memoizedState)),
              (f = vo || AM(e, t, f, i, p, _, c) || !1)
                  ? (d ||
                        (typeof o.UNSAFE_componentWillUpdate != 'function' &&
                            typeof o.componentWillUpdate != 'function') ||
                        (typeof o.componentWillUpdate == 'function' &&
                            o.componentWillUpdate(i, _, c),
                        typeof o.UNSAFE_componentWillUpdate == 'function' &&
                            o.UNSAFE_componentWillUpdate(i, _, c)),
                    typeof o.componentDidUpdate == 'function' && (e.flags |= 4),
                    typeof o.getSnapshotBeforeUpdate == 'function' && (e.flags |= 1024))
                  : (typeof o.componentDidUpdate != 'function' ||
                        (a === n.memoizedProps && p === n.memoizedState) ||
                        (e.flags |= 4),
                    typeof o.getSnapshotBeforeUpdate != 'function' ||
                        (a === n.memoizedProps && p === n.memoizedState) ||
                        (e.flags |= 1024),
                    (e.memoizedProps = i),
                    (e.memoizedState = _)),
              (o.props = i),
              (o.state = _),
              (o.context = c),
              (i = f))
            : (typeof o.componentDidUpdate != 'function' ||
                  (a === n.memoizedProps && p === n.memoizedState) ||
                  (e.flags |= 4),
              typeof o.getSnapshotBeforeUpdate != 'function' ||
                  (a === n.memoizedProps && p === n.memoizedState) ||
                  (e.flags |= 1024),
              (i = !1));
    }
    return h_(n, e, t, i, s, r);
}
function h_(n, e, t, i, r, s) {
    n2(n, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o) return r && SM(e, t, !1), Vs(n, e, s);
    (i = e.stateNode), (fL.current = e);
    var a = o && typeof t.getDerivedStateFromError != 'function' ? null : i.render();
    return (
        (e.flags |= 1),
        n !== null && o
            ? ((e.child = pu(e, n.child, null, s)), (e.child = pu(e, null, a, s)))
            : Mi(n, e, a, s),
        (e.memoizedState = i.state),
        r && SM(e, t, !0),
        e.child
    );
}
function i2(n) {
    var e = n.stateNode;
    e.pendingContext
        ? xM(n, e.pendingContext, e.pendingContext !== e.context)
        : e.context && xM(n, e.context, !1),
        Ky(n, e.containerInfo);
}
function FM(n, e, t, i, r) {
    return hu(), Wy(r), (e.flags |= 256), Mi(n, e, t, i), e.child;
}
var p_ = { dehydrated: null, treeContext: null, retryLane: 0 };
function m_(n) {
    return { baseLanes: n, cachePool: null, transitions: null };
}
function r2(n, e, t) {
    var i = e.pendingProps,
        r = fn.current,
        s = !1,
        o = (e.flags & 128) !== 0,
        a;
    if (
        ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
        a ? ((s = !0), (e.flags &= -129)) : (n === null || n.memoizedState !== null) && (r |= 1),
        Qt(fn, r & 1),
        n === null)
    )
        return (
            a_(e),
            (n = e.memoizedState),
            n !== null && ((n = n.dehydrated), n !== null)
                ? (e.mode & 1
                      ? n.data === '$!'
                          ? (e.lanes = 8)
                          : (e.lanes = 1073741824)
                      : (e.lanes = 1),
                  null)
                : ((o = i.children),
                  (n = i.fallback),
                  s
                      ? ((i = e.mode),
                        (s = e.child),
                        (o = { mode: 'hidden', children: o }),
                        !(i & 1) && s !== null
                            ? ((s.childLanes = 0), (s.pendingProps = o))
                            : (s = ym(o, i, 0, null)),
                        (n = La(n, i, t, null)),
                        (s.return = e),
                        (n.return = e),
                        (s.sibling = n),
                        (e.child = s),
                        (e.child.memoizedState = m_(t)),
                        (e.memoizedState = p_),
                        n)
                      : rx(e, o))
        );
    if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
        return dL(n, e, o, i, a, r, t);
    if (s) {
        (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
        var c = { mode: 'hidden', children: i.children };
        return (
            !(o & 1) && e.child !== r
                ? ((i = e.child), (i.childLanes = 0), (i.pendingProps = c), (e.deletions = null))
                : ((i = Lo(r, c)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
            a !== null ? (s = Lo(a, s)) : ((s = La(s, o, t, null)), (s.flags |= 2)),
            (s.return = e),
            (i.return = e),
            (i.sibling = s),
            (e.child = i),
            (i = s),
            (s = e.child),
            (o = n.child.memoizedState),
            (o =
                o === null
                    ? m_(t)
                    : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }),
            (s.memoizedState = o),
            (s.childLanes = n.childLanes & ~t),
            (e.memoizedState = p_),
            i
        );
    }
    return (
        (s = n.child),
        (n = s.sibling),
        (i = Lo(s, { mode: 'visible', children: i.children })),
        !(e.mode & 1) && (i.lanes = t),
        (i.return = e),
        (i.sibling = null),
        n !== null &&
            ((t = e.deletions), t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
        (e.child = i),
        (e.memoizedState = null),
        i
    );
}
function rx(n, e) {
    return (
        (e = ym({ mode: 'visible', children: e }, n.mode, 0, null)), (e.return = n), (n.child = e)
    );
}
function ih(n, e, t, i) {
    return (
        i !== null && Wy(i),
        pu(e, n.child, null, t),
        (n = rx(e, e.pendingProps.children)),
        (n.flags |= 2),
        (e.memoizedState = null),
        n
    );
}
function dL(n, e, t, i, r, s, o) {
    if (t)
        return e.flags & 256
            ? ((e.flags &= -257), (i = bv(Error(Te(422)))), ih(n, e, o, i))
            : e.memoizedState !== null
            ? ((e.child = n.child), (e.flags |= 128), null)
            : ((s = i.fallback),
              (r = e.mode),
              (i = ym({ mode: 'visible', children: i.children }, r, 0, null)),
              (s = La(s, r, o, null)),
              (s.flags |= 2),
              (i.return = e),
              (s.return = e),
              (i.sibling = s),
              (e.child = i),
              e.mode & 1 && pu(e, n.child, null, o),
              (e.child.memoizedState = m_(o)),
              (e.memoizedState = p_),
              s);
    if (!(e.mode & 1)) return ih(n, e, o, null);
    if (r.data === '$!') {
        if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
        return (i = a), (s = Error(Te(419))), (i = bv(s, i, void 0)), ih(n, e, o, i);
    }
    if (((a = (o & n.childLanes) !== 0), Oi || a)) {
        if (((i = Kn), i !== null)) {
            switch (o & -o) {
                case 4:
                    r = 2;
                    break;
                case 16:
                    r = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    r = 32;
                    break;
                case 536870912:
                    r = 268435456;
                    break;
                default:
                    r = 0;
            }
            (r = r & (i.suspendedLanes | o) ? 0 : r),
                r !== 0 && r !== s.retryLane && ((s.retryLane = r), Hs(n, r), Br(i, n, r, -1));
        }
        return cx(), (i = bv(Error(Te(421)))), ih(n, e, o, i);
    }
    return r.data === '$?'
        ? ((e.flags |= 128), (e.child = n.child), (e = TL.bind(null, n)), (r._reactRetry = e), null)
        : ((n = s.treeContext),
          (Qi = Co(r.nextSibling)),
          ($i = e),
          (an = !0),
          (Fr = null),
          n !== null &&
              ((yr[xr++] = Is),
              (yr[xr++] = Ns),
              (yr[xr++] = ka),
              (Is = n.id),
              (Ns = n.overflow),
              (ka = e)),
          (e = rx(e, i.children)),
          (e.flags |= 4096),
          e);
}
function kM(n, e, t) {
    n.lanes |= e;
    var i = n.alternate;
    i !== null && (i.lanes |= e), l_(n.return, e, t);
}
function Rv(n, e, t, i, r) {
    var s = n.memoizedState;
    s === null
        ? (n.memoizedState = {
              isBackwards: e,
              rendering: null,
              renderingStartTime: 0,
              last: i,
              tail: t,
              tailMode: r,
          })
        : ((s.isBackwards = e),
          (s.rendering = null),
          (s.renderingStartTime = 0),
          (s.last = i),
          (s.tail = t),
          (s.tailMode = r));
}
function s2(n, e, t) {
    var i = e.pendingProps,
        r = i.revealOrder,
        s = i.tail;
    if ((Mi(n, e, i.children, t), (i = fn.current), i & 2)) (i = (i & 1) | 2), (e.flags |= 128);
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13) n.memoizedState !== null && kM(n, t, e);
                else if (n.tag === 19) kM(n, t, e);
                else if (n.child !== null) {
                    (n.child.return = n), (n = n.child);
                    continue;
                }
                if (n === e) break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e) break e;
                    n = n.return;
                }
                (n.sibling.return = n.return), (n = n.sibling);
            }
        i &= 1;
    }
    if ((Qt(fn, i), !(e.mode & 1))) e.memoizedState = null;
    else
        switch (r) {
            case 'forwards':
                for (t = e.child, r = null; t !== null; )
                    (n = t.alternate), n !== null && Hp(n) === null && (r = t), (t = t.sibling);
                (t = r),
                    t === null
                        ? ((r = e.child), (e.child = null))
                        : ((r = t.sibling), (t.sibling = null)),
                    Rv(e, !1, r, t, s);
                break;
            case 'backwards':
                for (t = null, r = e.child, e.child = null; r !== null; ) {
                    if (((n = r.alternate), n !== null && Hp(n) === null)) {
                        e.child = r;
                        break;
                    }
                    (n = r.sibling), (r.sibling = t), (t = r), (r = n);
                }
                Rv(e, !0, t, null, s);
                break;
            case 'together':
                Rv(e, !1, null, null, void 0);
                break;
            default:
                e.memoizedState = null;
        }
    return e.child;
}
function hp(n, e) {
    !(e.mode & 1) && n !== null && ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Vs(n, e, t) {
    if ((n !== null && (e.dependencies = n.dependencies), (Ba |= e.lanes), !(t & e.childLanes)))
        return null;
    if (n !== null && e.child !== n.child) throw Error(Te(153));
    if (e.child !== null) {
        for (
            n = e.child, t = Lo(n, n.pendingProps), e.child = t, t.return = e;
            n.sibling !== null;

        )
            (n = n.sibling), (t = t.sibling = Lo(n, n.pendingProps)), (t.return = e);
        t.sibling = null;
    }
    return e.child;
}
function hL(n, e, t) {
    switch (e.tag) {
        case 3:
            i2(e), hu();
            break;
        case 5:
            IA(e);
            break;
        case 1:
            ki(e.type) && Up(e);
            break;
        case 4:
            Ky(e, e.stateNode.containerInfo);
            break;
        case 10:
            var i = e.type._context,
                r = e.memoizedProps.value;
            Qt(kp, i._currentValue), (i._currentValue = r);
            break;
        case 13:
            if (((i = e.memoizedState), i !== null))
                return i.dehydrated !== null
                    ? (Qt(fn, fn.current & 1), (e.flags |= 128), null)
                    : t & e.child.childLanes
                    ? r2(n, e, t)
                    : (Qt(fn, fn.current & 1), (n = Vs(n, e, t)), n !== null ? n.sibling : null);
            Qt(fn, fn.current & 1);
            break;
        case 19:
            if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
                if (i) return s2(n, e, t);
                e.flags |= 128;
            }
            if (
                ((r = e.memoizedState),
                r !== null && ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
                Qt(fn, fn.current),
                i)
            )
                break;
            return null;
        case 22:
        case 23:
            return (e.lanes = 0), t2(n, e, t);
    }
    return Vs(n, e, t);
}
var o2, g_, a2, l2;
o2 = function (n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            (t.child.return = t), (t = t.child);
            continue;
        }
        if (t === e) break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e) return;
            t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
    }
};
g_ = function () {};
a2 = function (n, e, t, i) {
    var r = n.memoizedProps;
    if (r !== i) {
        (n = e.stateNode), wa(cs.current);
        var s = null;
        switch (t) {
            case 'input':
                (r = k0(n, r)), (i = k0(n, i)), (s = []);
                break;
            case 'select':
                (r = gn({}, r, { value: void 0 })), (i = gn({}, i, { value: void 0 })), (s = []);
                break;
            case 'textarea':
                (r = H0(n, r)), (i = H0(n, i)), (s = []);
                break;
            default:
                typeof r.onClick != 'function' &&
                    typeof i.onClick == 'function' &&
                    (n.onclick = Np);
        }
        G0(t, i);
        var o;
        t = null;
        for (f in r)
            if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null)
                if (f === 'style') {
                    var a = r[f];
                    for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ''));
                } else
                    f !== 'dangerouslySetInnerHTML' &&
                        f !== 'children' &&
                        f !== 'suppressContentEditableWarning' &&
                        f !== 'suppressHydrationWarning' &&
                        f !== 'autoFocus' &&
                        (Xc.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
        for (f in i) {
            var c = i[f];
            if (
                ((a = r != null ? r[f] : void 0),
                i.hasOwnProperty(f) && c !== a && (c != null || a != null))
            )
                if (f === 'style')
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) ||
                                (c && c.hasOwnProperty(o)) ||
                                (t || (t = {}), (t[o] = ''));
                        for (o in c)
                            c.hasOwnProperty(o) && a[o] !== c[o] && (t || (t = {}), (t[o] = c[o]));
                    } else t || (s || (s = []), s.push(f, t)), (t = c);
                else
                    f === 'dangerouslySetInnerHTML'
                        ? ((c = c ? c.__html : void 0),
                          (a = a ? a.__html : void 0),
                          c != null && a !== c && (s = s || []).push(f, c))
                        : f === 'children'
                        ? (typeof c != 'string' && typeof c != 'number') ||
                          (s = s || []).push(f, '' + c)
                        : f !== 'suppressContentEditableWarning' &&
                          f !== 'suppressHydrationWarning' &&
                          (Xc.hasOwnProperty(f)
                              ? (c != null && f === 'onScroll' && en('scroll', n),
                                s || a === c || (s = []))
                              : (s = s || []).push(f, c));
        }
        t && (s = s || []).push('style', t);
        var f = s;
        (e.updateQueue = f) && (e.flags |= 4);
    }
};
l2 = function (n, e, t, i) {
    t !== i && (e.flags |= 4);
};
function rc(n, e) {
    if (!an)
        switch (n.tailMode) {
            case 'hidden':
                e = n.tail;
                for (var t = null; e !== null; ) e.alternate !== null && (t = e), (e = e.sibling);
                t === null ? (n.tail = null) : (t.sibling = null);
                break;
            case 'collapsed':
                t = n.tail;
                for (var i = null; t !== null; ) t.alternate !== null && (i = t), (t = t.sibling);
                i === null
                    ? e || n.tail === null
                        ? (n.tail = null)
                        : (n.tail.sibling = null)
                    : (i.sibling = null);
        }
}
function ui(n) {
    var e = n.alternate !== null && n.alternate.child === n.child,
        t = 0,
        i = 0;
    if (e)
        for (var r = n.child; r !== null; )
            (t |= r.lanes | r.childLanes),
                (i |= r.subtreeFlags & 14680064),
                (i |= r.flags & 14680064),
                (r.return = n),
                (r = r.sibling);
    else
        for (r = n.child; r !== null; )
            (t |= r.lanes | r.childLanes),
                (i |= r.subtreeFlags),
                (i |= r.flags),
                (r.return = n),
                (r = r.sibling);
    return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function pL(n, e, t) {
    var i = e.pendingProps;
    switch ((Gy(e), e.tag)) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return ui(e), null;
        case 1:
            return ki(e.type) && Dp(), ui(e), null;
        case 3:
            return (
                (i = e.stateNode),
                mu(),
                tn(Fi),
                tn(gi),
                Qy(),
                i.pendingContext && ((i.context = i.pendingContext), (i.pendingContext = null)),
                (n === null || n.child === null) &&
                    (th(e)
                        ? (e.flags |= 4)
                        : n === null ||
                          (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
                          ((e.flags |= 1024), Fr !== null && (E_(Fr), (Fr = null)))),
                g_(n, e),
                ui(e),
                null
            );
        case 5:
            Jy(e);
            var r = wa(sf.current);
            if (((t = e.type), n !== null && e.stateNode != null))
                a2(n, e, t, i, r), n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
            else {
                if (!i) {
                    if (e.stateNode === null) throw Error(Te(166));
                    return ui(e), null;
                }
                if (((n = wa(cs.current)), th(e))) {
                    (i = e.stateNode), (t = e.type);
                    var s = e.memoizedProps;
                    switch (((i[ss] = e), (i[nf] = s), (n = (e.mode & 1) !== 0), t)) {
                        case 'dialog':
                            en('cancel', i), en('close', i);
                            break;
                        case 'iframe':
                        case 'object':
                        case 'embed':
                            en('load', i);
                            break;
                        case 'video':
                        case 'audio':
                            for (r = 0; r < Rc.length; r++) en(Rc[r], i);
                            break;
                        case 'source':
                            en('error', i);
                            break;
                        case 'img':
                        case 'image':
                        case 'link':
                            en('error', i), en('load', i);
                            break;
                        case 'details':
                            en('toggle', i);
                            break;
                        case 'input':
                            YS(i, s), en('invalid', i);
                            break;
                        case 'select':
                            (i._wrapperState = { wasMultiple: !!s.multiple }), en('invalid', i);
                            break;
                        case 'textarea':
                            ZS(i, s), en('invalid', i);
                    }
                    G0(t, s), (r = null);
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === 'children'
                                ? typeof a == 'string'
                                    ? i.textContent !== a &&
                                      (s.suppressHydrationWarning !== !0 && eh(i.textContent, a, n),
                                      (r = ['children', a]))
                                    : typeof a == 'number' &&
                                      i.textContent !== '' + a &&
                                      (s.suppressHydrationWarning !== !0 && eh(i.textContent, a, n),
                                      (r = ['children', '' + a]))
                                : Xc.hasOwnProperty(o) &&
                                  a != null &&
                                  o === 'onScroll' &&
                                  en('scroll', i);
                        }
                    switch (t) {
                        case 'input':
                            Xd(i), qS(i, s, !0);
                            break;
                        case 'textarea':
                            Xd(i), KS(i);
                            break;
                        case 'select':
                        case 'option':
                            break;
                        default:
                            typeof s.onClick == 'function' && (i.onclick = Np);
                    }
                    (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
                } else {
                    (o = r.nodeType === 9 ? r : r.ownerDocument),
                        n === 'http://www.w3.org/1999/xhtml' && (n = UT(t)),
                        n === 'http://www.w3.org/1999/xhtml'
                            ? t === 'script'
                                ? ((n = o.createElement('div')),
                                  (n.innerHTML = '<script></script>'),
                                  (n = n.removeChild(n.firstChild)))
                                : typeof i.is == 'string'
                                ? (n = o.createElement(t, { is: i.is }))
                                : ((n = o.createElement(t)),
                                  t === 'select' &&
                                      ((o = n),
                                      i.multiple ? (o.multiple = !0) : i.size && (o.size = i.size)))
                            : (n = o.createElementNS(n, t)),
                        (n[ss] = e),
                        (n[nf] = i),
                        o2(n, e, !1, !1),
                        (e.stateNode = n);
                    e: {
                        switch (((o = W0(t, i)), t)) {
                            case 'dialog':
                                en('cancel', n), en('close', n), (r = i);
                                break;
                            case 'iframe':
                            case 'object':
                            case 'embed':
                                en('load', n), (r = i);
                                break;
                            case 'video':
                            case 'audio':
                                for (r = 0; r < Rc.length; r++) en(Rc[r], n);
                                r = i;
                                break;
                            case 'source':
                                en('error', n), (r = i);
                                break;
                            case 'img':
                            case 'image':
                            case 'link':
                                en('error', n), en('load', n), (r = i);
                                break;
                            case 'details':
                                en('toggle', n), (r = i);
                                break;
                            case 'input':
                                YS(n, i), (r = k0(n, i)), en('invalid', n);
                                break;
                            case 'option':
                                r = i;
                                break;
                            case 'select':
                                (n._wrapperState = { wasMultiple: !!i.multiple }),
                                    (r = gn({}, i, { value: void 0 })),
                                    en('invalid', n);
                                break;
                            case 'textarea':
                                ZS(n, i), (r = H0(n, i)), en('invalid', n);
                                break;
                            default:
                                r = i;
                        }
                        G0(t, r), (a = r);
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var c = a[s];
                                s === 'style'
                                    ? kT(n, c)
                                    : s === 'dangerouslySetInnerHTML'
                                    ? ((c = c ? c.__html : void 0), c != null && OT(n, c))
                                    : s === 'children'
                                    ? typeof c == 'string'
                                        ? (t !== 'textarea' || c !== '') && Yc(n, c)
                                        : typeof c == 'number' && Yc(n, '' + c)
                                    : s !== 'suppressContentEditableWarning' &&
                                      s !== 'suppressHydrationWarning' &&
                                      s !== 'autoFocus' &&
                                      (Xc.hasOwnProperty(s)
                                          ? c != null && s === 'onScroll' && en('scroll', n)
                                          : c != null && by(n, s, c, o));
                            }
                        switch (t) {
                            case 'input':
                                Xd(n), qS(n, i, !1);
                                break;
                            case 'textarea':
                                Xd(n), KS(n);
                                break;
                            case 'option':
                                i.value != null && n.setAttribute('value', '' + Uo(i.value));
                                break;
                            case 'select':
                                (n.multiple = !!i.multiple),
                                    (s = i.value),
                                    s != null
                                        ? ru(n, !!i.multiple, s, !1)
                                        : i.defaultValue != null &&
                                          ru(n, !!i.multiple, i.defaultValue, !0);
                                break;
                            default:
                                typeof r.onClick == 'function' && (n.onclick = Np);
                        }
                        switch (t) {
                            case 'button':
                            case 'input':
                            case 'select':
                            case 'textarea':
                                i = !!i.autoFocus;
                                break e;
                            case 'img':
                                i = !0;
                                break e;
                            default:
                                i = !1;
                        }
                    }
                    i && (e.flags |= 4);
                }
                e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
            }
            return ui(e), null;
        case 6:
            if (n && e.stateNode != null) l2(n, e, n.memoizedProps, i);
            else {
                if (typeof i != 'string' && e.stateNode === null) throw Error(Te(166));
                if (((t = wa(sf.current)), wa(cs.current), th(e))) {
                    if (
                        ((i = e.stateNode),
                        (t = e.memoizedProps),
                        (i[ss] = e),
                        (s = i.nodeValue !== t) && ((n = $i), n !== null))
                    )
                        switch (n.tag) {
                            case 3:
                                eh(i.nodeValue, t, (n.mode & 1) !== 0);
                                break;
                            case 5:
                                n.memoizedProps.suppressHydrationWarning !== !0 &&
                                    eh(i.nodeValue, t, (n.mode & 1) !== 0);
                        }
                    s && (e.flags |= 4);
                } else
                    (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
                        (i[ss] = e),
                        (e.stateNode = i);
            }
            return ui(e), null;
        case 13:
            if (
                (tn(fn),
                (i = e.memoizedState),
                n === null || (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
            ) {
                if (an && Qi !== null && e.mode & 1 && !(e.flags & 128))
                    TA(), hu(), (e.flags |= 98560), (s = !1);
                else if (((s = th(e)), i !== null && i.dehydrated !== null)) {
                    if (n === null) {
                        if (!s) throw Error(Te(318));
                        if (((s = e.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
                            throw Error(Te(317));
                        s[ss] = e;
                    } else hu(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
                    ui(e), (s = !1);
                } else Fr !== null && (E_(Fr), (Fr = null)), (s = !0);
                if (!s) return e.flags & 65536 ? e : null;
            }
            return e.flags & 128
                ? ((e.lanes = t), e)
                : ((i = i !== null),
                  i !== (n !== null && n.memoizedState !== null) &&
                      i &&
                      ((e.child.flags |= 8192),
                      e.mode & 1 && (n === null || fn.current & 1 ? zn === 0 && (zn = 3) : cx())),
                  e.updateQueue !== null && (e.flags |= 4),
                  ui(e),
                  null);
        case 4:
            return mu(), g_(n, e), n === null && ef(e.stateNode.containerInfo), ui(e), null;
        case 10:
            return Yy(e.type._context), ui(e), null;
        case 17:
            return ki(e.type) && Dp(), ui(e), null;
        case 19:
            if ((tn(fn), (s = e.memoizedState), s === null)) return ui(e), null;
            if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
                if (i) rc(s, !1);
                else {
                    if (zn !== 0 || (n !== null && n.flags & 128))
                        for (n = e.child; n !== null; ) {
                            if (((o = Hp(n)), o !== null)) {
                                for (
                                    e.flags |= 128,
                                        rc(s, !1),
                                        i = o.updateQueue,
                                        i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                                        e.subtreeFlags = 0,
                                        i = t,
                                        t = e.child;
                                    t !== null;

                                )
                                    (s = t),
                                        (n = i),
                                        (s.flags &= 14680066),
                                        (o = s.alternate),
                                        o === null
                                            ? ((s.childLanes = 0),
                                              (s.lanes = n),
                                              (s.child = null),
                                              (s.subtreeFlags = 0),
                                              (s.memoizedProps = null),
                                              (s.memoizedState = null),
                                              (s.updateQueue = null),
                                              (s.dependencies = null),
                                              (s.stateNode = null))
                                            : ((s.childLanes = o.childLanes),
                                              (s.lanes = o.lanes),
                                              (s.child = o.child),
                                              (s.subtreeFlags = 0),
                                              (s.deletions = null),
                                              (s.memoizedProps = o.memoizedProps),
                                              (s.memoizedState = o.memoizedState),
                                              (s.updateQueue = o.updateQueue),
                                              (s.type = o.type),
                                              (n = o.dependencies),
                                              (s.dependencies =
                                                  n === null
                                                      ? null
                                                      : {
                                                            lanes: n.lanes,
                                                            firstContext: n.firstContext,
                                                        })),
                                        (t = t.sibling);
                                return Qt(fn, (fn.current & 1) | 2), e.child;
                            }
                            n = n.sibling;
                        }
                    s.tail !== null &&
                        Rn() > vu &&
                        ((e.flags |= 128), (i = !0), rc(s, !1), (e.lanes = 4194304));
                }
            else {
                if (!i)
                    if (((n = Hp(o)), n !== null)) {
                        if (
                            ((e.flags |= 128),
                            (i = !0),
                            (t = n.updateQueue),
                            t !== null && ((e.updateQueue = t), (e.flags |= 4)),
                            rc(s, !0),
                            s.tail === null && s.tailMode === 'hidden' && !o.alternate && !an)
                        )
                            return ui(e), null;
                    } else
                        2 * Rn() - s.renderingStartTime > vu &&
                            t !== 1073741824 &&
                            ((e.flags |= 128), (i = !0), rc(s, !1), (e.lanes = 4194304));
                s.isBackwards
                    ? ((o.sibling = e.child), (e.child = o))
                    : ((t = s.last), t !== null ? (t.sibling = o) : (e.child = o), (s.last = o));
            }
            return s.tail !== null
                ? ((e = s.tail),
                  (s.rendering = e),
                  (s.tail = e.sibling),
                  (s.renderingStartTime = Rn()),
                  (e.sibling = null),
                  (t = fn.current),
                  Qt(fn, i ? (t & 1) | 2 : t & 1),
                  e)
                : (ui(e), null);
        case 22:
        case 23:
            return (
                ux(),
                (i = e.memoizedState !== null),
                n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
                i && e.mode & 1
                    ? Zi & 1073741824 && (ui(e), e.subtreeFlags & 6 && (e.flags |= 8192))
                    : ui(e),
                null
            );
        case 24:
            return null;
        case 25:
            return null;
    }
    throw Error(Te(156, e.tag));
}
function mL(n, e) {
    switch ((Gy(e), e.tag)) {
        case 1:
            return (
                ki(e.type) && Dp(),
                (n = e.flags),
                n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
            );
        case 3:
            return (
                mu(),
                tn(Fi),
                tn(gi),
                Qy(),
                (n = e.flags),
                n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
            );
        case 5:
            return Jy(e), null;
        case 13:
            if ((tn(fn), (n = e.memoizedState), n !== null && n.dehydrated !== null)) {
                if (e.alternate === null) throw Error(Te(340));
                hu();
            }
            return (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null;
        case 19:
            return tn(fn), null;
        case 4:
            return mu(), null;
        case 10:
            return Yy(e.type._context), null;
        case 22:
        case 23:
            return ux(), null;
        case 24:
            return null;
        default:
            return null;
    }
}
var rh = !1,
    hi = !1,
    gL = typeof WeakSet == 'function' ? WeakSet : Set,
    qe = null;
function ql(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == 'function')
            try {
                t(null);
            } catch (i) {
                Sn(n, e, i);
            }
        else t.current = null;
}
function v_(n, e, t) {
    try {
        t();
    } catch (i) {
        Sn(n, e, i);
    }
}
var zM = !1;
function vL(n, e) {
    if (((e_ = Pp), (n = dA()), Hy(n))) {
        if ('selectionStart' in n) var t = { start: n.selectionStart, end: n.selectionEnd };
        else
            e: {
                t = ((t = n.ownerDocument) && t.defaultView) || window;
                var i = t.getSelection && t.getSelection();
                if (i && i.rangeCount !== 0) {
                    t = i.anchorNode;
                    var r = i.anchorOffset,
                        s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        t.nodeType, s.nodeType;
                    } catch {
                        t = null;
                        break e;
                    }
                    var o = 0,
                        a = -1,
                        c = -1,
                        f = 0,
                        d = 0,
                        h = n,
                        p = null;
                    t: for (;;) {
                        for (
                            var v;
                            h !== t || (r !== 0 && h.nodeType !== 3) || (a = o + r),
                                h !== s || (i !== 0 && h.nodeType !== 3) || (c = o + i),
                                h.nodeType === 3 && (o += h.nodeValue.length),
                                (v = h.firstChild) !== null;

                        )
                            (p = h), (h = v);
                        for (;;) {
                            if (h === n) break t;
                            if (
                                (p === t && ++f === r && (a = o),
                                p === s && ++d === i && (c = o),
                                (v = h.nextSibling) !== null)
                            )
                                break;
                            (h = p), (p = h.parentNode);
                        }
                        h = v;
                    }
                    t = a === -1 || c === -1 ? null : { start: a, end: c };
                } else t = null;
            }
        t = t || { start: 0, end: 0 };
    } else t = null;
    for (t_ = { focusedElem: n, selectionRange: t }, Pp = !1, qe = e; qe !== null; )
        if (((e = qe), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
            (n.return = e), (qe = n);
        else
            for (; qe !== null; ) {
                e = qe;
                try {
                    var _ = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (_ !== null) {
                                    var w = _.memoizedProps,
                                        x = _.memoizedState,
                                        g = e.stateNode,
                                        S = g.getSnapshotBeforeUpdate(
                                            e.elementType === e.type ? w : Nr(e.type, w),
                                            x
                                        );
                                    g.__reactInternalSnapshotBeforeUpdate = S;
                                }
                                break;
                            case 3:
                                var M = e.stateNode.containerInfo;
                                M.nodeType === 1
                                    ? (M.textContent = '')
                                    : M.nodeType === 9 &&
                                      M.documentElement &&
                                      M.removeChild(M.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(Te(163));
                        }
                } catch (T) {
                    Sn(e, e.return, T);
                }
                if (((n = e.sibling), n !== null)) {
                    (n.return = e.return), (qe = n);
                    break;
                }
                qe = e.return;
            }
    return (_ = zM), (zM = !1), _;
}
function Fc(n, e, t) {
    var i = e.updateQueue;
    if (((i = i !== null ? i.lastEffect : null), i !== null)) {
        var r = (i = i.next);
        do {
            if ((r.tag & n) === n) {
                var s = r.destroy;
                (r.destroy = void 0), s !== void 0 && v_(e, t, s);
            }
            r = r.next;
        } while (r !== i);
    }
}
function vm(n, e) {
    if (((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)) {
        var t = (e = e.next);
        do {
            if ((t.tag & n) === n) {
                var i = t.create;
                t.destroy = i();
            }
            t = t.next;
        } while (t !== e);
    }
}
function __(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
            case 5:
                n = t;
                break;
            default:
                n = t;
        }
        typeof e == 'function' ? e(n) : (e.current = n);
    }
}
function u2(n) {
    var e = n.alternate;
    e !== null && ((n.alternate = null), u2(e)),
        (n.child = null),
        (n.deletions = null),
        (n.sibling = null),
        n.tag === 5 &&
            ((e = n.stateNode),
            e !== null && (delete e[ss], delete e[nf], delete e[r_], delete e[$3], delete e[eL])),
        (n.stateNode = null),
        (n.return = null),
        (n.dependencies = null),
        (n.memoizedProps = null),
        (n.memoizedState = null),
        (n.pendingProps = null),
        (n.stateNode = null),
        (n.updateQueue = null);
}
function c2(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function BM(n) {
    e: for (;;) {
        for (; n.sibling === null; ) {
            if (n.return === null || c2(n.return)) return null;
            n = n.return;
        }
        for (
            n.sibling.return = n.return, n = n.sibling;
            n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

        ) {
            if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
            (n.child.return = n), (n = n.child);
        }
        if (!(n.flags & 2)) return n.stateNode;
    }
}
function y_(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        (n = n.stateNode),
            e
                ? t.nodeType === 8
                    ? t.parentNode.insertBefore(n, e)
                    : t.insertBefore(n, e)
                : (t.nodeType === 8
                      ? ((e = t.parentNode), e.insertBefore(n, t))
                      : ((e = t), e.appendChild(n)),
                  (t = t._reactRootContainer),
                  t != null || e.onclick !== null || (e.onclick = Np));
    else if (i !== 4 && ((n = n.child), n !== null))
        for (y_(n, e, t), n = n.sibling; n !== null; ) y_(n, e, t), (n = n.sibling);
}
function x_(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6) (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (i !== 4 && ((n = n.child), n !== null))
        for (x_(n, e, t), n = n.sibling; n !== null; ) x_(n, e, t), (n = n.sibling);
}
var ei = null,
    Ur = !1;
function ro(n, e, t) {
    for (t = t.child; t !== null; ) f2(n, e, t), (t = t.sibling);
}
function f2(n, e, t) {
    if (us && typeof us.onCommitFiberUnmount == 'function')
        try {
            us.onCommitFiberUnmount(um, t);
        } catch {}
    switch (t.tag) {
        case 5:
            hi || ql(t, e);
        case 6:
            var i = ei,
                r = Ur;
            (ei = null),
                ro(n, e, t),
                (ei = i),
                (Ur = r),
                ei !== null &&
                    (Ur
                        ? ((n = ei),
                          (t = t.stateNode),
                          n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
                        : ei.removeChild(t.stateNode));
            break;
        case 18:
            ei !== null &&
                (Ur
                    ? ((n = ei),
                      (t = t.stateNode),
                      n.nodeType === 8 ? Mv(n.parentNode, t) : n.nodeType === 1 && Mv(n, t),
                      Jc(n))
                    : Mv(ei, t.stateNode));
            break;
        case 4:
            (i = ei),
                (r = Ur),
                (ei = t.stateNode.containerInfo),
                (Ur = !0),
                ro(n, e, t),
                (ei = i),
                (Ur = r);
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!hi && ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))) {
                r = i = i.next;
                do {
                    var s = r,
                        o = s.destroy;
                    (s = s.tag), o !== void 0 && (s & 2 || s & 4) && v_(t, e, o), (r = r.next);
                } while (r !== i);
            }
            ro(n, e, t);
            break;
        case 1:
            if (!hi && (ql(t, e), (i = t.stateNode), typeof i.componentWillUnmount == 'function'))
                try {
                    (i.props = t.memoizedProps),
                        (i.state = t.memoizedState),
                        i.componentWillUnmount();
                } catch (a) {
                    Sn(t, e, a);
                }
            ro(n, e, t);
            break;
        case 21:
            ro(n, e, t);
            break;
        case 22:
            t.mode & 1
                ? ((hi = (i = hi) || t.memoizedState !== null), ro(n, e, t), (hi = i))
                : ro(n, e, t);
            break;
        default:
            ro(n, e, t);
    }
}
function HM(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new gL()),
            e.forEach(function (i) {
                var r = AL.bind(null, n, i);
                t.has(i) || (t.add(i), i.then(r, r));
            });
    }
}
function Rr(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            try {
                var s = n,
                    o = e,
                    a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                        case 5:
                            (ei = a.stateNode), (Ur = !1);
                            break e;
                        case 3:
                            (ei = a.stateNode.containerInfo), (Ur = !0);
                            break e;
                        case 4:
                            (ei = a.stateNode.containerInfo), (Ur = !0);
                            break e;
                    }
                    a = a.return;
                }
                if (ei === null) throw Error(Te(160));
                f2(s, o, r), (ei = null), (Ur = !1);
                var c = r.alternate;
                c !== null && (c.return = null), (r.return = null);
            } catch (f) {
                Sn(r, e, f);
            }
        }
    if (e.subtreeFlags & 12854) for (e = e.child; e !== null; ) d2(e, n), (e = e.sibling);
}
function d2(n, e) {
    var t = n.alternate,
        i = n.flags;
    switch (n.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if ((Rr(e, n), is(n), i & 4)) {
                try {
                    Fc(3, n, n.return), vm(3, n);
                } catch (w) {
                    Sn(n, n.return, w);
                }
                try {
                    Fc(5, n, n.return);
                } catch (w) {
                    Sn(n, n.return, w);
                }
            }
            break;
        case 1:
            Rr(e, n), is(n), i & 512 && t !== null && ql(t, t.return);
            break;
        case 5:
            if ((Rr(e, n), is(n), i & 512 && t !== null && ql(t, t.return), n.flags & 32)) {
                var r = n.stateNode;
                try {
                    Yc(r, '');
                } catch (w) {
                    Sn(n, n.return, w);
                }
            }
            if (i & 4 && ((r = n.stateNode), r != null)) {
                var s = n.memoizedProps,
                    o = t !== null ? t.memoizedProps : s,
                    a = n.type,
                    c = n.updateQueue;
                if (((n.updateQueue = null), c !== null))
                    try {
                        a === 'input' && s.type === 'radio' && s.name != null && NT(r, s), W0(a, o);
                        var f = W0(a, s);
                        for (o = 0; o < c.length; o += 2) {
                            var d = c[o],
                                h = c[o + 1];
                            d === 'style'
                                ? kT(r, h)
                                : d === 'dangerouslySetInnerHTML'
                                ? OT(r, h)
                                : d === 'children'
                                ? Yc(r, h)
                                : by(r, d, h, f);
                        }
                        switch (a) {
                            case 'input':
                                z0(r, s);
                                break;
                            case 'textarea':
                                DT(r, s);
                                break;
                            case 'select':
                                var p = r._wrapperState.wasMultiple;
                                r._wrapperState.wasMultiple = !!s.multiple;
                                var v = s.value;
                                v != null
                                    ? ru(r, !!s.multiple, v, !1)
                                    : p !== !!s.multiple &&
                                      (s.defaultValue != null
                                          ? ru(r, !!s.multiple, s.defaultValue, !0)
                                          : ru(r, !!s.multiple, s.multiple ? [] : '', !1));
                        }
                        r[nf] = s;
                    } catch (w) {
                        Sn(n, n.return, w);
                    }
            }
            break;
        case 6:
            if ((Rr(e, n), is(n), i & 4)) {
                if (n.stateNode === null) throw Error(Te(162));
                (r = n.stateNode), (s = n.memoizedProps);
                try {
                    r.nodeValue = s;
                } catch (w) {
                    Sn(n, n.return, w);
                }
            }
            break;
        case 3:
            if ((Rr(e, n), is(n), i & 4 && t !== null && t.memoizedState.isDehydrated))
                try {
                    Jc(e.containerInfo);
                } catch (w) {
                    Sn(n, n.return, w);
                }
            break;
        case 4:
            Rr(e, n), is(n);
            break;
        case 13:
            Rr(e, n),
                is(n),
                (r = n.child),
                r.flags & 8192 &&
                    ((s = r.memoizedState !== null),
                    (r.stateNode.isHidden = s),
                    !s ||
                        (r.alternate !== null && r.alternate.memoizedState !== null) ||
                        (ax = Rn())),
                i & 4 && HM(n);
            break;
        case 22:
            if (
                ((d = t !== null && t.memoizedState !== null),
                n.mode & 1 ? ((hi = (f = hi) || d), Rr(e, n), (hi = f)) : Rr(e, n),
                is(n),
                i & 8192)
            ) {
                if (
                    ((f = n.memoizedState !== null), (n.stateNode.isHidden = f) && !d && n.mode & 1)
                )
                    for (qe = n, d = n.child; d !== null; ) {
                        for (h = qe = d; qe !== null; ) {
                            switch (((p = qe), (v = p.child), p.tag)) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Fc(4, p, p.return);
                                    break;
                                case 1:
                                    ql(p, p.return);
                                    var _ = p.stateNode;
                                    if (typeof _.componentWillUnmount == 'function') {
                                        (i = p), (t = p.return);
                                        try {
                                            (e = i),
                                                (_.props = e.memoizedProps),
                                                (_.state = e.memoizedState),
                                                _.componentWillUnmount();
                                        } catch (w) {
                                            Sn(i, t, w);
                                        }
                                    }
                                    break;
                                case 5:
                                    ql(p, p.return);
                                    break;
                                case 22:
                                    if (p.memoizedState !== null) {
                                        GM(h);
                                        continue;
                                    }
                            }
                            v !== null ? ((v.return = p), (qe = v)) : GM(h);
                        }
                        d = d.sibling;
                    }
                e: for (d = null, h = n; ; ) {
                    if (h.tag === 5) {
                        if (d === null) {
                            d = h;
                            try {
                                (r = h.stateNode),
                                    f
                                        ? ((s = r.style),
                                          typeof s.setProperty == 'function'
                                              ? s.setProperty('display', 'none', 'important')
                                              : (s.display = 'none'))
                                        : ((a = h.stateNode),
                                          (c = h.memoizedProps.style),
                                          (o =
                                              c != null && c.hasOwnProperty('display')
                                                  ? c.display
                                                  : null),
                                          (a.style.display = FT('display', o)));
                            } catch (w) {
                                Sn(n, n.return, w);
                            }
                        }
                    } else if (h.tag === 6) {
                        if (d === null)
                            try {
                                h.stateNode.nodeValue = f ? '' : h.memoizedProps;
                            } catch (w) {
                                Sn(n, n.return, w);
                            }
                    } else if (
                        ((h.tag !== 22 && h.tag !== 23) || h.memoizedState === null || h === n) &&
                        h.child !== null
                    ) {
                        (h.child.return = h), (h = h.child);
                        continue;
                    }
                    if (h === n) break e;
                    for (; h.sibling === null; ) {
                        if (h.return === null || h.return === n) break e;
                        d === h && (d = null), (h = h.return);
                    }
                    d === h && (d = null), (h.sibling.return = h.return), (h = h.sibling);
                }
            }
            break;
        case 19:
            Rr(e, n), is(n), i & 4 && HM(n);
            break;
        case 21:
            break;
        default:
            Rr(e, n), is(n);
    }
}
function is(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (c2(t)) {
                        var i = t;
                        break e;
                    }
                    t = t.return;
                }
                throw Error(Te(160));
            }
            switch (i.tag) {
                case 5:
                    var r = i.stateNode;
                    i.flags & 32 && (Yc(r, ''), (i.flags &= -33));
                    var s = BM(n);
                    x_(n, s, r);
                    break;
                case 3:
                case 4:
                    var o = i.stateNode.containerInfo,
                        a = BM(n);
                    y_(n, a, o);
                    break;
                default:
                    throw Error(Te(161));
            }
        } catch (c) {
            Sn(n, n.return, c);
        }
        n.flags &= -3;
    }
    e & 4096 && (n.flags &= -4097);
}
function _L(n, e, t) {
    (qe = n), h2(n);
}
function h2(n, e, t) {
    for (var i = (n.mode & 1) !== 0; qe !== null; ) {
        var r = qe,
            s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || rh;
            if (!o) {
                var a = r.alternate,
                    c = (a !== null && a.memoizedState !== null) || hi;
                a = rh;
                var f = hi;
                if (((rh = o), (hi = c) && !f))
                    for (qe = r; qe !== null; )
                        (o = qe),
                            (c = o.child),
                            o.tag === 22 && o.memoizedState !== null
                                ? WM(r)
                                : c !== null
                                ? ((c.return = o), (qe = c))
                                : WM(r);
                for (; s !== null; ) (qe = s), h2(s), (s = s.sibling);
                (qe = r), (rh = a), (hi = f);
            }
            VM(n);
        } else r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (qe = s)) : VM(n);
    }
}
function VM(n) {
    for (; qe !== null; ) {
        var e = qe;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            hi || vm(5, e);
                            break;
                        case 1:
                            var i = e.stateNode;
                            if (e.flags & 4 && !hi)
                                if (t === null) i.componentDidMount();
                                else {
                                    var r =
                                        e.elementType === e.type
                                            ? t.memoizedProps
                                            : Nr(e.type, t.memoizedProps);
                                    i.componentDidUpdate(
                                        r,
                                        t.memoizedState,
                                        i.__reactInternalSnapshotBeforeUpdate
                                    );
                                }
                            var s = e.updateQueue;
                            s !== null && TM(e, s, i);
                            break;
                        case 3:
                            var o = e.updateQueue;
                            if (o !== null) {
                                if (((t = null), e.child !== null))
                                    switch (e.child.tag) {
                                        case 5:
                                            t = e.child.stateNode;
                                            break;
                                        case 1:
                                            t = e.child.stateNode;
                                    }
                                TM(e, o, t);
                            }
                            break;
                        case 5:
                            var a = e.stateNode;
                            if (t === null && e.flags & 4) {
                                t = a;
                                var c = e.memoizedProps;
                                switch (e.type) {
                                    case 'button':
                                    case 'input':
                                    case 'select':
                                    case 'textarea':
                                        c.autoFocus && t.focus();
                                        break;
                                    case 'img':
                                        c.src && (t.src = c.src);
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (e.memoizedState === null) {
                                var f = e.alternate;
                                if (f !== null) {
                                    var d = f.memoizedState;
                                    if (d !== null) {
                                        var h = d.dehydrated;
                                        h !== null && Jc(h);
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(Te(163));
                    }
                hi || (e.flags & 512 && __(e));
            } catch (p) {
                Sn(e, e.return, p);
            }
        }
        if (e === n) {
            qe = null;
            break;
        }
        if (((t = e.sibling), t !== null)) {
            (t.return = e.return), (qe = t);
            break;
        }
        qe = e.return;
    }
}
function GM(n) {
    for (; qe !== null; ) {
        var e = qe;
        if (e === n) {
            qe = null;
            break;
        }
        var t = e.sibling;
        if (t !== null) {
            (t.return = e.return), (qe = t);
            break;
        }
        qe = e.return;
    }
}
function WM(n) {
    for (; qe !== null; ) {
        var e = qe;
        try {
            switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var t = e.return;
                    try {
                        vm(4, e);
                    } catch (c) {
                        Sn(e, t, c);
                    }
                    break;
                case 1:
                    var i = e.stateNode;
                    if (typeof i.componentDidMount == 'function') {
                        var r = e.return;
                        try {
                            i.componentDidMount();
                        } catch (c) {
                            Sn(e, r, c);
                        }
                    }
                    var s = e.return;
                    try {
                        __(e);
                    } catch (c) {
                        Sn(e, s, c);
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        __(e);
                    } catch (c) {
                        Sn(e, o, c);
                    }
            }
        } catch (c) {
            Sn(e, e.return, c);
        }
        if (e === n) {
            qe = null;
            break;
        }
        var a = e.sibling;
        if (a !== null) {
            (a.return = e.return), (qe = a);
            break;
        }
        qe = e.return;
    }
}
var yL = Math.ceil,
    Wp = Xs.ReactCurrentDispatcher,
    sx = Xs.ReactCurrentOwner,
    Mr = Xs.ReactCurrentBatchConfig,
    Ot = 0,
    Kn = null,
    Un = null,
    ti = 0,
    Zi = 0,
    Zl = Bo(0),
    zn = 0,
    uf = null,
    Ba = 0,
    _m = 0,
    ox = 0,
    kc = null,
    Ui = null,
    ax = 0,
    vu = 1 / 0,
    bs = null,
    jp = !1,
    S_ = null,
    Ro = null,
    sh = !1,
    wo = null,
    Xp = 0,
    zc = 0,
    M_ = null,
    pp = -1,
    mp = 0;
function Ti() {
    return Ot & 6 ? Rn() : pp !== -1 ? pp : (pp = Rn());
}
function Po(n) {
    return n.mode & 1
        ? Ot & 2 && ti !== 0
            ? ti & -ti
            : nL.transition !== null
            ? (mp === 0 && (mp = KT()), mp)
            : ((n = jt), n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : iA(n.type))), n)
        : 1;
}
function Br(n, e, t, i) {
    if (50 < zc) throw ((zc = 0), (M_ = null), Error(Te(185)));
    Uf(n, t, i),
        (!(Ot & 2) || n !== Kn) &&
            (n === Kn && (!(Ot & 2) && (_m |= t), zn === 4 && xo(n, ti)),
            zi(n, i),
            t === 1 && Ot === 0 && !(e.mode & 1) && ((vu = Rn() + 500), pm && Ho()));
}
function zi(n, e) {
    var t = n.callbackNode;
    n3(n, e);
    var i = Rp(n, n === Kn ? ti : 0);
    if (i === 0) t !== null && $S(t), (n.callbackNode = null), (n.callbackPriority = 0);
    else if (((e = i & -i), n.callbackPriority !== e)) {
        if ((t != null && $S(t), e === 1))
            n.tag === 0 ? tL(jM.bind(null, n)) : MA(jM.bind(null, n)),
                J3(function () {
                    !(Ot & 6) && Ho();
                }),
                (t = null);
        else {
            switch (JT(i)) {
                case 1:
                    t = Ny;
                    break;
                case 4:
                    t = qT;
                    break;
                case 16:
                    t = bp;
                    break;
                case 536870912:
                    t = ZT;
                    break;
                default:
                    t = bp;
            }
            t = S2(t, p2.bind(null, n));
        }
        (n.callbackPriority = e), (n.callbackNode = t);
    }
}
function p2(n, e) {
    if (((pp = -1), (mp = 0), Ot & 6)) throw Error(Te(327));
    var t = n.callbackNode;
    if (uu() && n.callbackNode !== t) return null;
    var i = Rp(n, n === Kn ? ti : 0);
    if (i === 0) return null;
    if (i & 30 || i & n.expiredLanes || e) e = Yp(n, i);
    else {
        e = i;
        var r = Ot;
        Ot |= 2;
        var s = g2();
        (Kn !== n || ti !== e) && ((bs = null), (vu = Rn() + 500), Pa(n, e));
        do
            try {
                ML();
                break;
            } catch (a) {
                m2(n, a);
            }
        while (1);
        Xy(), (Wp.current = s), (Ot = r), Un !== null ? (e = 0) : ((Kn = null), (ti = 0), (e = zn));
    }
    if (e !== 0) {
        if ((e === 2 && ((r = Z0(n)), r !== 0 && ((i = r), (e = w_(n, r)))), e === 1))
            throw ((t = uf), Pa(n, 0), xo(n, i), zi(n, Rn()), t);
        if (e === 6) xo(n, i);
        else {
            if (
                ((r = n.current.alternate),
                !(i & 30) &&
                    !xL(r) &&
                    ((e = Yp(n, i)),
                    e === 2 && ((s = Z0(n)), s !== 0 && ((i = s), (e = w_(n, s)))),
                    e === 1))
            )
                throw ((t = uf), Pa(n, 0), xo(n, i), zi(n, Rn()), t);
            switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
                case 0:
                case 1:
                    throw Error(Te(345));
                case 2:
                    ga(n, Ui, bs);
                    break;
                case 3:
                    if ((xo(n, i), (i & 130023424) === i && ((e = ax + 500 - Rn()), 10 < e))) {
                        if (Rp(n, 0) !== 0) break;
                        if (((r = n.suspendedLanes), (r & i) !== i)) {
                            Ti(), (n.pingedLanes |= n.suspendedLanes & r);
                            break;
                        }
                        n.timeoutHandle = i_(ga.bind(null, n, Ui, bs), e);
                        break;
                    }
                    ga(n, Ui, bs);
                    break;
                case 4:
                    if ((xo(n, i), (i & 4194240) === i)) break;
                    for (e = n.eventTimes, r = -1; 0 < i; ) {
                        var o = 31 - zr(i);
                        (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
                    }
                    if (
                        ((i = r),
                        (i = Rn() - i),
                        (i =
                            (120 > i
                                ? 120
                                : 480 > i
                                ? 480
                                : 1080 > i
                                ? 1080
                                : 1920 > i
                                ? 1920
                                : 3e3 > i
                                ? 3e3
                                : 4320 > i
                                ? 4320
                                : 1960 * yL(i / 1960)) - i),
                        10 < i)
                    ) {
                        n.timeoutHandle = i_(ga.bind(null, n, Ui, bs), i);
                        break;
                    }
                    ga(n, Ui, bs);
                    break;
                case 5:
                    ga(n, Ui, bs);
                    break;
                default:
                    throw Error(Te(329));
            }
        }
    }
    return zi(n, Rn()), n.callbackNode === t ? p2.bind(null, n) : null;
}
function w_(n, e) {
    var t = kc;
    return (
        n.current.memoizedState.isDehydrated && (Pa(n, e).flags |= 256),
        (n = Yp(n, e)),
        n !== 2 && ((e = Ui), (Ui = t), e !== null && E_(e)),
        n
    );
}
function E_(n) {
    Ui === null ? (Ui = n) : Ui.push.apply(Ui, n);
}
function xL(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && ((t = t.stores), t !== null))
                for (var i = 0; i < t.length; i++) {
                    var r = t[i],
                        s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!Hr(s(), r)) return !1;
                    } catch {
                        return !1;
                    }
                }
        }
        if (((t = e.child), e.subtreeFlags & 16384 && t !== null)) (t.return = e), (e = t);
        else {
            if (e === n) break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n) return !0;
                e = e.return;
            }
            (e.sibling.return = e.return), (e = e.sibling);
        }
    }
    return !0;
}
function xo(n, e) {
    for (
        e &= ~ox, e &= ~_m, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes;
        0 < e;

    ) {
        var t = 31 - zr(e),
            i = 1 << t;
        (n[t] = -1), (e &= ~i);
    }
}
function jM(n) {
    if (Ot & 6) throw Error(Te(327));
    uu();
    var e = Rp(n, 0);
    if (!(e & 1)) return zi(n, Rn()), null;
    var t = Yp(n, e);
    if (n.tag !== 0 && t === 2) {
        var i = Z0(n);
        i !== 0 && ((e = i), (t = w_(n, i)));
    }
    if (t === 1) throw ((t = uf), Pa(n, 0), xo(n, e), zi(n, Rn()), t);
    if (t === 6) throw Error(Te(345));
    return (
        (n.finishedWork = n.current.alternate),
        (n.finishedLanes = e),
        ga(n, Ui, bs),
        zi(n, Rn()),
        null
    );
}
function lx(n, e) {
    var t = Ot;
    Ot |= 1;
    try {
        return n(e);
    } finally {
        (Ot = t), Ot === 0 && ((vu = Rn() + 500), pm && Ho());
    }
}
function Ha(n) {
    wo !== null && wo.tag === 0 && !(Ot & 6) && uu();
    var e = Ot;
    Ot |= 1;
    var t = Mr.transition,
        i = jt;
    try {
        if (((Mr.transition = null), (jt = 1), n)) return n();
    } finally {
        (jt = i), (Mr.transition = t), (Ot = e), !(Ot & 6) && Ho();
    }
}
function ux() {
    (Zi = Zl.current), tn(Zl);
}
function Pa(n, e) {
    (n.finishedWork = null), (n.finishedLanes = 0);
    var t = n.timeoutHandle;
    if ((t !== -1 && ((n.timeoutHandle = -1), K3(t)), Un !== null))
        for (t = Un.return; t !== null; ) {
            var i = t;
            switch ((Gy(i), i.tag)) {
                case 1:
                    (i = i.type.childContextTypes), i != null && Dp();
                    break;
                case 3:
                    mu(), tn(Fi), tn(gi), Qy();
                    break;
                case 5:
                    Jy(i);
                    break;
                case 4:
                    mu();
                    break;
                case 13:
                    tn(fn);
                    break;
                case 19:
                    tn(fn);
                    break;
                case 10:
                    Yy(i.type._context);
                    break;
                case 22:
                case 23:
                    ux();
            }
            t = t.return;
        }
    if (
        ((Kn = n),
        (Un = n = Lo(n.current, null)),
        (ti = Zi = e),
        (zn = 0),
        (uf = null),
        (ox = _m = Ba = 0),
        (Ui = kc = null),
        Ma !== null)
    ) {
        for (e = 0; e < Ma.length; e++)
            if (((t = Ma[e]), (i = t.interleaved), i !== null)) {
                t.interleaved = null;
                var r = i.next,
                    s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    (s.next = r), (i.next = o);
                }
                t.pending = i;
            }
        Ma = null;
    }
    return n;
}
function m2(n, e) {
    do {
        var t = Un;
        try {
            if ((Xy(), (fp.current = Gp), Vp)) {
                for (var i = pn.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null), (i = i.next);
                }
                Vp = !1;
            }
            if (
                ((za = 0),
                (qn = kn = pn = null),
                (Oc = !1),
                (of = 0),
                (sx.current = null),
                t === null || t.return === null)
            ) {
                (zn = 1), (uf = e), (Un = null);
                break;
            }
            e: {
                var s = n,
                    o = t.return,
                    a = t,
                    c = e;
                if (
                    ((e = ti),
                    (a.flags |= 32768),
                    c !== null && typeof c == 'object' && typeof c.then == 'function')
                ) {
                    var f = c,
                        d = a,
                        h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var p = d.alternate;
                        p
                            ? ((d.updateQueue = p.updateQueue),
                              (d.memoizedState = p.memoizedState),
                              (d.lanes = p.lanes))
                            : ((d.updateQueue = null), (d.memoizedState = null));
                    }
                    var v = IM(o);
                    if (v !== null) {
                        (v.flags &= -257),
                            NM(v, o, a, s, e),
                            v.mode & 1 && LM(s, f, e),
                            (e = v),
                            (c = f);
                        var _ = e.updateQueue;
                        if (_ === null) {
                            var w = new Set();
                            w.add(c), (e.updateQueue = w);
                        } else _.add(c);
                        break e;
                    } else {
                        if (!(e & 1)) {
                            LM(s, f, e), cx();
                            break e;
                        }
                        c = Error(Te(426));
                    }
                } else if (an && a.mode & 1) {
                    var x = IM(o);
                    if (x !== null) {
                        !(x.flags & 65536) && (x.flags |= 256), NM(x, o, a, s, e), Wy(gu(c, a));
                        break e;
                    }
                }
                (s = c = gu(c, a)),
                    zn !== 4 && (zn = 2),
                    kc === null ? (kc = [s]) : kc.push(s),
                    (s = o);
                do {
                    switch (s.tag) {
                        case 3:
                            (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                            var g = QA(s, c, e);
                            EM(s, g);
                            break e;
                        case 1:
                            a = c;
                            var S = s.type,
                                M = s.stateNode;
                            if (
                                !(s.flags & 128) &&
                                (typeof S.getDerivedStateFromError == 'function' ||
                                    (M !== null &&
                                        typeof M.componentDidCatch == 'function' &&
                                        (Ro === null || !Ro.has(M))))
                            ) {
                                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                                var T = $A(s, a, e);
                                EM(s, T);
                                break e;
                            }
                    }
                    s = s.return;
                } while (s !== null);
            }
            _2(t);
        } catch (P) {
            (e = P), Un === t && t !== null && (Un = t = t.return);
            continue;
        }
        break;
    } while (1);
}
function g2() {
    var n = Wp.current;
    return (Wp.current = Gp), n === null ? Gp : n;
}
function cx() {
    (zn === 0 || zn === 3 || zn === 2) && (zn = 4),
        Kn === null || (!(Ba & 268435455) && !(_m & 268435455)) || xo(Kn, ti);
}
function Yp(n, e) {
    var t = Ot;
    Ot |= 2;
    var i = g2();
    (Kn !== n || ti !== e) && ((bs = null), Pa(n, e));
    do
        try {
            SL();
            break;
        } catch (r) {
            m2(n, r);
        }
    while (1);
    if ((Xy(), (Ot = t), (Wp.current = i), Un !== null)) throw Error(Te(261));
    return (Kn = null), (ti = 0), zn;
}
function SL() {
    for (; Un !== null; ) v2(Un);
}
function ML() {
    for (; Un !== null && !YP(); ) v2(Un);
}
function v2(n) {
    var e = x2(n.alternate, n, Zi);
    (n.memoizedProps = n.pendingProps), e === null ? _2(n) : (Un = e), (sx.current = null);
}
function _2(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (((n = e.return), e.flags & 32768)) {
            if (((t = mL(t, e)), t !== null)) {
                (t.flags &= 32767), (Un = t);
                return;
            }
            if (n !== null) (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
            else {
                (zn = 6), (Un = null);
                return;
            }
        } else if (((t = pL(t, e, Zi)), t !== null)) {
            Un = t;
            return;
        }
        if (((e = e.sibling), e !== null)) {
            Un = e;
            return;
        }
        Un = e = n;
    } while (e !== null);
    zn === 0 && (zn = 5);
}
function ga(n, e, t) {
    var i = jt,
        r = Mr.transition;
    try {
        (Mr.transition = null), (jt = 1), wL(n, e, t, i);
    } finally {
        (Mr.transition = r), (jt = i);
    }
    return null;
}
function wL(n, e, t, i) {
    do uu();
    while (wo !== null);
    if (Ot & 6) throw Error(Te(327));
    t = n.finishedWork;
    var r = n.finishedLanes;
    if (t === null) return null;
    if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current)) throw Error(Te(177));
    (n.callbackNode = null), (n.callbackPriority = 0);
    var s = t.lanes | t.childLanes;
    if (
        (i3(n, s),
        n === Kn && ((Un = Kn = null), (ti = 0)),
        (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
            sh ||
            ((sh = !0),
            S2(bp, function () {
                return uu(), null;
            })),
        (s = (t.flags & 15990) !== 0),
        t.subtreeFlags & 15990 || s)
    ) {
        (s = Mr.transition), (Mr.transition = null);
        var o = jt;
        jt = 1;
        var a = Ot;
        (Ot |= 4),
            (sx.current = null),
            vL(n, t),
            d2(t, n),
            G3(t_),
            (Pp = !!e_),
            (t_ = e_ = null),
            (n.current = t),
            _L(t),
            qP(),
            (Ot = a),
            (jt = o),
            (Mr.transition = s);
    } else n.current = t;
    if (
        (sh && ((sh = !1), (wo = n), (Xp = r)),
        (s = n.pendingLanes),
        s === 0 && (Ro = null),
        JP(t.stateNode),
        zi(n, Rn()),
        e !== null)
    )
        for (i = n.onRecoverableError, t = 0; t < e.length; t++)
            (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
    if (jp) throw ((jp = !1), (n = S_), (S_ = null), n);
    return (
        Xp & 1 && n.tag !== 0 && uu(),
        (s = n.pendingLanes),
        s & 1 ? (n === M_ ? zc++ : ((zc = 0), (M_ = n))) : (zc = 0),
        Ho(),
        null
    );
}
function uu() {
    if (wo !== null) {
        var n = JT(Xp),
            e = Mr.transition,
            t = jt;
        try {
            if (((Mr.transition = null), (jt = 16 > n ? 16 : n), wo === null)) var i = !1;
            else {
                if (((n = wo), (wo = null), (Xp = 0), Ot & 6)) throw Error(Te(331));
                var r = Ot;
                for (Ot |= 4, qe = n.current; qe !== null; ) {
                    var s = qe,
                        o = s.child;
                    if (qe.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var c = 0; c < a.length; c++) {
                                var f = a[c];
                                for (qe = f; qe !== null; ) {
                                    var d = qe;
                                    switch (d.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Fc(8, d, s);
                                    }
                                    var h = d.child;
                                    if (h !== null) (h.return = d), (qe = h);
                                    else
                                        for (; qe !== null; ) {
                                            d = qe;
                                            var p = d.sibling,
                                                v = d.return;
                                            if ((u2(d), d === f)) {
                                                qe = null;
                                                break;
                                            }
                                            if (p !== null) {
                                                (p.return = v), (qe = p);
                                                break;
                                            }
                                            qe = v;
                                        }
                                }
                            }
                            var _ = s.alternate;
                            if (_ !== null) {
                                var w = _.child;
                                if (w !== null) {
                                    _.child = null;
                                    do {
                                        var x = w.sibling;
                                        (w.sibling = null), (w = x);
                                    } while (w !== null);
                                }
                            }
                            qe = s;
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (qe = o);
                    else
                        e: for (; qe !== null; ) {
                            if (((s = qe), s.flags & 2048))
                                switch (s.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Fc(9, s, s.return);
                                }
                            var g = s.sibling;
                            if (g !== null) {
                                (g.return = s.return), (qe = g);
                                break e;
                            }
                            qe = s.return;
                        }
                }
                var S = n.current;
                for (qe = S; qe !== null; ) {
                    o = qe;
                    var M = o.child;
                    if (o.subtreeFlags & 2064 && M !== null) (M.return = o), (qe = M);
                    else
                        e: for (o = S; qe !== null; ) {
                            if (((a = qe), a.flags & 2048))
                                try {
                                    switch (a.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            vm(9, a);
                                    }
                                } catch (P) {
                                    Sn(a, a.return, P);
                                }
                            if (a === o) {
                                qe = null;
                                break e;
                            }
                            var T = a.sibling;
                            if (T !== null) {
                                (T.return = a.return), (qe = T);
                                break e;
                            }
                            qe = a.return;
                        }
                }
                if (((Ot = r), Ho(), us && typeof us.onPostCommitFiberRoot == 'function'))
                    try {
                        us.onPostCommitFiberRoot(um, n);
                    } catch {}
                i = !0;
            }
            return i;
        } finally {
            (jt = t), (Mr.transition = e);
        }
    }
    return !1;
}
function XM(n, e, t) {
    (e = gu(t, e)),
        (e = QA(n, e, 1)),
        (n = bo(n, e, 1)),
        (e = Ti()),
        n !== null && (Uf(n, 1, e), zi(n, e));
}
function Sn(n, e, t) {
    if (n.tag === 3) XM(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                XM(e, n, t);
                break;
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (
                    typeof e.type.getDerivedStateFromError == 'function' ||
                    (typeof i.componentDidCatch == 'function' && (Ro === null || !Ro.has(i)))
                ) {
                    (n = gu(t, n)),
                        (n = $A(e, n, 1)),
                        (e = bo(e, n, 1)),
                        (n = Ti()),
                        e !== null && (Uf(e, 1, n), zi(e, n));
                    break;
                }
            }
            e = e.return;
        }
}
function EL(n, e, t) {
    var i = n.pingCache;
    i !== null && i.delete(e),
        (e = Ti()),
        (n.pingedLanes |= n.suspendedLanes & t),
        Kn === n &&
            (ti & t) === t &&
            (zn === 4 || (zn === 3 && (ti & 130023424) === ti && 500 > Rn() - ax)
                ? Pa(n, 0)
                : (ox |= t)),
        zi(n, e);
}
function y2(n, e) {
    e === 0 && (n.mode & 1 ? ((e = Zd), (Zd <<= 1), !(Zd & 130023424) && (Zd = 4194304)) : (e = 1));
    var t = Ti();
    (n = Hs(n, e)), n !== null && (Uf(n, e, t), zi(n, t));
}
function TL(n) {
    var e = n.memoizedState,
        t = 0;
    e !== null && (t = e.retryLane), y2(n, t);
}
function AL(n, e) {
    var t = 0;
    switch (n.tag) {
        case 13:
            var i = n.stateNode,
                r = n.memoizedState;
            r !== null && (t = r.retryLane);
            break;
        case 19:
            i = n.stateNode;
            break;
        default:
            throw Error(Te(314));
    }
    i !== null && i.delete(e), y2(n, t);
}
var x2;
x2 = function (n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || Fi.current) Oi = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128)) return (Oi = !1), hL(n, e, t);
            Oi = !!(n.flags & 131072);
        }
    else (Oi = !1), an && e.flags & 1048576 && wA(e, Fp, e.index);
    switch (((e.lanes = 0), e.tag)) {
        case 2:
            var i = e.type;
            hp(n, e), (n = e.pendingProps);
            var r = du(e, gi.current);
            lu(e, t), (r = ex(null, e, i, n, r, t));
            var s = tx();
            return (
                (e.flags |= 1),
                typeof r == 'object' &&
                r !== null &&
                typeof r.render == 'function' &&
                r.$$typeof === void 0
                    ? ((e.tag = 1),
                      (e.memoizedState = null),
                      (e.updateQueue = null),
                      ki(i) ? ((s = !0), Up(e)) : (s = !1),
                      (e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null),
                      Zy(e),
                      (r.updater = mm),
                      (e.stateNode = r),
                      (r._reactInternals = e),
                      c_(e, i, n, t),
                      (e = h_(null, e, i, !0, s, t)))
                    : ((e.tag = 0), an && s && Vy(e), Mi(null, e, r, t), (e = e.child)),
                e
            );
        case 16:
            i = e.elementType;
            e: {
                switch (
                    (hp(n, e),
                    (n = e.pendingProps),
                    (r = i._init),
                    (i = r(i._payload)),
                    (e.type = i),
                    (r = e.tag = bL(i)),
                    (n = Nr(i, n)),
                    r)
                ) {
                    case 0:
                        e = d_(null, e, i, n, t);
                        break e;
                    case 1:
                        e = OM(null, e, i, n, t);
                        break e;
                    case 11:
                        e = DM(null, e, i, n, t);
                        break e;
                    case 14:
                        e = UM(null, e, i, Nr(i.type, n), t);
                        break e;
                }
                throw Error(Te(306, i, ''));
            }
            return e;
        case 0:
            return (
                (i = e.type),
                (r = e.pendingProps),
                (r = e.elementType === i ? r : Nr(i, r)),
                d_(n, e, i, r, t)
            );
        case 1:
            return (
                (i = e.type),
                (r = e.pendingProps),
                (r = e.elementType === i ? r : Nr(i, r)),
                OM(n, e, i, r, t)
            );
        case 3:
            e: {
                if ((i2(e), n === null)) throw Error(Te(387));
                (i = e.pendingProps),
                    (s = e.memoizedState),
                    (r = s.element),
                    CA(n, e),
                    Bp(e, i, null, t);
                var o = e.memoizedState;
                if (((i = o.element), s.isDehydrated))
                    if (
                        ((s = {
                            element: i,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions,
                        }),
                        (e.updateQueue.baseState = s),
                        (e.memoizedState = s),
                        e.flags & 256)
                    ) {
                        (r = gu(Error(Te(423)), e)), (e = FM(n, e, i, t, r));
                        break e;
                    } else if (i !== r) {
                        (r = gu(Error(Te(424)), e)), (e = FM(n, e, i, t, r));
                        break e;
                    } else
                        for (
                            Qi = Co(e.stateNode.containerInfo.firstChild),
                                $i = e,
                                an = !0,
                                Fr = null,
                                t = LA(e, null, i, t),
                                e.child = t;
                            t;

                        )
                            (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
                else {
                    if ((hu(), i === r)) {
                        e = Vs(n, e, t);
                        break e;
                    }
                    Mi(n, e, i, t);
                }
                e = e.child;
            }
            return e;
        case 5:
            return (
                IA(e),
                n === null && a_(e),
                (i = e.type),
                (r = e.pendingProps),
                (s = n !== null ? n.memoizedProps : null),
                (o = r.children),
                n_(i, r) ? (o = null) : s !== null && n_(i, s) && (e.flags |= 32),
                n2(n, e),
                Mi(n, e, o, t),
                e.child
            );
        case 6:
            return n === null && a_(e), null;
        case 13:
            return r2(n, e, t);
        case 4:
            return (
                Ky(e, e.stateNode.containerInfo),
                (i = e.pendingProps),
                n === null ? (e.child = pu(e, null, i, t)) : Mi(n, e, i, t),
                e.child
            );
        case 11:
            return (
                (i = e.type),
                (r = e.pendingProps),
                (r = e.elementType === i ? r : Nr(i, r)),
                DM(n, e, i, r, t)
            );
        case 7:
            return Mi(n, e, e.pendingProps, t), e.child;
        case 8:
            return Mi(n, e, e.pendingProps.children, t), e.child;
        case 12:
            return Mi(n, e, e.pendingProps.children, t), e.child;
        case 10:
            e: {
                if (
                    ((i = e.type._context),
                    (r = e.pendingProps),
                    (s = e.memoizedProps),
                    (o = r.value),
                    Qt(kp, i._currentValue),
                    (i._currentValue = o),
                    s !== null)
                )
                    if (Hr(s.value, o)) {
                        if (s.children === r.children && !Fi.current) {
                            e = Vs(n, e, t);
                            break e;
                        }
                    } else
                        for (s = e.child, s !== null && (s.return = e); s !== null; ) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var c = a.firstContext; c !== null; ) {
                                    if (c.context === i) {
                                        if (s.tag === 1) {
                                            (c = Fs(-1, t & -t)), (c.tag = 2);
                                            var f = s.updateQueue;
                                            if (f !== null) {
                                                f = f.shared;
                                                var d = f.pending;
                                                d === null
                                                    ? (c.next = c)
                                                    : ((c.next = d.next), (d.next = c)),
                                                    (f.pending = c);
                                            }
                                        }
                                        (s.lanes |= t),
                                            (c = s.alternate),
                                            c !== null && (c.lanes |= t),
                                            l_(s.return, t, e),
                                            (a.lanes |= t);
                                        break;
                                    }
                                    c = c.next;
                                }
                            } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (((o = s.return), o === null)) throw Error(Te(341));
                                (o.lanes |= t),
                                    (a = o.alternate),
                                    a !== null && (a.lanes |= t),
                                    l_(o, t, e),
                                    (o = s.sibling);
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null; ) {
                                    if (o === e) {
                                        o = null;
                                        break;
                                    }
                                    if (((s = o.sibling), s !== null)) {
                                        (s.return = o.return), (o = s);
                                        break;
                                    }
                                    o = o.return;
                                }
                            s = o;
                        }
                Mi(n, e, r.children, t), (e = e.child);
            }
            return e;
        case 9:
            return (
                (r = e.type),
                (i = e.pendingProps.children),
                lu(e, t),
                (r = wr(r)),
                (i = i(r)),
                (e.flags |= 1),
                Mi(n, e, i, t),
                e.child
            );
        case 14:
            return (
                (i = e.type), (r = Nr(i, e.pendingProps)), (r = Nr(i.type, r)), UM(n, e, i, r, t)
            );
        case 15:
            return e2(n, e, e.type, e.pendingProps, t);
        case 17:
            return (
                (i = e.type),
                (r = e.pendingProps),
                (r = e.elementType === i ? r : Nr(i, r)),
                hp(n, e),
                (e.tag = 1),
                ki(i) ? ((n = !0), Up(e)) : (n = !1),
                lu(e, t),
                RA(e, i, r),
                c_(e, i, r, t),
                h_(null, e, i, !0, n, t)
            );
        case 19:
            return s2(n, e, t);
        case 22:
            return t2(n, e, t);
    }
    throw Error(Te(156, e.tag));
};
function S2(n, e) {
    return YT(n, e);
}
function CL(n, e, t, i) {
    (this.tag = n),
        (this.key = t),
        (this.sibling =
            this.child =
            this.return =
            this.stateNode =
            this.type =
            this.elementType =
                null),
        (this.index = 0),
        (this.ref = null),
        (this.pendingProps = e),
        (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
        (this.mode = i),
        (this.subtreeFlags = this.flags = 0),
        (this.deletions = null),
        (this.childLanes = this.lanes = 0),
        (this.alternate = null);
}
function Sr(n, e, t, i) {
    return new CL(n, e, t, i);
}
function fx(n) {
    return (n = n.prototype), !(!n || !n.isReactComponent);
}
function bL(n) {
    if (typeof n == 'function') return fx(n) ? 1 : 0;
    if (n != null) {
        if (((n = n.$$typeof), n === Py)) return 11;
        if (n === Ly) return 14;
    }
    return 2;
}
function Lo(n, e) {
    var t = n.alternate;
    return (
        t === null
            ? ((t = Sr(n.tag, e, n.key, n.mode)),
              (t.elementType = n.elementType),
              (t.type = n.type),
              (t.stateNode = n.stateNode),
              (t.alternate = n),
              (n.alternate = t))
            : ((t.pendingProps = e),
              (t.type = n.type),
              (t.flags = 0),
              (t.subtreeFlags = 0),
              (t.deletions = null)),
        (t.flags = n.flags & 14680064),
        (t.childLanes = n.childLanes),
        (t.lanes = n.lanes),
        (t.child = n.child),
        (t.memoizedProps = n.memoizedProps),
        (t.memoizedState = n.memoizedState),
        (t.updateQueue = n.updateQueue),
        (e = n.dependencies),
        (t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
        (t.sibling = n.sibling),
        (t.index = n.index),
        (t.ref = n.ref),
        t
    );
}
function gp(n, e, t, i, r, s) {
    var o = 2;
    if (((i = n), typeof n == 'function')) fx(n) && (o = 1);
    else if (typeof n == 'string') o = 5;
    else
        e: switch (n) {
            case zl:
                return La(t.children, r, s, e);
            case Ry:
                (o = 8), (r |= 8);
                break;
            case D0:
                return (n = Sr(12, t, e, r | 2)), (n.elementType = D0), (n.lanes = s), n;
            case U0:
                return (n = Sr(13, t, e, r)), (n.elementType = U0), (n.lanes = s), n;
            case O0:
                return (n = Sr(19, t, e, r)), (n.elementType = O0), (n.lanes = s), n;
            case PT:
                return ym(t, r, s, e);
            default:
                if (typeof n == 'object' && n !== null)
                    switch (n.$$typeof) {
                        case bT:
                            o = 10;
                            break e;
                        case RT:
                            o = 9;
                            break e;
                        case Py:
                            o = 11;
                            break e;
                        case Ly:
                            o = 14;
                            break e;
                        case go:
                            (o = 16), (i = null);
                            break e;
                    }
                throw Error(Te(130, n == null ? n : typeof n, ''));
        }
    return (e = Sr(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e;
}
function La(n, e, t, i) {
    return (n = Sr(7, n, i, e)), (n.lanes = t), n;
}
function ym(n, e, t, i) {
    return (
        (n = Sr(22, n, i, e)),
        (n.elementType = PT),
        (n.lanes = t),
        (n.stateNode = { isHidden: !1 }),
        n
    );
}
function Pv(n, e, t) {
    return (n = Sr(6, n, null, e)), (n.lanes = t), n;
}
function Lv(n, e, t) {
    return (
        (e = Sr(4, n.children !== null ? n.children : [], n.key, e)),
        (e.lanes = t),
        (e.stateNode = {
            containerInfo: n.containerInfo,
            pendingChildren: null,
            implementation: n.implementation,
        }),
        e
    );
}
function RL(n, e, t, i, r) {
    (this.tag = e),
        (this.containerInfo = n),
        (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
        (this.timeoutHandle = -1),
        (this.callbackNode = this.pendingContext = this.context = null),
        (this.callbackPriority = 0),
        (this.eventTimes = fv(0)),
        (this.expirationTimes = fv(-1)),
        (this.entangledLanes =
            this.finishedLanes =
            this.mutableReadLanes =
            this.expiredLanes =
            this.pingedLanes =
            this.suspendedLanes =
            this.pendingLanes =
                0),
        (this.entanglements = fv(0)),
        (this.identifierPrefix = i),
        (this.onRecoverableError = r),
        (this.mutableSourceEagerHydrationData = null);
}
function dx(n, e, t, i, r, s, o, a, c) {
    return (
        (n = new RL(n, e, t, a, c)),
        e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
        (s = Sr(3, null, null, e)),
        (n.current = s),
        (s.stateNode = n),
        (s.memoizedState = {
            element: i,
            isDehydrated: t,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null,
        }),
        Zy(s),
        n
    );
}
function PL(n, e, t) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: kl,
        key: i == null ? null : '' + i,
        children: n,
        containerInfo: e,
        implementation: t,
    };
}
function M2(n) {
    if (!n) return Oo;
    n = n._reactInternals;
    e: {
        if (Xa(n) !== n || n.tag !== 1) throw Error(Te(170));
        var e = n;
        do {
            switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break e;
                case 1:
                    if (ki(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e;
                    }
            }
            e = e.return;
        } while (e !== null);
        throw Error(Te(171));
    }
    if (n.tag === 1) {
        var t = n.type;
        if (ki(t)) return SA(n, t, e);
    }
    return e;
}
function w2(n, e, t, i, r, s, o, a, c) {
    return (
        (n = dx(t, i, !0, n, r, s, o, a, c)),
        (n.context = M2(null)),
        (t = n.current),
        (i = Ti()),
        (r = Po(t)),
        (s = Fs(i, r)),
        (s.callback = e ?? null),
        bo(t, s, r),
        (n.current.lanes = r),
        Uf(n, r, i),
        zi(n, i),
        n
    );
}
function xm(n, e, t, i) {
    var r = e.current,
        s = Ti(),
        o = Po(r);
    return (
        (t = M2(t)),
        e.context === null ? (e.context = t) : (e.pendingContext = t),
        (e = Fs(s, o)),
        (e.payload = { element: n }),
        (i = i === void 0 ? null : i),
        i !== null && (e.callback = i),
        (n = bo(r, e, o)),
        n !== null && (Br(n, r, o, s), cp(n, r, o)),
        o
    );
}
function qp(n) {
    if (((n = n.current), !n.child)) return null;
    switch (n.child.tag) {
        case 5:
            return n.child.stateNode;
        default:
            return n.child.stateNode;
    }
}
function YM(n, e) {
    if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e;
    }
}
function hx(n, e) {
    YM(n, e), (n = n.alternate) && YM(n, e);
}
function LL() {
    return null;
}
var E2 =
    typeof reportError == 'function'
        ? reportError
        : function (n) {
              console.error(n);
          };
function px(n) {
    this._internalRoot = n;
}
Sm.prototype.render = px.prototype.render = function (n) {
    var e = this._internalRoot;
    if (e === null) throw Error(Te(409));
    xm(n, e, null, null);
};
Sm.prototype.unmount = px.prototype.unmount = function () {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        Ha(function () {
            xm(null, n, null, null);
        }),
            (e[Bs] = null);
    }
};
function Sm(n) {
    this._internalRoot = n;
}
Sm.prototype.unstable_scheduleHydration = function (n) {
    if (n) {
        var e = eA();
        n = { blockedOn: null, target: n, priority: e };
        for (var t = 0; t < yo.length && e !== 0 && e < yo[t].priority; t++);
        yo.splice(t, 0, n), t === 0 && nA(n);
    }
};
function mx(n) {
    return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function Mm(n) {
    return !(
        !n ||
        (n.nodeType !== 1 &&
            n.nodeType !== 9 &&
            n.nodeType !== 11 &&
            (n.nodeType !== 8 || n.nodeValue !== ' react-mount-point-unstable '))
    );
}
function qM() {}
function IL(n, e, t, i, r) {
    if (r) {
        if (typeof i == 'function') {
            var s = i;
            i = function () {
                var f = qp(o);
                s.call(f);
            };
        }
        var o = w2(e, i, n, 0, null, !1, !1, '', qM);
        return (
            (n._reactRootContainer = o),
            (n[Bs] = o.current),
            ef(n.nodeType === 8 ? n.parentNode : n),
            Ha(),
            o
        );
    }
    for (; (r = n.lastChild); ) n.removeChild(r);
    if (typeof i == 'function') {
        var a = i;
        i = function () {
            var f = qp(c);
            a.call(f);
        };
    }
    var c = dx(n, 0, !1, null, null, !1, !1, '', qM);
    return (
        (n._reactRootContainer = c),
        (n[Bs] = c.current),
        ef(n.nodeType === 8 ? n.parentNode : n),
        Ha(function () {
            xm(e, c, t, i);
        }),
        c
    );
}
function wm(n, e, t, i, r) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == 'function') {
            var a = r;
            r = function () {
                var c = qp(o);
                a.call(c);
            };
        }
        xm(e, o, n, r);
    } else o = IL(t, e, n, r, i);
    return qp(o);
}
QT = function (n) {
    switch (n.tag) {
        case 3:
            var e = n.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var t = bc(e.pendingLanes);
                t !== 0 && (Dy(e, t | 1), zi(e, Rn()), !(Ot & 6) && ((vu = Rn() + 500), Ho()));
            }
            break;
        case 13:
            Ha(function () {
                var i = Hs(n, 1);
                if (i !== null) {
                    var r = Ti();
                    Br(i, n, 1, r);
                }
            }),
                hx(n, 1);
    }
};
Uy = function (n) {
    if (n.tag === 13) {
        var e = Hs(n, 134217728);
        if (e !== null) {
            var t = Ti();
            Br(e, n, 134217728, t);
        }
        hx(n, 134217728);
    }
};
$T = function (n) {
    if (n.tag === 13) {
        var e = Po(n),
            t = Hs(n, e);
        if (t !== null) {
            var i = Ti();
            Br(t, n, e, i);
        }
        hx(n, e);
    }
};
eA = function () {
    return jt;
};
tA = function (n, e) {
    var t = jt;
    try {
        return (jt = n), e();
    } finally {
        jt = t;
    }
};
X0 = function (n, e, t) {
    switch (e) {
        case 'input':
            if ((z0(n, t), (e = t.name), t.type === 'radio' && e != null)) {
                for (t = n; t.parentNode; ) t = t.parentNode;
                for (
                    t = t.querySelectorAll(
                        'input[name=' + JSON.stringify('' + e) + '][type="radio"]'
                    ),
                        e = 0;
                    e < t.length;
                    e++
                ) {
                    var i = t[e];
                    if (i !== n && i.form === n.form) {
                        var r = hm(i);
                        if (!r) throw Error(Te(90));
                        IT(i), z0(i, r);
                    }
                }
            }
            break;
        case 'textarea':
            DT(n, t);
            break;
        case 'select':
            (e = t.value), e != null && ru(n, !!t.multiple, e, !1);
    }
};
HT = lx;
VT = Ha;
var NL = { usingClientEntryPoint: !1, Events: [Ff, Gl, hm, zT, BT, lx] },
    sc = {
        findFiberByHostInstance: Sa,
        bundleType: 0,
        version: '18.2.0',
        rendererPackageName: 'react-dom',
    },
    DL = {
        bundleType: sc.bundleType,
        version: sc.version,
        rendererPackageName: sc.rendererPackageName,
        rendererConfig: sc.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Xs.ReactCurrentDispatcher,
        findHostInstanceByFiber: function (n) {
            return (n = jT(n)), n === null ? null : n.stateNode;
        },
        findFiberByHostInstance: sc.findFiberByHostInstance || LL,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: '18.2.0-next-9e3b772b8-20220608',
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
    var oh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!oh.isDisabled && oh.supportsFiber)
        try {
            (um = oh.inject(DL)), (us = oh);
        } catch {}
}
ir.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = NL;
ir.createPortal = function (n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!mx(e)) throw Error(Te(200));
    return PL(n, e, null, t);
};
ir.createRoot = function (n, e) {
    if (!mx(n)) throw Error(Te(299));
    var t = !1,
        i = '',
        r = E2;
    return (
        e != null &&
            (e.unstable_strictMode === !0 && (t = !0),
            e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
            e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
        (e = dx(n, 1, !1, null, null, t, !1, i, r)),
        (n[Bs] = e.current),
        ef(n.nodeType === 8 ? n.parentNode : n),
        new px(e)
    );
};
ir.findDOMNode = function (n) {
    if (n == null) return null;
    if (n.nodeType === 1) return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == 'function'
            ? Error(Te(188))
            : ((n = Object.keys(n).join(',')), Error(Te(268, n)));
    return (n = jT(e)), (n = n === null ? null : n.stateNode), n;
};
ir.flushSync = function (n) {
    return Ha(n);
};
ir.hydrate = function (n, e, t) {
    if (!Mm(e)) throw Error(Te(200));
    return wm(null, n, e, !0, t);
};
ir.hydrateRoot = function (n, e, t) {
    if (!mx(n)) throw Error(Te(405));
    var i = (t != null && t.hydratedSources) || null,
        r = !1,
        s = '',
        o = E2;
    if (
        (t != null &&
            (t.unstable_strictMode === !0 && (r = !0),
            t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
            t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
        (e = w2(e, null, n, 1, t ?? null, r, !1, s, o)),
        (n[Bs] = e.current),
        ef(n),
        i)
    )
        for (n = 0; n < i.length; n++)
            (t = i[n]),
                (r = t._getVersion),
                (r = r(t._source)),
                e.mutableSourceEagerHydrationData == null
                    ? (e.mutableSourceEagerHydrationData = [t, r])
                    : e.mutableSourceEagerHydrationData.push(t, r);
    return new Sm(e);
};
ir.render = function (n, e, t) {
    if (!Mm(e)) throw Error(Te(200));
    return wm(null, n, e, !1, t);
};
ir.unmountComponentAtNode = function (n) {
    if (!Mm(n)) throw Error(Te(40));
    return n._reactRootContainer
        ? (Ha(function () {
              wm(null, null, n, !1, function () {
                  (n._reactRootContainer = null), (n[Bs] = null);
              });
          }),
          !0)
        : !1;
};
ir.unstable_batchedUpdates = lx;
ir.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
    if (!Mm(t)) throw Error(Te(200));
    if (n == null || n._reactInternals === void 0) throw Error(Te(38));
    return wm(n, e, t, !1, i);
};
ir.version = '18.2.0-next-9e3b772b8-20220608';
function T2() {
    if (
        !(
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
        )
    )
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(T2);
        } catch (n) {
            console.error(n);
        }
}
T2(), (wT.exports = ir);
var gx = wT.exports;
const UL = Nf(gx),
    OL = dT({ __proto__: null, default: UL }, [gx]);
var ZM = gx;
(I0.createRoot = ZM.createRoot), (I0.hydrateRoot = ZM.hydrateRoot);
const FL = '_App_qhskm_1',
    kL = '_logo_qhskm_9',
    zL = '_react_qhskm_19',
    BL = '_ts_qhskm_23',
    HL = '_scss_qhskm_27',
    VL = '_card_qhskm_44',
    GL = '_footer11_qhskm_57',
    Iv = {
        App: FL,
        logo: kL,
        react: zL,
        ts: BL,
        scss: HL,
        'logo-spin': '_logo-spin_qhskm_1',
        card: VL,
        'read-the-docs': '_read-the-docs_qhskm_48',
        'fav-slider': '_fav-slider_qhskm_52',
        footer11: GL,
    };
var A2 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (n) {
    (function () {
        var e = {}.hasOwnProperty;
        function t() {
            for (var s = '', o = 0; o < arguments.length; o++) {
                var a = arguments[o];
                a && (s = r(s, i(a)));
            }
            return s;
        }
        function i(s) {
            if (typeof s == 'string' || typeof s == 'number') return s;
            if (typeof s != 'object') return '';
            if (Array.isArray(s)) return t.apply(null, s);
            if (
                s.toString !== Object.prototype.toString &&
                !s.toString.toString().includes('[native code]')
            )
                return s.toString();
            var o = '';
            for (var a in s) e.call(s, a) && s[a] && (o = r(o, a));
            return o;
        }
        function r(s, o) {
            return o ? (s ? s + ' ' + o : s + o) : s;
        }
        n.exports ? ((t.default = t), (n.exports = t)) : (window.classNames = t);
    })();
})(A2);
var WL = A2.exports;
const Tr = Nf(WL),
    jL = '_root_1k5fp_1',
    XL = '_navbar_1k5fp_12',
    YL = '_logo_1k5fp_19',
    qL = '_navmenu_1k5fp_27',
    ZL = '_navicon_1k5fp_43',
    KL = '_navmenu1_1k5fp_52',
    JL = '_navmenu2_1k5fp_68',
    so = {
        root: jL,
        navbar: XL,
        logo: YL,
        navmenu: qL,
        navicon: ZL,
        navmenu1: KL,
        navmenu2: JL,
        'menu-mod-icon': '_menu-mod-icon_1k5fp_84',
    };
var C2 = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 },
    KM = Os.createContext && Os.createContext(C2),
    QL = ['attr', 'size', 'title'];
function $L(n, e) {
    if (n == null) return {};
    var t = eI(n, e),
        i,
        r;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(n);
        for (r = 0; r < s.length; r++)
            (i = s[r]),
                !(e.indexOf(i) >= 0) &&
                    Object.prototype.propertyIsEnumerable.call(n, i) &&
                    (t[i] = n[i]);
    }
    return t;
}
function eI(n, e) {
    if (n == null) return {};
    var t = {},
        i = Object.keys(n),
        r,
        s;
    for (s = 0; s < i.length; s++) (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t;
}
function Zp() {
    return (
        (Zp = Object.assign
            ? Object.assign.bind()
            : function (n) {
                  for (var e = 1; e < arguments.length; e++) {
                      var t = arguments[e];
                      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
                  }
                  return n;
              }),
        Zp.apply(this, arguments)
    );
}
function JM(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e &&
            (i = i.filter(function (r) {
                return Object.getOwnPropertyDescriptor(n, r).enumerable;
            })),
            t.push.apply(t, i);
    }
    return t;
}
function Kp(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2
            ? JM(Object(t), !0).forEach(function (i) {
                  tI(n, i, t[i]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
            : JM(Object(t)).forEach(function (i) {
                  Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
              });
    }
    return n;
}
function tI(n, e, t) {
    return (
        (e = nI(e)),
        e in n
            ? Object.defineProperty(n, e, {
                  value: t,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
              })
            : (n[e] = t),
        n
    );
}
function nI(n) {
    var e = iI(n, 'string');
    return typeof e == 'symbol' ? e : String(e);
}
function iI(n, e) {
    if (typeof n != 'object' || n === null) return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var i = t.call(n, e || 'default');
        if (typeof i != 'object') return i;
        throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return (e === 'string' ? String : Number)(n);
}
function b2(n) {
    return n && n.map((e, t) => Os.createElement(e.tag, Kp({ key: t }, e.attr), b2(e.child)));
}
function Wr(n) {
    return (e) => Os.createElement(rI, Zp({ attr: Kp({}, n.attr) }, e), b2(n.child));
}
function rI(n) {
    var e = (t) => {
        var { attr: i, size: r, title: s } = n,
            o = $L(n, QL),
            a = r || t.size || '1em',
            c;
        return (
            t.className && (c = t.className),
            n.className && (c = (c ? c + ' ' : '') + n.className),
            Os.createElement(
                'svg',
                Zp(
                    { stroke: 'currentColor', fill: 'currentColor', strokeWidth: '0' },
                    t.attr,
                    i,
                    o,
                    {
                        className: c,
                        style: Kp(Kp({ color: n.color || t.color }, t.style), n.style),
                        height: a,
                        width: a,
                        xmlns: 'http://www.w3.org/2000/svg',
                    }
                ),
                s && Os.createElement('title', null, s),
                n.children
            )
        );
    };
    return KM !== void 0 ? Os.createElement(KM.Consumer, null, (t) => e(t)) : e(C2);
}
function sI(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    fill: 'none',
                    strokeLinecap: 'round',
                    strokeMiterlimit: '10',
                    strokeWidth: '32',
                    d: 'M80 160h352M80 256h352M80 352h352',
                },
                child: [],
            },
        ],
    })(n);
}
const Em = ({ className: n }) =>
        X.jsx('div', {
            className: Tr(so.root, n),
            children: X.jsxs('nav', {
                className: so.navbar,
                children: [
                    X.jsx('img', {
                        src: 'src/Capture-removebg-preview 2.png',
                        alt: '',
                        className: so.logo,
                    }),
                    X.jsx(sI, { className: so['menu-mod-icon'] }),
                    X.jsx('a', {
                        href: '/',
                        children: X.jsx('p', { className: so.navmenu, children: 'Home' }),
                    }),
                    X.jsx('a', {
                        href: '/configurator',
                        children: X.jsx('p', { className: so.navmenu1, children: 'Aanpassen' }),
                    }),
                    X.jsx('a', {
                        href: '/shop',
                        children: X.jsx('p', { className: so.navmenu2, children: 'Producten' }),
                    }),
                    X.jsxs('a', {
                        href: '/checkout',
                        children: [
                            ' ',
                            X.jsx('img', {
                                src: 'src/Image6.svg',
                                alt: '',
                                className: so.navicon,
                            }),
                        ],
                    }),
                ],
            }),
        }),
    oI = '_root_zabac_1',
    aI = '_header_zabac_14',
    Ss = {
        root: oI,
        header: aI,
        'header-big': '_header-big_zabac_41',
        'header-big1': '_header-big1_zabac_71',
        'header-btn1': '_header-btn1_zabac_103',
        'header-btn2': '_header-btn2_zabac_135',
        'feature-prod': '_feature-prod_zabac_167',
        'featured-text': '_featured-text_zabac_189',
    },
    lI = [
        {
            id: 1,
            name: 'Kast',
            image: 'src/product image/Kast.png',
            featured: !0,
            favorite: !0,
            discount: ' ',
        },
        {
            id: 2,
            name: 'Badkamermeubel',
            image: 'src/product image/Badkamermeubel.png',
            featured: !0,
            favorite: !0,
            discount: '-35%OFF',
        },
        {
            id: 3,
            name: 'Garderobe',
            image: 'src/product image/Garderobe.png',
            featured: !0,
            favorite: !0,
            discount: '-20%OFF',
        },
        {
            id: 4,
            name: 'TV-meubel',
            image: 'src/product image/Tvmeubel.svg',
            favorite: !0,
            discount: ' ',
        },
        {
            id: 5,
            name: 'Wasruimtekast',
            image: 'src/product image/whiteKast.svg',
            favorite: !0,
            discount: ' ',
        },
    ],
    vx = { products: lI },
    uI = '_root_1gsx2_1',
    ah = {
        root: uI,
        'card-div': '_card-div_1gsx2_7',
        'prod-img': '_prod-img_1gsx2_26',
        'product-title': '_product-title_1gsx2_31',
    },
    cI = ({ className: n, imageUrl: e, title: t }) =>
        X.jsx('div', {
            className: Tr(ah.root, n),
            children: X.jsxs('div', {
                className: ah['card-div'],
                children: [
                    X.jsx('img', { src: e, alt: '', className: ah['prod-img'] }),
                    X.jsx('p', { className: ah['product-title'], children: t }),
                ],
            }),
        }),
    lh = vx.products.filter((n) => n.featured === !0),
    fI = ({ className: n }) =>
        X.jsxs('div', {
            className: Tr(Ss.root, n),
            children: [
                X.jsxs('header', {
                    className: Ss.header,
                    children: [
                        X.jsx('div', {
                            className: Ss['header-big'],
                            children: ' Je eigen meubels oet Twente',
                        }),
                        X.jsx('p', {
                            className: Ss['header-big1'],
                            children:
                                'Ontwerp je eigen meubel op jou wensen en laat dit in onze werkplaats maken.',
                        }),
                        X.jsx('button', { className: Ss['header-btn1'], children: 'Winkel nu' }),
                        X.jsx('button', {
                            className: Ss['header-btn2'],
                            children: 'Personaliseren',
                        }),
                    ],
                }),
                X.jsxs('div', {
                    className: Ss['feature-prod'],
                    children: [
                        X.jsx('p', { className: Ss['featured-text'], children: 'Uitgelicht' }),
                        (lh == null ? void 0 : lh.length) > 0 &&
                            lh.map((e) =>
                                X.jsx(
                                    cI,
                                    {
                                        className: Ss['featured-card'],
                                        imageUrl: e.image,
                                        title: e.name,
                                    },
                                    e.id
                                )
                            ),
                    ],
                }),
            ],
        }),
    dI = '_root_1faik_1',
    dl = {
        root: dI,
        'fav-prod': '_fav-prod_1faik_15',
        'fav-prod1': '_fav-prod1_1faik_31',
        'left-arrow': '_left-arrow_1faik_36',
        'favorite-heading': '_favorite-heading_1faik_49',
        'fav-sub': '_fav-sub_1faik_82',
        'favorite-card': '_favorite-card_1faik_112',
    },
    hI = '_root_1b5j3_1',
    pI = '_favoritecard_1b5j3_8',
    mI = '_discount_1b5j3_45',
    oc = {
        root: hI,
        favoritecard: pI,
        'card-img': '_card-img_1b5j3_20',
        'card-title': '_card-title_1b5j3_30',
        discount: mI,
    },
    gI = ({ className: n, imageUrl: e, title: t, discount: i }) =>
        X.jsx('div', {
            className: Tr(oc.root, n),
            children: X.jsxs('div', {
                className: oc.favoritecard,
                children: [
                    X.jsx('p', { className: oc.discount, children: i }),
                    X.jsx('img', { src: e, alt: '', className: oc['card-img'] }),
                    X.jsx('p', { className: oc['card-title'], children: t }),
                ],
            }),
        }),
    ac = vx.products.filter((n) => n.favorite === !0),
    vI = ({ className: n }) => {
        const [e, t] = pe.useState(0),
            i = () => {
                t((s) => Math.max(s - 1, 0));
            },
            r = () => {
                t((s) => Math.min(s + 1, ac.length - 4));
            };
        return X.jsxs('div', {
            className: Tr(dl.root, n),
            children: [
                X.jsx('p', { className: dl['favorite-heading'], children: 'Onze favorieten' }),
                X.jsx('p', {
                    className: dl['fav-sub'],
                    children: 'Onze wekelijkse keuzes vind je hier.',
                }),
                X.jsxs('div', {
                    className: dl['fav-prod'],
                    children: [
                        X.jsx('img', {
                            src: 'src/product image/arrowleft.svg',
                            onClick: i,
                        }),
                        X.jsx('div', {
                            className: dl['favorite-card'],
                            children:
                                (ac == null ? void 0 : ac.length) > 0 &&
                                ac
                                    .slice(e, e + 4)
                                    .map((s) =>
                                        X.jsx(
                                            gI,
                                            {
                                                imageUrl: s.image,
                                                title: s.name,
                                                discount: s.discount,
                                            },
                                            s.id
                                        )
                                    ),
                        }),
                        X.jsx('img', {
                            src: 'src/product image/arrowleft.svg',
                            className: dl['left-arrow'],
                            onClick: r,
                        }),
                    ],
                }),
            ],
        });
    },
    _I = '_root_1u9sv_1',
    yI = '_line_1u9sv_28',
    xI = '_kast_1u9sv_37',
    SI = '_imgabout1_1u9sv_50',
    MI = '_imgabout2_1u9sv_68',
    wI = '_ad_1u9sv_86',
    EI = '_newsletterDiv_1u9sv_104',
    TI = '_newslettersubsubdiv_1u9sv_141',
    AI = '_about_title_1u9sv_154',
    CI = '_verdenzing_1u9sv_447',
    Vt = {
        root: _I,
        'about-block': '_about-block_1u9sv_14',
        line: yI,
        kast: xI,
        imgabout1: SI,
        imgabout2: MI,
        ad: wI,
        newsletterDiv: EI,
        'newsletter-subdiv': '_newsletter-subdiv_1u9sv_123',
        newslettersubsubdiv: TI,
        about_title: AI,
        'about-us': '_about-us_1u9sv_175',
        'about-us-btn': '_about-us-btn_1u9sv_198',
        'kast-img': '_kast-img_1u9sv_212',
        'kast-heading': '_kast-heading_1u9sv_229',
        'kast-desc': '_kast-desc_1u9sv_248',
        'kast-btn': '_kast-btn_1u9sv_271',
        'ad-head': '_ad-head_1u9sv_303',
        'ad-sub': '_ad-sub_1u9sv_326',
        'ad-img': '_ad-img_1u9sv_347',
        'delivery-img': '_delivery-img_1u9sv_364',
        'delivery-head-txt': '_delivery-head-txt_1u9sv_383',
        'delivery-sub-sub-txt': '_delivery-sub-sub-txt_1u9sv_406',
        'fast-del': '_fast-del_1u9sv_432',
        verdenzing: CI,
        'sub-fast-del': '_sub-fast-del_1u9sv_468',
        'newsletter-subscribe': '_newsletter-subscribe_1u9sv_491',
        'input-email': '_input-email_1u9sv_514',
        'field-div-newsletter': '_field-div-newsletter_1u9sv_526',
        'newsletter-input': '_newsletter-input_1u9sv_548',
    },
    bI = ({ className: n }) =>
        X.jsxs('div', {
            className: Tr(Vt.root, n),
            children: [
                X.jsxs('div', {
                    className: Vt['about-block'],
                    children: [
                        X.jsx('p', { className: Vt.about_title, children: 'Over ons' }),
                        X.jsx('p', {
                            className: Vt['about-us'],
                            children:
                                'wij zijn de interieurbouwers van VI Interieurs.Wij ontwerpen, ontzorgen en realiseren op basis van wederzijdsvertrouwen complete interieurs. Van meubels, keukens, kastenwand tot complete winkelinrichting.',
                        }),
                        X.jsx('p', { className: Vt['about-us-btn'], children: 'Lees meer' }),
                        X.jsx('div', { className: Vt.line }),
                        X.jsx('img', {
                            src: 'src/product image/Image 129about2.png',
                            className: Vt.imgabout1,
                        }),
                        X.jsx('img', {
                            src: 'src/product image/Image 130about1.png',
                            className: Vt.imgabout2,
                        }),
                    ],
                }),
                X.jsxs('div', {
                    className: Vt.kast,
                    children: [
                        X.jsx('img', {
                            src: 'src/product image/Image 152Kast.png',
                            className: Vt['kast-img'],
                        }),
                        X.jsx('p', { className: Vt['kast-heading'], children: 'Kast' }),
                        X.jsx('p', {
                            className: Vt['kast-desc'],
                            children:
                                'Praktische kledingkast voor al uw opbergbehoeften. Stijlvol ontwerp met voldoende ruimte voor kleding en accessoires. Een must-have voor een georganiseerde en opgeruimde slaapkamer.',
                        }),
                        X.jsx('button', { className: Vt['kast-btn'], children: 'customize' }),
                    ],
                }),
                X.jsxs('div', {
                    className: Vt.ad,
                    children: [
                        X.jsx('p', {
                            className: Vt['ad-head'],
                            children: 'EINDE VAN HET SEIZOEN UITVERKOOP',
                        }),
                        X.jsx('p', { className: Vt['ad-sub'], children: '35% KORTING' }),
                        X.jsx('img', {
                            src: 'src/product image/Image 96ad.png',
                            className: Vt['ad-img'],
                        }),
                    ],
                }),
                X.jsx('div', {
                    className: Vt.newsletterDiv,
                    children: X.jsx('div', {
                        className: Vt['newsletter-subdiv'],
                        children: X.jsxs('div', {
                            className: Vt.newslettersubsubdiv,
                            children: [
                                X.jsx('img', {
                                    src: 'src/product image/Image 85deliverynewsletter.png',
                                    className: Vt['delivery-img'],
                                }),
                                X.jsx('p', {
                                    className: Vt['delivery-head-txt'],
                                    children: 'Snelle levering',
                                }),
                                X.jsx('p', {
                                    className: Vt['delivery-sub-sub-txt'],
                                    children: 'Levering binnen minder dan 20 dagen',
                                }),
                                X.jsx('img', {
                                    src: 'src/product image/Image 87newsletter.png',
                                    className: Vt['fast-del'],
                                }),
                                X.jsx('p', { className: Vt.verdenzing, children: 'Verzending' }),
                                X.jsx('p', {
                                    className: Vt['sub-fast-del'],
                                    children: 'Overal in Nederland',
                                }),
                                X.jsx('p', {
                                    className: Vt['newsletter-subscribe'],
                                    children: 'Inschrijven voor de nieuwsbrief',
                                }),
                                X.jsx('div', {
                                    className: Vt['field-div-newsletter'],
                                    children: X.jsxs('p', {
                                        className: Vt['input-email'],
                                        children: [
                                            'Uw e-mail',
                                            X.jsx('input', { className: Vt['newsletter-input'] }),
                                        ],
                                    }),
                                }),
                            ],
                        }),
                    }),
                }),
            ],
        }),
    RI = '_root_3bh1a_1',
    PI = '_subject_3bh1a_83',
    LI = '_Mailons_3bh1a_303',
    Nn = {
        root: RI,
        'contact-img': '_contact-img_3bh1a_17',
        'contact-div': '_contact-div_3bh1a_30',
        'contact-form': '_contact-form_3bh1a_51',
        'name-input': '_name-input_3bh1a_67',
        'email-input': '_email-input_3bh1a_75',
        subject: PI,
        'message-input': '_message-input_3bh1a_100',
        'div-name-input': '_div-name-input_3bh1a_118',
        'div-email-input': '_div-email-input_3bh1a_137',
        'submit-btn': '_submit-btn_3bh1a_203',
        'submit-btn-txt': '_submit-btn-txt_3bh1a_229',
        'contact-form-title': '_contact-form-title_3bh1a_241',
        'belons-txt': '_belons-txt_3bh1a_262',
        'belons-subtxt': '_belons-subtxt_3bh1a_276',
        'belons-number': '_belons-number_3bh1a_291',
        Mailons: LI,
        'mail-address': '_mail-address_3bh1a_316',
        'waar-alles': '_waar-alles_3bh1a_330',
        'sub-waar-alles': '_sub-waar-alles_3bh1a_344',
    },
    II = ({ className: n }) =>
        X.jsxs('div', {
            className: Tr(Nn.root, n),
            children: [
                X.jsx('img', { src: 'src/Rectangle 3.png', className: Nn['contact-img'] }),
                X.jsxs('div', {
                    className: Nn['contact-div'],
                    children: [
                        X.jsx('p', {
                            className: Nn['contact-form-title'],
                            children: 'Neem contact met ons op',
                        }),
                        X.jsx('p', { className: Nn['belons-txt'], children: 'Bel ons' }),
                        X.jsx('p', {
                            className: Nn['belons-subtxt'],
                            children:
                                'We zijn van Ma tm Vr van 8:00 tot 18:00 ook telefonisch bereikbaar',
                        }),
                        X.jsx('p', { className: Nn['belons-number'], children: '+31 6 14118713' }),
                        X.jsx('p', { className: Nn.Mailons, children: 'Mail ons ' }),
                        X.jsx('p', {
                            className: Nn['mail-address'],
                            children: 'Info@meubelsoettwente.nl',
                        }),
                        X.jsx('p', {
                            className: Nn['waar-alles'],
                            children: ' Waar alles gebeurt',
                        }),
                        X.jsx('p', {
                            className: Nn['sub-waar-alles'],
                            children: 'VI InterieursHandelsweg 137461 JJ Rijssen',
                        }),
                        X.jsxs('div', {
                            className: Nn['contact-form'],
                            children: [
                                X.jsx('div', {
                                    className: Nn['div-name-input'],
                                    children: X.jsx('input', {
                                        className: Nn['name-input'],
                                        placeholder: 'Name:*',
                                    }),
                                }),
                                X.jsx('div', {
                                    className: Nn['div-email-input'],
                                    children: X.jsx('input', {
                                        className: Nn['email-input'],
                                        placeholder: 'Email',
                                    }),
                                }),
                                X.jsx('input', { className: Nn.subject, placeholder: 'Subject' }),
                                X.jsx('textarea', {
                                    className: Nn['message-input'],
                                    placeholder: 'Message',
                                }),
                                X.jsx('button', {
                                    className: Nn['submit-btn'],
                                    children: X.jsx('p', {
                                        className: Nn['submit-btn-txt'],
                                        children: 'SEND MESSAGE',
                                    }),
                                }),
                            ],
                        }),
                    ],
                }),
            ],
        }),
    NI = '_root_1wxdt_1',
    yi = {
        root: NI,
        'footer-txtunderlogo': '_footer-txtunderlogo_1wxdt_15',
        'div-fr2': '_div-fr2_1wxdt_29',
        'div-fr3': '_div-fr3_1wxdt_44',
        'div-fr4': '_div-fr4_1wxdt_59',
        'footer-logo': '_footer-logo_1wxdt_74',
        'studio-footer': '_studio-footer_1wxdt_82',
        'foote-fr2-subtext': '_foote-fr2-subtext_1wxdt_91',
        'footer-fr3-heading': '_footer-fr3-heading_1wxdt_101',
        'footer-fr3-subtext': '_footer-fr3-subtext_1wxdt_110',
        'footer-fr4-heading': '_footer-fr4-heading_1wxdt_121',
        'footer-firstimg': '_footer-firstimg_1wxdt_130',
        'text-payment': '_text-payment_1wxdt_139',
        'footer-secondimg': '_footer-secondimg_1wxdt_152',
        'copyright-1': '_copyright-1_1wxdt_161',
    },
    R2 = ({ className: n }) =>
        X.jsxs('div', {
            className: Tr(yi.root, n),
            children: [
                X.jsx('img', {
                    src: 'src/Capture-removebg-preview 2.png',
                    className: yi['footer-logo'],
                }),
                X.jsx('p', {
                    className: yi['footer-txtunderlogo'],
                    children: 'Je eigen meubels oet TwenteIn samenwerking met VI interieurs',
                }),
                X.jsxs('div', {
                    className: yi['div-fr2'],
                    children: [
                        X.jsx('p', { className: yi['studio-footer'], children: 'Studio' }),
                        X.jsx('p', {
                            className: yi['foote-fr2-subtext'],
                            children: 'Bezoek onze winkel',
                        }),
                    ],
                }),
                X.jsxs('div', {
                    className: yi['div-fr3'],
                    children: [
                        X.jsx('p', { className: yi['footer-fr3-heading'], children: 'Shopping' }),
                        X.jsx('p', {
                            className: yi['footer-fr3-subtext'],
                            children: 'Selecteer een van onze vele producten om aan te passen.',
                        }),
                    ],
                }),
                X.jsxs('div', {
                    className: yi['div-fr4'],
                    children: [
                        X.jsx('p', {
                            className: yi['footer-fr4-heading'],
                            children: 'Payment Methods',
                        }),
                        X.jsx('img', {
                            src: 'src/Image 120.svg',
                            className: yi['footer-firstimg'],
                        }),
                        X.jsx('img', {
                            src: 'src/Image122.png',
                            className: yi['footer-secondimg'],
                        }),
                        X.jsx('p', { className: yi['text-payment'], children: 'VISA' }),
                    ],
                }),
                X.jsx('p', {
                    className: yi['copyright-1'],
                    children: '2024@ VI Interieur AllRights Reserved',
                }),
            ],
        });
function DI() {
    return X.jsxs('div', {
        className: Iv.App,
        children: [
            X.jsx(Em, {}),
            X.jsx(fI, {}),
            X.jsx(vI, { className: Iv['fav-slider'] }),
            X.jsx(bI, {}),
            X.jsx(II, {}),
            X.jsx(R2, { className: Iv.footer11 }),
        ],
    });
}
const UI = '_root_svboe_1',
    Nv = { root: UI, 'shop-div': '_shop-div_svboe_5', 'nav-shop': '_nav-shop_svboe_13' },
    OI = '_root_awg6d_1',
    FI = '_container_awg6d_7',
    uh = {
        root: OI,
        container: FI,
        'card-img': '_card-img_awg6d_23',
        'card-title': '_card-title_awg6d_30',
    },
    kI = ({ className: n, imageUrl: e, title: t }) =>
        X.jsxs('div', {
            className: Tr(uh.root, n),
            children: [
                X.jsx('div', {
                    className: uh.container,
                    children: X.jsx('img', { src: e, alt: '', className: uh['card-img'] }),
                }),
                X.jsx('p', { className: uh['card-title'], children: t }),
            ],
        }),
    ch = vx.products,
    zI = ({ className: n }) =>
        X.jsxs('div', {
            className: Tr(Nv.root, n),
            children: [
                X.jsx(Em, { className: Nv['nav-shop'] }),
                X.jsx('p', {
                    style: {
                        color: 'black',
                        fontSize: 48,
                        fontFamily: 'Inria Serif',
                        fontWeight: '700',
                        wordWrap: 'break-word',
                        width: '700',
                        marginLeft: 39,
                        marginTop: 30,
                    },
                    children: 'Choose any of the product to customise',
                }),
                X.jsx('div', {
                    className: Nv['shop-div'],
                    children:
                        (ch == null ? void 0 : ch.length) > 0 &&
                        ch.map((e) => X.jsx(kI, { imageUrl: e.image, title: e.name }, e.id)),
                }),
            ],
        }),
    BI = '_root_1cfff_1',
    HI = '_listingdiv_1cfff_17',
    VI = '_listing1_1cfff_43',
    GI = '_postcode_1cfff_138',
    Bt = {
        root: BI,
        'checkout-div': '_checkout-div_1cfff_5',
        'form-div': '_form-div_1cfff_11',
        listingdiv: HI,
        'container-checkout': '_container-checkout_1cfff_29',
        listing1: VI,
        'heading-checkout': '_heading-checkout_1cfff_51',
        'button-listing': '_button-listing_1cfff_63',
        'left-heading': '_left-heading_1cfff_82',
        'first-name': '_first-name_1cfff_91',
        'second-name': '_second-name_1cfff_102',
        'street-address': '_street-address_1cfff_112',
        'city-label': '_city-label_1cfff_125',
        postcode: GI,
        'button-checkout': '_button-checkout_1cfff_152',
        'first-name-input': '_first-name-input_1cfff_178',
        'last-name-input': '_last-name-input_1cfff_187',
        'street-input': '_street-input_1cfff_196',
        'city-input': '_city-input_1cfff_206',
        'postcode-input': '_postcode-input_1cfff_217',
        'text--1': '_text--1_1cfff_228',
        'text--2': '_text--2_1cfff_243',
        'text--3': '_text--3_1cfff_258',
        'text--4': '_text--4_1cfff_273',
        'close-icon-circle': '_close-icon-circle_1cfff_288',
        'icon-circle2': '_icon-circle2_1cfff_296',
        'circle-icon3': '_circle-icon3_1cfff_304',
        'class-circle-4': '_class-circle-4_1cfff_312',
        'footer-checkout': '_footer-checkout_1cfff_320',
    };
function na(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M210.7 147.6c7.5-7.5 19.8-7.5 27.3 0l95.4 95.7c7.3 7.3 7.5 19.1.6 26.6l-94 94.3c-3.8 3.8-8.7 5.7-13.7 5.7-4.9 0-9.9-1.9-13.6-5.6-7.5-7.5-7.6-19.7 0-27.3l79.9-81.1-81.9-81.1c-7.6-7.4-7.6-19.6 0-27.2z',
                },
                child: [],
            },
            {
                tag: 'path',
                attr: {
                    d: 'M48 256c0 114.9 93.1 208 208 208s208-93.1 208-208S370.9 48 256 48 48 141.1 48 256zm32 0c0-47 18.3-91.2 51.6-124.4C164.8 98.3 209 80 256 80s91.2 18.3 124.4 51.6C413.7 164.8 432 209 432 256s-18.3 91.2-51.6 124.4C347.2 413.7 303 432 256 432s-91.2-18.3-124.4-51.6C98.3 347.2 80 303 80 256z',
                },
                child: [],
            },
        ],
    })(n);
}
function fh(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M256 48C140.559 48 48 140.559 48 256c0 115.436 92.559 208 208 208 115.435 0 208-92.564 208-208 0-115.441-92.564-208-208-208zm104.002 282.881l-29.12 29.117L256 285.117l-74.881 74.881-29.121-29.117L226.881 256l-74.883-74.881 29.121-29.116L256 226.881l74.881-74.878 29.12 29.116L285.119 256l74.883 74.881z',
                },
                child: [],
            },
        ],
    })(n);
}
const WI = ({ className: n }) =>
        X.jsxs('div', {
            className: Tr(Bt.root, n),
            children: [
                X.jsx(Em, {}),
                X.jsxs('div', {
                    className: Bt['checkout-div'],
                    children: [
                        X.jsxs('div', {
                            className: Bt['form-div'],
                            children: [
                                X.jsx('p', {
                                    className: Bt['left-heading'],
                                    children: 'Bestellen',
                                }),
                                X.jsx('p', { className: Bt['first-name'], children: 'Voornaam' }),
                                X.jsx('input', { className: Bt['first-name-input'] }),
                                X.jsxs('div', {
                                    style: {
                                        width: 208,
                                        height: 50,
                                        position: 'relative',
                                        left: '230px',
                                        bottom: '66px',
                                    },
                                    children: [
                                        X.jsx('p', {
                                            className: Bt['second-name'],
                                            children: 'Achternaam',
                                        }),
                                        X.jsx('input', { className: Bt['last-name-input'] }),
                                    ],
                                }),
                                X.jsx('p', {
                                    className: Bt['street-address'],
                                    children: 'Straat en huisnummer',
                                }),
                                X.jsx('input', { className: Bt['street-input'] }),
                                X.jsx('p', { className: Bt['city-label'], children: 'Plaats' }),
                                X.jsx('input', { className: Bt['city-input'] }),
                                X.jsx('p', { className: Bt.postcode, children: 'Postcode' }),
                                X.jsx('input', { className: Bt['postcode-input'] }),
                                X.jsx('button', {
                                    className: Bt['button-checkout'],
                                    children: 'Bestellen',
                                }),
                            ],
                        }),
                        X.jsxs('div', {
                            className: Bt.listingdiv,
                            children: [
                                X.jsx('p', {
                                    className: Bt['heading-checkout'],
                                    children: 'Winkelwagen',
                                }),
                                X.jsxs('div', {
                                    className: Bt['container-checkout'],
                                    children: [
                                        X.jsxs('div', {
                                            className: Bt.listing1,
                                            children: [
                                                X.jsx('img', {
                                                    style: {
                                                        width: '80px',
                                                        height: 70,
                                                        borderRadius: 10,
                                                    },
                                                    src: 'src/product image/Garderobe.png',
                                                }),
                                                X.jsx('p', {
                                                    className: Bt['text--1'],
                                                    children: 'Garderobe',
                                                }),
                                                X.jsx(fh, { className: Bt['close-icon-circle'] }),
                                            ],
                                        }),
                                        X.jsxs('div', {
                                            className: Bt.listing1,
                                            children: [
                                                X.jsx('img', {
                                                    style: {
                                                        width: 94,
                                                        height: '80px',
                                                        borderRadius: 10,
                                                    },
                                                    src: 'src/product image/Badkamermeubel.png',
                                                }),
                                                X.jsx('p', {
                                                    className: Bt['text--2'],
                                                    children: 'Kast',
                                                }),
                                                X.jsx(fh, { className: Bt['icon-circle2'] }),
                                            ],
                                        }),
                                        X.jsxs('div', {
                                            className: Bt.listing1,
                                            children: [
                                                X.jsx('img', {
                                                    style: {
                                                        width: 95,
                                                        height: '80px',
                                                        borderRadius: 65,
                                                    },
                                                    src: 'src/product image/Kast.png',
                                                }),
                                                X.jsx('p', {
                                                    className: Bt['text--3'],
                                                    children: 'Kast',
                                                }),
                                                X.jsx(fh, { className: Bt['circle-icon3'] }),
                                            ],
                                        }),
                                        X.jsxs('div', {
                                            className: Bt.listing1,
                                            children: [
                                                X.jsx('img', {
                                                    style: {
                                                        width: '80px',
                                                        height: '80px',
                                                        borderRadius: 2,
                                                        marginLeft: '10px',
                                                    },
                                                    src: 'src/product image/Image 50.png',
                                                }),
                                                X.jsx('p', {
                                                    className: Bt['text--4'],
                                                    children: 'Kast',
                                                }),
                                                X.jsx(fh, { className: Bt['class-circle-4'] }),
                                            ],
                                        }),
                                    ],
                                }),
                                X.jsx('button', {
                                    className: Bt['button-listing'],
                                    children: 'Opslaan voor later',
                                }),
                            ],
                        }),
                    ],
                }),
                X.jsx(R2, { className: Bt['footer-checkout'] }),
            ],
        }),
    jI = '_root_1khdr_1',
    XI = '_Lamp_1khdr_24',
    YI = '_kast_1khdr_40',
    qI = '_LivingRoom_1khdr_45',
    ZI = '_NewNow_1khdr_56',
    KI = '_ChevronLeft_1khdr_67',
    JI = '_Chevron_1khdr_67',
    QI = '_door_1khdr_100',
    Zt = {
        root: jI,
        'configurator-section': '_configurator-section_1khdr_5',
        'canva-div': '_canva-div_1khdr_12',
        'configurator-listing': '_configurator-listing_1khdr_17',
        Lamp: XI,
        'tv-meubel-div': '_tv-meubel-div_1khdr_35',
        kast: YI,
        LivingRoom: qI,
        NewNow: ZI,
        ChevronLeft: KI,
        Chevron: JI,
        'component-config': '_component-config_1khdr_84',
        'components-selection': '_components-selection_1khdr_89',
        door: QI,
        'door-icon': '_door-icon_1khdr_108',
        'frame-icon': '_frame-icon_1khdr_115',
        'handle-icon': '_handle-icon_1khdr_122',
        'drawer-icon': '_drawer-icon_1khdr_129',
        'rail-icon': '_rail-icon_1khdr_136',
        'shelve-icon': '_shelve-icon_1khdr_143',
        'shoe-icon': '_shoe-icon_1khdr_150',
    };
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Tm = '162',
    $I = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
    eN = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
    P2 = 0,
    T_ = 1,
    L2 = 2,
    tN = 3,
    I2 = 0,
    Am = 1,
    Bc = 2,
    Dr = 3,
    Gs = 0,
    Ai = 1,
    os = 2,
    ks = 0,
    Ia = 1,
    A_ = 2,
    C_ = 3,
    b_ = 4,
    N2 = 5,
    So = 100,
    D2 = 101,
    U2 = 102,
    R_ = 103,
    P_ = 104,
    O2 = 200,
    F2 = 201,
    k2 = 202,
    z2 = 203,
    Jp = 204,
    Qp = 205,
    B2 = 206,
    H2 = 207,
    V2 = 208,
    G2 = 209,
    W2 = 210,
    j2 = 211,
    X2 = 212,
    Y2 = 213,
    q2 = 214,
    Z2 = 0,
    K2 = 1,
    J2 = 2,
    cf = 3,
    Q2 = 4,
    $2 = 5,
    eC = 6,
    tC = 7,
    zf = 0,
    nC = 1,
    iC = 2,
    fs = 0,
    rC = 1,
    sC = 2,
    oC = 3,
    _x = 4,
    aC = 5,
    lC = 6,
    uC = 7,
    L_ = 'attached',
    cC = 'detached',
    Cm = 300,
    Ws = 301,
    Fo = 302,
    ff = 303,
    df = 304,
    Cu = 306,
    hf = 1e3,
    pi = 1001,
    pf = 1002,
    bn = 1003,
    $p = 1004,
    nN = 1004,
    ya = 1005,
    iN = 1005,
    dn = 1006,
    Hc = 1007,
    rN = 1007,
    as = 1008,
    sN = 1008,
    ds = 1009,
    fC = 1010,
    dC = 1011,
    bm = 1012,
    yx = 1013,
    Ds = 1014,
    Ki = 1015,
    _u = 1016,
    xx = 1017,
    Sx = 1018,
    Io = 1020,
    hC = 1021,
    wi = 1023,
    pC = 1024,
    mC = 1025,
    No = 1026,
    Va = 1027,
    Mx = 1028,
    wx = 1029,
    gC = 1030,
    Ex = 1031,
    Tx = 1033,
    vp = 33776,
    _p = 33777,
    yp = 33778,
    xp = 33779,
    I_ = 35840,
    N_ = 35841,
    D_ = 35842,
    U_ = 35843,
    Ax = 36196,
    O_ = 37492,
    F_ = 37496,
    k_ = 37808,
    z_ = 37809,
    B_ = 37810,
    H_ = 37811,
    V_ = 37812,
    G_ = 37813,
    W_ = 37814,
    j_ = 37815,
    X_ = 37816,
    Y_ = 37817,
    q_ = 37818,
    Z_ = 37819,
    K_ = 37820,
    J_ = 37821,
    Sp = 36492,
    Q_ = 36494,
    $_ = 36495,
    vC = 36283,
    ey = 36284,
    ty = 36285,
    ny = 36286,
    _C = 2200,
    yC = 2201,
    xC = 2202,
    mf = 2300,
    gf = 2301,
    Mp = 2302,
    Ea = 2400,
    Ta = 2401,
    vf = 2402,
    Rm = 2500,
    Cx = 2501,
    oN = 0,
    aN = 1,
    lN = 2,
    SC = 3200,
    MC = 3201,
    Vo = 0,
    wC = 1,
    Ps = '',
    _r = 'srgb',
    Ys = 'srgb-linear',
    Pm = 'display-p3',
    Bf = 'display-p3-linear',
    _f = 'linear',
    Jt = 'srgb',
    yf = 'rec709',
    xf = 'p3',
    uN = 0,
    va = 7680,
    cN = 7681,
    fN = 7682,
    dN = 7683,
    hN = 34055,
    pN = 34056,
    mN = 5386,
    gN = 512,
    vN = 513,
    _N = 514,
    yN = 515,
    xN = 516,
    SN = 517,
    MN = 518,
    iy = 519,
    EC = 512,
    TC = 513,
    AC = 514,
    bx = 515,
    CC = 516,
    bC = 517,
    RC = 518,
    PC = 519,
    Sf = 35044,
    wN = 35048,
    EN = 35040,
    TN = 35045,
    AN = 35049,
    CN = 35041,
    bN = 35046,
    RN = 35050,
    PN = 35042,
    LN = '100',
    ry = '300 es',
    em = 1035,
    ls = 2e3,
    Mf = 2001;
class qs {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1);
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
            e.target = null;
        }
    }
}
const ci = [
    '00',
    '01',
    '02',
    '03',
    '04',
    '05',
    '06',
    '07',
    '08',
    '09',
    '0a',
    '0b',
    '0c',
    '0d',
    '0e',
    '0f',
    '10',
    '11',
    '12',
    '13',
    '14',
    '15',
    '16',
    '17',
    '18',
    '19',
    '1a',
    '1b',
    '1c',
    '1d',
    '1e',
    '1f',
    '20',
    '21',
    '22',
    '23',
    '24',
    '25',
    '26',
    '27',
    '28',
    '29',
    '2a',
    '2b',
    '2c',
    '2d',
    '2e',
    '2f',
    '30',
    '31',
    '32',
    '33',
    '34',
    '35',
    '36',
    '37',
    '38',
    '39',
    '3a',
    '3b',
    '3c',
    '3d',
    '3e',
    '3f',
    '40',
    '41',
    '42',
    '43',
    '44',
    '45',
    '46',
    '47',
    '48',
    '49',
    '4a',
    '4b',
    '4c',
    '4d',
    '4e',
    '4f',
    '50',
    '51',
    '52',
    '53',
    '54',
    '55',
    '56',
    '57',
    '58',
    '59',
    '5a',
    '5b',
    '5c',
    '5d',
    '5e',
    '5f',
    '60',
    '61',
    '62',
    '63',
    '64',
    '65',
    '66',
    '67',
    '68',
    '69',
    '6a',
    '6b',
    '6c',
    '6d',
    '6e',
    '6f',
    '70',
    '71',
    '72',
    '73',
    '74',
    '75',
    '76',
    '77',
    '78',
    '79',
    '7a',
    '7b',
    '7c',
    '7d',
    '7e',
    '7f',
    '80',
    '81',
    '82',
    '83',
    '84',
    '85',
    '86',
    '87',
    '88',
    '89',
    '8a',
    '8b',
    '8c',
    '8d',
    '8e',
    '8f',
    '90',
    '91',
    '92',
    '93',
    '94',
    '95',
    '96',
    '97',
    '98',
    '99',
    '9a',
    '9b',
    '9c',
    '9d',
    '9e',
    '9f',
    'a0',
    'a1',
    'a2',
    'a3',
    'a4',
    'a5',
    'a6',
    'a7',
    'a8',
    'a9',
    'aa',
    'ab',
    'ac',
    'ad',
    'ae',
    'af',
    'b0',
    'b1',
    'b2',
    'b3',
    'b4',
    'b5',
    'b6',
    'b7',
    'b8',
    'b9',
    'ba',
    'bb',
    'bc',
    'bd',
    'be',
    'bf',
    'c0',
    'c1',
    'c2',
    'c3',
    'c4',
    'c5',
    'c6',
    'c7',
    'c8',
    'c9',
    'ca',
    'cb',
    'cc',
    'cd',
    'ce',
    'cf',
    'd0',
    'd1',
    'd2',
    'd3',
    'd4',
    'd5',
    'd6',
    'd7',
    'd8',
    'd9',
    'da',
    'db',
    'dc',
    'dd',
    'de',
    'df',
    'e0',
    'e1',
    'e2',
    'e3',
    'e4',
    'e5',
    'e6',
    'e7',
    'e8',
    'e9',
    'ea',
    'eb',
    'ec',
    'ed',
    'ee',
    'ef',
    'f0',
    'f1',
    'f2',
    'f3',
    'f4',
    'f5',
    'f6',
    'f7',
    'f8',
    'f9',
    'fa',
    'fb',
    'fc',
    'fd',
    'fe',
    'ff',
];
let QM = 1234567;
const Na = Math.PI / 180,
    yu = 180 / Math.PI;
function er() {
    const n = (Math.random() * 4294967295) | 0,
        e = (Math.random() * 4294967295) | 0,
        t = (Math.random() * 4294967295) | 0,
        i = (Math.random() * 4294967295) | 0;
    return (
        ci[n & 255] +
        ci[(n >> 8) & 255] +
        ci[(n >> 16) & 255] +
        ci[(n >> 24) & 255] +
        '-' +
        ci[e & 255] +
        ci[(e >> 8) & 255] +
        '-' +
        ci[((e >> 16) & 15) | 64] +
        ci[(e >> 24) & 255] +
        '-' +
        ci[(t & 63) | 128] +
        ci[(t >> 8) & 255] +
        '-' +
        ci[(t >> 16) & 255] +
        ci[(t >> 24) & 255] +
        ci[i & 255] +
        ci[(i >> 8) & 255] +
        ci[(i >> 16) & 255] +
        ci[(i >> 24) & 255]
    ).toLowerCase();
}
function wn(n, e, t) {
    return Math.max(e, Math.min(t, n));
}
function Rx(n, e) {
    return ((n % e) + e) % e;
}
function IN(n, e, t, i, r) {
    return i + ((n - e) * (r - i)) / (t - e);
}
function NN(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0;
}
function Vc(n, e, t) {
    return (1 - t) * n + t * e;
}
function DN(n, e, t, i) {
    return Vc(n, e, 1 - Math.exp(-t * i));
}
function UN(n, e = 1) {
    return e - Math.abs(Rx(n, e * 2) - e);
}
function ON(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function FN(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function kN(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1));
}
function zN(n, e) {
    return n + Math.random() * (e - n);
}
function BN(n) {
    return n * (0.5 - Math.random());
}
function HN(n) {
    n !== void 0 && (QM = n);
    let e = (QM += 1831565813);
    return (
        (e = Math.imul(e ^ (e >>> 15), e | 1)),
        (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
        ((e ^ (e >>> 14)) >>> 0) / 4294967296
    );
}
function VN(n) {
    return n * Na;
}
function GN(n) {
    return n * yu;
}
function sy(n) {
    return (n & (n - 1)) === 0 && n !== 0;
}
function WN(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function tm(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function jN(n, e, t, i, r) {
    const s = Math.cos,
        o = Math.sin,
        a = s(t / 2),
        c = o(t / 2),
        f = s((e + i) / 2),
        d = o((e + i) / 2),
        h = s((e - i) / 2),
        p = o((e - i) / 2),
        v = s((i - e) / 2),
        _ = o((i - e) / 2);
    switch (r) {
        case 'XYX':
            n.set(a * d, c * h, c * p, a * f);
            break;
        case 'YZY':
            n.set(c * p, a * d, c * h, a * f);
            break;
        case 'ZXZ':
            n.set(c * h, c * p, a * d, a * f);
            break;
        case 'XZX':
            n.set(a * d, c * _, c * v, a * f);
            break;
        case 'YXY':
            n.set(c * v, a * d, c * _, a * f);
            break;
        case 'ZYZ':
            n.set(c * _, c * v, a * d, a * f);
            break;
        default:
            console.warn(
                'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
                    r
            );
    }
}
function Ei(n, e) {
    switch (e.constructor) {
        case Float32Array:
            return n;
        case Uint32Array:
            return n / 4294967295;
        case Uint16Array:
            return n / 65535;
        case Uint8Array:
            return n / 255;
        case Int32Array:
            return Math.max(n / 2147483647, -1);
        case Int16Array:
            return Math.max(n / 32767, -1);
        case Int8Array:
            return Math.max(n / 127, -1);
        default:
            throw new Error('Invalid component type.');
    }
}
function Tt(n, e) {
    switch (e.constructor) {
        case Float32Array:
            return n;
        case Uint32Array:
            return Math.round(n * 4294967295);
        case Uint16Array:
            return Math.round(n * 65535);
        case Uint8Array:
            return Math.round(n * 255);
        case Int32Array:
            return Math.round(n * 2147483647);
        case Int16Array:
            return Math.round(n * 32767);
        case Int8Array:
            return Math.round(n * 127);
        default:
            throw new Error('Invalid component type.');
    }
}
const XN = {
    DEG2RAD: Na,
    RAD2DEG: yu,
    generateUUID: er,
    clamp: wn,
    euclideanModulo: Rx,
    mapLinear: IN,
    inverseLerp: NN,
    lerp: Vc,
    damp: DN,
    pingpong: UN,
    smoothstep: ON,
    smootherstep: FN,
    randInt: kN,
    randFloat: zN,
    randFloatSpread: BN,
    seededRandom: HN,
    degToRad: VN,
    radToDeg: GN,
    isPowerOfTwo: sy,
    ceilPowerOfTwo: WN,
    floorPowerOfTwo: tm,
    setQuaternionFromProperEuler: jN,
    normalize: Tt,
    denormalize: Ei,
};
class _e {
    constructor(e = 0, t = 0) {
        (_e.prototype.isVector2 = !0), (this.x = e), (this.y = t);
    }
    get width() {
        return this.x;
    }
    set width(e) {
        this.x = e;
    }
    get height() {
        return this.y;
    }
    set height(e) {
        this.y = e;
    }
    set(e, t) {
        return (this.x = e), (this.y = t), this;
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error('index is out of range: ' + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
    }
    add(e) {
        return (this.x += e.x), (this.y += e.y), this;
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), this;
    }
    addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
    }
    addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
    }
    sub(e) {
        return (this.x -= e.x), (this.y -= e.y), this;
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
    }
    multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            r = e.elements;
        return (this.x = r[0] * t + r[3] * i + r[6]), (this.y = r[1] * t + r[4] * i + r[7]), this;
    }
    min(e) {
        return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
    }
    max(e) {
        return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
        );
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
    }
    floor() {
        return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
        return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
        return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
    }
    negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y;
    }
    cross(e) {
        return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(wn(i, -1, 1));
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y;
        return t * t + i * i;
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
    }
    lerpVectors(e, t, i) {
        return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
    }
    fromBufferAttribute(e, t) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
    }
    rotateAround(e, t) {
        const i = Math.cos(t),
            r = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
        return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
    }
    random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y;
    }
}
class Et {
    constructor(e, t, i, r, s, o, a, c, f) {
        (Et.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            e !== void 0 && this.set(e, t, i, r, s, o, a, c, f);
    }
    set(e, t, i, r, s, o, a, c, f) {
        const d = this.elements;
        return (
            (d[0] = e),
            (d[1] = r),
            (d[2] = a),
            (d[3] = t),
            (d[4] = s),
            (d[5] = c),
            (d[6] = i),
            (d[7] = o),
            (d[8] = f),
            this
        );
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            this
        );
    }
    extractBasis(e, t, i) {
        return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            i.setFromMatrix3Column(this, 2),
            this
        );
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }
    multiply(e) {
        return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[3],
            c = i[6],
            f = i[1],
            d = i[4],
            h = i[7],
            p = i[2],
            v = i[5],
            _ = i[8],
            w = r[0],
            x = r[3],
            g = r[6],
            S = r[1],
            M = r[4],
            T = r[7],
            P = r[2],
            A = r[5],
            R = r[8];
        return (
            (s[0] = o * w + a * S + c * P),
            (s[3] = o * x + a * M + c * A),
            (s[6] = o * g + a * T + c * R),
            (s[1] = f * w + d * S + h * P),
            (s[4] = f * x + d * M + h * A),
            (s[7] = f * g + d * T + h * R),
            (s[2] = p * w + v * S + _ * P),
            (s[5] = p * x + v * M + _ * A),
            (s[8] = p * g + v * T + _ * R),
            this
        );
    }
    multiplyScalar(e) {
        const t = this.elements;
        return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
        );
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            c = e[6],
            f = e[7],
            d = e[8];
        return t * o * d - t * a * f - i * s * d + i * a * c + r * s * f - r * o * c;
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            c = e[6],
            f = e[7],
            d = e[8],
            h = d * o - a * f,
            p = a * c - d * s,
            v = f * s - o * c,
            _ = t * h + i * p + r * v;
        if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / _;
        return (
            (e[0] = h * w),
            (e[1] = (r * f - d * i) * w),
            (e[2] = (a * i - r * o) * w),
            (e[3] = p * w),
            (e[4] = (d * t - r * c) * w),
            (e[5] = (r * s - a * t) * w),
            (e[6] = v * w),
            (e[7] = (i * c - f * t) * w),
            (e[8] = (o * t - i * s) * w),
            this
        );
    }
    transpose() {
        let e;
        const t = this.elements;
        return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
        );
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
        );
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const c = Math.cos(s),
            f = Math.sin(s);
        return (
            this.set(
                i * c,
                i * f,
                -i * (c * o + f * a) + o + e,
                -r * f,
                r * c,
                -r * (-f * o + c * a) + a + t,
                0,
                0,
                1
            ),
            this
        );
    }
    scale(e, t) {
        return this.premultiply(Dv.makeScale(e, t)), this;
    }
    rotate(e) {
        return this.premultiply(Dv.makeRotation(-e)), this;
    }
    translate(e, t) {
        return this.premultiply(Dv.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
        return (
            e.isVector2
                ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
                : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
        );
    }
    makeRotation(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this;
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            e
        );
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
}
const Dv = new Et();
function LC(n) {
    for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
    return !1;
}
const YN = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
};
function Kl(n, e) {
    return new YN[n](e);
}
function wf(n) {
    return document.createElementNS('http://www.w3.org/1999/xhtml', n);
}
function IC() {
    const n = wf('canvas');
    return (n.style.display = 'block'), n;
}
const $M = {};
function NC(n) {
    n in $M || (($M[n] = !0), console.warn(n));
}
const ew = new Et().set(
        0.8224621,
        0.177538,
        0,
        0.0331941,
        0.9668058,
        0,
        0.0170827,
        0.0723974,
        0.9105199
    ),
    tw = new Et().set(
        1.2249401,
        -0.2249404,
        0,
        -0.0420569,
        1.0420571,
        0,
        -0.0196376,
        -0.0786361,
        1.0982735
    ),
    dh = {
        [Ys]: { transfer: _f, primaries: yf, toReference: (n) => n, fromReference: (n) => n },
        [_r]: {
            transfer: Jt,
            primaries: yf,
            toReference: (n) => n.convertSRGBToLinear(),
            fromReference: (n) => n.convertLinearToSRGB(),
        },
        [Bf]: {
            transfer: _f,
            primaries: xf,
            toReference: (n) => n.applyMatrix3(tw),
            fromReference: (n) => n.applyMatrix3(ew),
        },
        [Pm]: {
            transfer: Jt,
            primaries: xf,
            toReference: (n) => n.convertSRGBToLinear().applyMatrix3(tw),
            fromReference: (n) => n.applyMatrix3(ew).convertLinearToSRGB(),
        },
    },
    qN = new Set([Ys, Bf]),
    Gt = {
        enabled: !0,
        _workingColorSpace: Ys,
        get workingColorSpace() {
            return this._workingColorSpace;
        },
        set workingColorSpace(n) {
            if (!qN.has(n)) throw new Error(`Unsupported working color space, "${n}".`);
            this._workingColorSpace = n;
        },
        convert: function (n, e, t) {
            if (this.enabled === !1 || e === t || !e || !t) return n;
            const i = dh[e].toReference,
                r = dh[t].fromReference;
            return r(i(n));
        },
        fromWorkingColorSpace: function (n, e) {
            return this.convert(n, this._workingColorSpace, e);
        },
        toWorkingColorSpace: function (n, e) {
            return this.convert(n, e, this._workingColorSpace);
        },
        getPrimaries: function (n) {
            return dh[n].primaries;
        },
        getTransfer: function (n) {
            return n === Ps ? _f : dh[n].transfer;
        },
    };
function cu(n) {
    return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Uv(n) {
    return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let hl;
class Px {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            hl === void 0 && (hl = wf('canvas')), (hl.width = e.width), (hl.height = e.height);
            const i = hl.getContext('2d');
            e instanceof ImageData
                ? i.putImageData(e, 0, 0)
                : i.drawImage(e, 0, 0, e.width, e.height),
                (t = hl);
        }
        return t.width > 2048 || t.height > 2048
            ? (console.warn(
                  'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
                  e
              ),
              t.toDataURL('image/jpeg', 0.6))
            : t.toDataURL('image/png');
    }
    static sRGBToLinear(e) {
        if (
            (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
        ) {
            const t = wf('canvas');
            (t.width = e.width), (t.height = e.height);
            const i = t.getContext('2d');
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height),
                s = r.data;
            for (let o = 0; o < s.length; o++) s[o] = cu(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0), t;
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray
                    ? (t[i] = Math.floor(cu(t[i] / 255) * 255))
                    : (t[i] = cu(t[i]));
            return { data: t, width: e.width, height: e.height };
        } else
            return (
                console.warn(
                    'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
                ),
                e
            );
    }
}
let ZN = 0;
class Aa {
    constructor(e = null) {
        (this.isSource = !0),
            Object.defineProperty(this, 'id', { value: ZN++ }),
            (this.uuid = er()),
            (this.data = e),
            (this.dataReady = !0),
            (this.version = 0);
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string';
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const i = { uuid: this.uuid, url: '' },
            r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(Ov(r[o].image)) : s.push(Ov(r[o]));
            } else s = Ov(r);
            i.url = s;
        }
        return t || (e.images[this.uuid] = i), i;
    }
}
function Ov(n) {
    return (typeof HTMLImageElement < 'u' && n instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && n instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && n instanceof ImageBitmap)
        ? Px.getDataURL(n)
        : n.data
        ? {
              data: Array.from(n.data),
              width: n.width,
              height: n.height,
              type: n.data.constructor.name,
          }
        : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
let KN = 0;
class mn extends qs {
    constructor(
        e = mn.DEFAULT_IMAGE,
        t = mn.DEFAULT_MAPPING,
        i = pi,
        r = pi,
        s = dn,
        o = as,
        a = wi,
        c = ds,
        f = mn.DEFAULT_ANISOTROPY,
        d = Ps
    ) {
        super(),
            (this.isTexture = !0),
            Object.defineProperty(this, 'id', { value: KN++ }),
            (this.uuid = er()),
            (this.name = ''),
            (this.source = new Aa(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.channel = 0),
            (this.wrapS = i),
            (this.wrapT = r),
            (this.magFilter = s),
            (this.minFilter = o),
            (this.anisotropy = f),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = c),
            (this.offset = new _e(0, 0)),
            (this.repeat = new _e(1, 1)),
            (this.center = new _e(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Et()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = d),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
    }
    get image() {
        return this.source.data;
    }
    set image(e = null) {
        this.source.data = e;
    }
    updateMatrix() {
        this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.channel = e.channel),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.colorSpace = e.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
        );
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string';
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const i = {
            metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
        };
        return (
            Object.keys(this.userData).length > 0 && (i.userData = this.userData),
            t || (e.textures[this.uuid] = i),
            i
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
    transformUv(e) {
        if (this.mapping !== Cm) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
                case hf:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case pi:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case pf:
                    Math.abs(Math.floor(e.x) % 2) === 1
                        ? (e.x = Math.ceil(e.x) - e.x)
                        : (e.x = e.x - Math.floor(e.x));
                    break;
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
                case hf:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case pi:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case pf:
                    Math.abs(Math.floor(e.y) % 2) === 1
                        ? (e.y = Math.ceil(e.y) - e.y)
                        : (e.y = e.y - Math.floor(e.y));
                    break;
            }
        return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, (this.source.needsUpdate = !0));
    }
}
mn.DEFAULT_IMAGE = null;
mn.DEFAULT_MAPPING = Cm;
mn.DEFAULT_ANISOTROPY = 1;
class Wt {
    constructor(e = 0, t = 0, i = 0, r = 1) {
        (Wt.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = i), (this.w = r);
    }
    get width() {
        return this.z;
    }
    set width(e) {
        this.z = e;
    }
    get height() {
        return this.w;
    }
    set height(e) {
        this.w = e;
    }
    set(e, t, i, r) {
        return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setZ(e) {
        return (this.z = e), this;
    }
    setW(e) {
        return (this.w = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error('index is out of range: ' + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
        return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
        );
    }
    add(e) {
        return (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this;
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
    }
    addVectors(e, t) {
        return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
        );
    }
    addScaledVector(e, t) {
        return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this
        );
    }
    sub(e) {
        return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this;
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
    }
    subVectors(e, t) {
        return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
        );
    }
    multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this;
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = this.w,
            o = e.elements;
        return (
            (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
            (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
            (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
            (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
            this
        );
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return (
            t < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
        );
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const c = e.elements,
            f = c[0],
            d = c[4],
            h = c[8],
            p = c[1],
            v = c[5],
            _ = c[9],
            w = c[2],
            x = c[6],
            g = c[10];
        if (Math.abs(d - p) < 0.01 && Math.abs(h - w) < 0.01 && Math.abs(_ - x) < 0.01) {
            if (
                Math.abs(d + p) < 0.1 &&
                Math.abs(h + w) < 0.1 &&
                Math.abs(_ + x) < 0.1 &&
                Math.abs(f + v + g - 3) < 0.1
            )
                return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const M = (f + 1) / 2,
                T = (v + 1) / 2,
                P = (g + 1) / 2,
                A = (d + p) / 4,
                R = (h + w) / 4,
                D = (_ + x) / 4;
            return (
                M > T && M > P
                    ? M < 0.01
                        ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
                        : ((i = Math.sqrt(M)), (r = A / i), (s = R / i))
                    : T > P
                    ? T < 0.01
                        ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
                        : ((r = Math.sqrt(T)), (i = A / r), (s = D / r))
                    : P < 0.01
                    ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
                    : ((s = Math.sqrt(P)), (i = R / s), (r = D / s)),
                this.set(i, r, s, t),
                this
            );
        }
        let S = Math.sqrt((x - _) * (x - _) + (h - w) * (h - w) + (p - d) * (p - d));
        return (
            Math.abs(S) < 0.001 && (S = 1),
            (this.x = (x - _) / S),
            (this.y = (h - w) / S),
            (this.z = (p - d) / S),
            (this.w = Math.acos((f + v + g - 1) / 2)),
            this
        );
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
        );
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
        );
    }
    ceil() {
        return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
        );
    }
    round() {
        return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
        );
    }
    roundToZero() {
        return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
        );
    }
    negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
        );
    }
    lerpVectors(e, t, i) {
        return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            (this.z = e.z + (t.z - e.z) * i),
            (this.w = e.w + (t.w - e.w) * i),
            this
        );
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
    }
    fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
    }
    fromBufferAttribute(e, t) {
        return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
        );
    }
    random() {
        return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
        );
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
    }
}
class DC extends qs {
    constructor(e = 1, t = 1, i = {}) {
        super(),
            (this.isRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Wt(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Wt(0, 0, e, t));
        const r = { width: e, height: t, depth: 1 };
        i = Object.assign(
            {
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: dn,
                depthBuffer: !0,
                stencilBuffer: !1,
                depthTexture: null,
                samples: 0,
                count: 1,
            },
            i
        );
        const s = new mn(
            r,
            i.mapping,
            i.wrapS,
            i.wrapT,
            i.magFilter,
            i.minFilter,
            i.format,
            i.type,
            i.anisotropy,
            i.colorSpace
        );
        (s.flipY = !1),
            (s.generateMipmaps = i.generateMipmaps),
            (s.internalFormat = i.internalFormat),
            (this.textures = []);
        const o = i.count;
        for (let a = 0; a < o; a++)
            (this.textures[a] = s.clone()), (this.textures[a].isRenderTargetTexture = !0);
        (this.depthBuffer = i.depthBuffer),
            (this.stencilBuffer = i.stencilBuffer),
            (this.depthTexture = i.depthTexture),
            (this.samples = i.samples);
    }
    get texture() {
        return this.textures[0];
    }
    set texture(e) {
        this.textures[0] = e;
    }
    setSize(e, t, i = 1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            (this.width = e), (this.height = t), (this.depth = i);
            for (let r = 0, s = this.textures.length; r < s; r++)
                (this.textures[r].image.width = e),
                    (this.textures[r].image.height = t),
                    (this.textures[r].image.depth = i);
            this.dispose();
        }
        this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.textures.length = 0);
        for (let i = 0, r = e.textures.length; i < r; i++)
            (this.textures[i] = e.textures[i].clone()),
                (this.textures[i].isRenderTargetTexture = !0);
        const t = Object.assign({}, e.texture.image);
        return (
            (this.texture.source = new Aa(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
}
class Vr extends DC {
    constructor(e = 1, t = 1, i = {}) {
        super(e, t, i), (this.isWebGLRenderTarget = !0);
    }
}
class Lm extends mn {
    constructor(e = null, t = 1, i = 1, r = 1) {
        super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: r }),
            (this.magFilter = bn),
            (this.minFilter = bn),
            (this.wrapR = pi),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
}
class JN extends Vr {
    constructor(e = 1, t = 1, i = 1, r = {}) {
        super(e, t, r),
            (this.isWebGLArrayRenderTarget = !0),
            (this.depth = i),
            (this.texture = new Lm(null, e, t, i)),
            (this.texture.isRenderTargetTexture = !0);
    }
}
class Lx extends mn {
    constructor(e = null, t = 1, i = 1, r = 1) {
        super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: r }),
            (this.magFilter = bn),
            (this.minFilter = bn),
            (this.wrapR = pi),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
}
class QN extends Vr {
    constructor(e = 1, t = 1, i = 1, r = {}) {
        super(e, t, r),
            (this.isWebGL3DRenderTarget = !0),
            (this.depth = i),
            (this.texture = new Lx(null, e, t, i)),
            (this.texture.isRenderTargetTexture = !0);
    }
}
class Bi {
    constructor(e = 0, t = 0, i = 0, r = 1) {
        (this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = i), (this._w = r);
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let c = i[r + 0],
            f = i[r + 1],
            d = i[r + 2],
            h = i[r + 3];
        const p = s[o + 0],
            v = s[o + 1],
            _ = s[o + 2],
            w = s[o + 3];
        if (a === 0) {
            (e[t + 0] = c), (e[t + 1] = f), (e[t + 2] = d), (e[t + 3] = h);
            return;
        }
        if (a === 1) {
            (e[t + 0] = p), (e[t + 1] = v), (e[t + 2] = _), (e[t + 3] = w);
            return;
        }
        if (h !== w || c !== p || f !== v || d !== _) {
            let x = 1 - a;
            const g = c * p + f * v + d * _ + h * w,
                S = g >= 0 ? 1 : -1,
                M = 1 - g * g;
            if (M > Number.EPSILON) {
                const P = Math.sqrt(M),
                    A = Math.atan2(P, g * S);
                (x = Math.sin(x * A) / P), (a = Math.sin(a * A) / P);
            }
            const T = a * S;
            if (
                ((c = c * x + p * T),
                (f = f * x + v * T),
                (d = d * x + _ * T),
                (h = h * x + w * T),
                x === 1 - a)
            ) {
                const P = 1 / Math.sqrt(c * c + f * f + d * d + h * h);
                (c *= P), (f *= P), (d *= P), (h *= P);
            }
        }
        (e[t] = c), (e[t + 1] = f), (e[t + 2] = d), (e[t + 3] = h);
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r],
            c = i[r + 1],
            f = i[r + 2],
            d = i[r + 3],
            h = s[o],
            p = s[o + 1],
            v = s[o + 2],
            _ = s[o + 3];
        return (
            (e[t] = a * _ + d * h + c * v - f * p),
            (e[t + 1] = c * _ + d * p + f * h - a * v),
            (e[t + 2] = f * _ + d * v + a * p - c * h),
            (e[t + 3] = d * _ - a * h - c * p - f * v),
            e
        );
    }
    get x() {
        return this._x;
    }
    set x(e) {
        (this._x = e), this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        (this._y = e), this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        (this._z = e), this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(e) {
        (this._w = e), this._onChangeCallback();
    }
    set(e, t, i, r) {
        return (
            (this._x = e),
            (this._y = t),
            (this._z = i),
            (this._w = r),
            this._onChangeCallback(),
            this
        );
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
        return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
        );
    }
    setFromEuler(e, t = !0) {
        const i = e._x,
            r = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            c = Math.sin,
            f = a(i / 2),
            d = a(r / 2),
            h = a(s / 2),
            p = c(i / 2),
            v = c(r / 2),
            _ = c(s / 2);
        switch (o) {
            case 'XYZ':
                (this._x = p * d * h + f * v * _),
                    (this._y = f * v * h - p * d * _),
                    (this._z = f * d * _ + p * v * h),
                    (this._w = f * d * h - p * v * _);
                break;
            case 'YXZ':
                (this._x = p * d * h + f * v * _),
                    (this._y = f * v * h - p * d * _),
                    (this._z = f * d * _ - p * v * h),
                    (this._w = f * d * h + p * v * _);
                break;
            case 'ZXY':
                (this._x = p * d * h - f * v * _),
                    (this._y = f * v * h + p * d * _),
                    (this._z = f * d * _ + p * v * h),
                    (this._w = f * d * h - p * v * _);
                break;
            case 'ZYX':
                (this._x = p * d * h - f * v * _),
                    (this._y = f * v * h + p * d * _),
                    (this._z = f * d * _ - p * v * h),
                    (this._w = f * d * h + p * v * _);
                break;
            case 'YZX':
                (this._x = p * d * h + f * v * _),
                    (this._y = f * v * h + p * d * _),
                    (this._z = f * d * _ - p * v * h),
                    (this._w = f * d * h - p * v * _);
                break;
            case 'XZY':
                (this._x = p * d * h - f * v * _),
                    (this._y = f * v * h - p * d * _),
                    (this._z = f * d * _ + p * v * h),
                    (this._w = f * d * h + p * v * _);
                break;
            default:
                console.warn(
                    'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + o
                );
        }
        return t === !0 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
        const i = t / 2,
            r = Math.sin(i);
        return (
            (this._x = e.x * r),
            (this._y = e.y * r),
            (this._z = e.z * r),
            (this._w = Math.cos(i)),
            this._onChangeCallback(),
            this
        );
    }
    setFromRotationMatrix(e) {
        const t = e.elements,
            i = t[0],
            r = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            c = t[9],
            f = t[2],
            d = t[6],
            h = t[10],
            p = i + a + h;
        if (p > 0) {
            const v = 0.5 / Math.sqrt(p + 1);
            (this._w = 0.25 / v),
                (this._x = (d - c) * v),
                (this._y = (s - f) * v),
                (this._z = (o - r) * v);
        } else if (i > a && i > h) {
            const v = 2 * Math.sqrt(1 + i - a - h);
            (this._w = (d - c) / v),
                (this._x = 0.25 * v),
                (this._y = (r + o) / v),
                (this._z = (s + f) / v);
        } else if (a > h) {
            const v = 2 * Math.sqrt(1 + a - i - h);
            (this._w = (s - f) / v),
                (this._x = (r + o) / v),
                (this._y = 0.25 * v),
                (this._z = (c + d) / v);
        } else {
            const v = 2 * Math.sqrt(1 + h - i - a);
            (this._w = (o - r) / v),
                (this._x = (s + f) / v),
                (this._y = (c + d) / v),
                (this._z = 0.25 * v);
        }
        return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return (
            i < Number.EPSILON
                ? ((i = 0),
                  Math.abs(e.x) > Math.abs(e.z)
                      ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
                      : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
                : ((this._x = e.y * t.z - e.z * t.y),
                  (this._y = e.z * t.x - e.x * t.z),
                  (this._z = e.x * t.y - e.y * t.x),
                  (this._w = i)),
            this.normalize()
        );
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(wn(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0) return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r), this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        return this.conjugate();
    }
    conjugate() {
        return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(
            this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        );
    }
    normalize() {
        let e = this.length();
        return (
            e === 0
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((e = 1 / e),
                  (this._x = this._x * e),
                  (this._y = this._y * e),
                  (this._z = this._z * e),
                  (this._w = this._w * e)),
            this._onChangeCallback(),
            this
        );
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
        const i = e._x,
            r = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            c = t._y,
            f = t._z,
            d = t._w;
        return (
            (this._x = i * d + o * a + r * f - s * c),
            (this._y = r * d + o * c + s * a - i * f),
            (this._z = s * d + o * f + i * c - r * a),
            (this._w = o * d - i * a - r * c - s * f),
            this._onChangeCallback(),
            this
        );
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const i = this._x,
            r = this._y,
            s = this._z,
            o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (
            (a < 0
                ? ((this._w = -e._w),
                  (this._x = -e._x),
                  (this._y = -e._y),
                  (this._z = -e._z),
                  (a = -a))
                : this.copy(e),
            a >= 1)
        )
            return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
        const c = 1 - a * a;
        if (c <= Number.EPSILON) {
            const v = 1 - t;
            return (
                (this._w = v * o + t * this._w),
                (this._x = v * i + t * this._x),
                (this._y = v * r + t * this._y),
                (this._z = v * s + t * this._z),
                this.normalize(),
                this
            );
        }
        const f = Math.sqrt(c),
            d = Math.atan2(f, a),
            h = Math.sin((1 - t) * d) / f,
            p = Math.sin(t * d) / f;
        return (
            (this._w = o * h + this._w * p),
            (this._x = i * h + this._x * p),
            (this._y = r * h + this._y * p),
            (this._z = s * h + this._z * p),
            this._onChangeCallback(),
            this
        );
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i);
    }
    random() {
        const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            i = Math.random(),
            r = Math.sqrt(1 - i),
            s = Math.sqrt(i);
        return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t));
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
    }
    fromArray(e, t = 0) {
        return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e
        );
    }
    fromBufferAttribute(e, t) {
        return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this._onChangeCallback(),
            this
        );
    }
    toJSON() {
        return this.toArray();
    }
    _onChange(e) {
        return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
    }
}
class k {
    constructor(e = 0, t = 0, i = 0) {
        (k.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z), (this.x = e), (this.y = t), (this.z = i), this;
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setZ(e) {
        return (this.z = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error('index is out of range: ' + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
    }
    add(e) {
        return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
    }
    addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
    }
    addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
    }
    sub(e) {
        return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
    }
    subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
    }
    multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
    }
    multiplyVectors(e, t) {
        return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
    }
    applyEuler(e) {
        return this.applyQuaternion(nw.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(nw.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
        return (
            (this.x = s[0] * t + s[3] * i + s[6] * r),
            (this.y = s[1] * t + s[4] * i + s[7] * r),
            (this.z = s[2] * t + s[5] * i + s[8] * r),
            this
        );
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return (
            (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
            (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
            (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
            this
        );
    }
    applyQuaternion(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            c = e.w,
            f = 2 * (o * r - a * i),
            d = 2 * (a * t - s * r),
            h = 2 * (s * i - o * t);
        return (
            (this.x = t + c * f + o * h - a * d),
            (this.y = i + c * d + a * f - s * h),
            (this.z = r + c * h + s * d - o * f),
            this
        );
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
    }
    transformDirection(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
        return (
            (this.x = s[0] * t + s[4] * i + s[8] * r),
            (this.y = s[1] * t + s[5] * i + s[9] * r),
            (this.z = s[2] * t + s[6] * i + s[10] * r),
            this.normalize()
        );
    }
    divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
        );
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
        );
    }
    ceil() {
        return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
        );
    }
    round() {
        return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
        );
    }
    roundToZero() {
        return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
        );
    }
    negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
        );
    }
    lerpVectors(e, t, i) {
        return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            (this.z = e.z + (t.z - e.z) * i),
            this
        );
    }
    cross(e) {
        return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            c = t.z;
        return (this.x = r * c - s * a), (this.y = s * o - i * c), (this.z = i * a - r * o), this;
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i);
    }
    projectOnPlane(e) {
        return Fv.copy(this).projectOnVector(e), this.sub(Fv);
    }
    reflect(e) {
        return this.sub(Fv.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(wn(i, -1, 1));
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y,
            r = this.z - e.z;
        return t * t + i * i + r * r;
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return (
            (this.x = r * Math.sin(i)), (this.y = Math.cos(t) * e), (this.z = r * Math.cos(i)), this
        );
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, i) {
        return (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this;
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = i), (this.z = r), this;
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
        return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
    }
    setFromColor(e) {
        return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
    }
    fromBufferAttribute(e, t) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
    }
    random() {
        return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2,
            t = Math.random() * 2 - 1,
            i = Math.sqrt(1 - t * t);
        return (this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
    }
}
const Fv = new k(),
    nw = new Bi();
class Ci {
    constructor(e = new k(1 / 0, 1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0, -1 / 0)) {
        (this.isBox3 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Pr.fromArray(e, t));
        return this;
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Pr.fromBufferAttribute(e, t));
        return this;
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this;
    }
    setFromCenterAndSize(e, t) {
        const i = Pr.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
        return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
        );
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e) {
        return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute('position');
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, Pr) : Pr.fromBufferAttribute(s, o),
                        Pr.applyMatrix4(e.matrixWorld),
                        this.expandByPoint(Pr);
            else
                e.boundingBox !== void 0
                    ? (e.boundingBox === null && e.computeBoundingBox(), hh.copy(e.boundingBox))
                    : (i.boundingBox === null && i.computeBoundingBox(), hh.copy(i.boundingBox)),
                    hh.applyMatrix4(e.matrixWorld),
                    this.union(hh);
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
        return this;
    }
    containsPoint(e) {
        return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
        );
    }
    containsBox(e) {
        return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
        );
    }
    getParameter(e, t) {
        return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
        );
    }
    intersectsBox(e) {
        return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
        );
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Pr), Pr.distanceToSquared(e.center) <= e.radius * e.radius;
    }
    intersectsPlane(e) {
        let t, i;
        return (
            e.normal.x > 0
                ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
                : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
            e.normal.y > 0
                ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
                : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
            e.normal.z > 0
                ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
                : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
            t <= -e.constant && i >= -e.constant
        );
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(lc),
            ph.subVectors(this.max, lc),
            pl.subVectors(e.a, lc),
            ml.subVectors(e.b, lc),
            gl.subVectors(e.c, lc),
            oo.subVectors(ml, pl),
            ao.subVectors(gl, ml),
            ia.subVectors(pl, gl);
        let t = [
            0,
            -oo.z,
            oo.y,
            0,
            -ao.z,
            ao.y,
            0,
            -ia.z,
            ia.y,
            oo.z,
            0,
            -oo.x,
            ao.z,
            0,
            -ao.x,
            ia.z,
            0,
            -ia.x,
            -oo.y,
            oo.x,
            0,
            -ao.y,
            ao.x,
            0,
            -ia.y,
            ia.x,
            0,
        ];
        return !kv(t, pl, ml, gl, ph) || ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !kv(t, pl, ml, gl, ph))
            ? !1
            : (mh.crossVectors(oo, ao), (t = [mh.x, mh.y, mh.z]), kv(t, pl, ml, gl, ph));
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Pr).distanceTo(e);
    }
    getBoundingSphere(e) {
        return (
            this.isEmpty()
                ? e.makeEmpty()
                : (this.getCenter(e.center), (e.radius = this.getSize(Pr).length() * 0.5)),
            e
        );
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
        return this.isEmpty()
            ? this
            : (Ms[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Ms[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Ms[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Ms[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Ms[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Ms[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Ms[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Ms[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Ms),
              this);
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
    }
}
const Ms = [new k(), new k(), new k(), new k(), new k(), new k(), new k(), new k()],
    Pr = new k(),
    hh = new Ci(),
    pl = new k(),
    ml = new k(),
    gl = new k(),
    oo = new k(),
    ao = new k(),
    ia = new k(),
    lc = new k(),
    ph = new k(),
    mh = new k(),
    ra = new k();
function kv(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        ra.fromArray(n, s);
        const a = r.x * Math.abs(ra.x) + r.y * Math.abs(ra.y) + r.z * Math.abs(ra.z),
            c = e.dot(ra),
            f = t.dot(ra),
            d = i.dot(ra);
        if (Math.max(-Math.max(c, f, d), Math.min(c, f, d)) > a) return !1;
    }
    return !0;
}
const $N = new Ci(),
    uc = new k(),
    zv = new k();
class mi {
    constructor(e = new k(), t = -1) {
        (this.isSphere = !0), (this.center = e), (this.radius = t);
    }
    set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : $N.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]));
        return (this.radius = Math.sqrt(r)), this;
    }
    copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
        return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return (
            t.copy(e),
            i > this.radius * this.radius &&
                (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)),
            t
        );
    }
    getBoundingBox(e) {
        return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
        return (
            this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this
        );
    }
    translate(e) {
        return this.center.add(e), this;
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
        uc.subVectors(e, this.center);
        const t = uc.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
                r = (i - this.radius) * 0.5;
            this.center.addScaledVector(uc, r / i), (this.radius += r);
        }
        return this;
    }
    union(e) {
        return e.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(e), this)
            : (this.center.equals(e.center) === !0
                  ? (this.radius = Math.max(this.radius, e.radius))
                  : (zv.subVectors(e.center, this.center).setLength(e.radius),
                    this.expandByPoint(uc.copy(e.center).add(zv)),
                    this.expandByPoint(uc.copy(e.center).sub(zv))),
              this);
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const ws = new k(),
    Bv = new k(),
    gh = new k(),
    lo = new k(),
    Hv = new k(),
    vh = new k(),
    Vv = new k();
class bu {
    constructor(e = new k(), t = new k(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e);
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
        return this.origin.copy(this.at(e, ws)), this;
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
        const t = ws.subVectors(e, this.origin).dot(this.direction);
        return t < 0
            ? this.origin.distanceToSquared(e)
            : (ws.copy(this.origin).addScaledVector(this.direction, t), ws.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, i, r) {
        Bv.copy(e).add(t).multiplyScalar(0.5),
            gh.copy(t).sub(e).normalize(),
            lo.copy(this.origin).sub(Bv);
        const s = e.distanceTo(t) * 0.5,
            o = -this.direction.dot(gh),
            a = lo.dot(this.direction),
            c = -lo.dot(gh),
            f = lo.lengthSq(),
            d = Math.abs(1 - o * o);
        let h, p, v, _;
        if (d > 0)
            if (((h = o * c - a), (p = o * a - c), (_ = s * d), h >= 0))
                if (p >= -_)
                    if (p <= _) {
                        const w = 1 / d;
                        (h *= w),
                            (p *= w),
                            (v = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * c) + f);
                    } else
                        (p = s),
                            (h = Math.max(0, -(o * p + a))),
                            (v = -h * h + p * (p + 2 * c) + f);
                else (p = -s), (h = Math.max(0, -(o * p + a))), (v = -h * h + p * (p + 2 * c) + f);
            else
                p <= -_
                    ? ((h = Math.max(0, -(-o * s + a))),
                      (p = h > 0 ? -s : Math.min(Math.max(-s, -c), s)),
                      (v = -h * h + p * (p + 2 * c) + f))
                    : p <= _
                    ? ((h = 0), (p = Math.min(Math.max(-s, -c), s)), (v = p * (p + 2 * c) + f))
                    : ((h = Math.max(0, -(o * s + a))),
                      (p = h > 0 ? s : Math.min(Math.max(-s, -c), s)),
                      (v = -h * h + p * (p + 2 * c) + f));
        else
            (p = o > 0 ? -s : s),
                (h = Math.max(0, -(o * p + a))),
                (v = -h * h + p * (p + 2 * c) + f);
        return (
            i && i.copy(this.origin).addScaledVector(this.direction, h),
            r && r.copy(Bv).addScaledVector(gh, p),
            v
        );
    }
    intersectSphere(e, t) {
        ws.subVectors(e.center, this.origin);
        const i = ws.dot(this.direction),
            r = ws.dot(ws) - i * i,
            s = e.radius * e.radius;
        if (r > s) return null;
        const o = Math.sqrt(s - r),
            a = i - o,
            c = i + o;
        return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t);
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null;
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t);
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
        let i, r, s, o, a, c;
        const f = 1 / this.direction.x,
            d = 1 / this.direction.y,
            h = 1 / this.direction.z,
            p = this.origin;
        return (
            f >= 0
                ? ((i = (e.min.x - p.x) * f), (r = (e.max.x - p.x) * f))
                : ((i = (e.max.x - p.x) * f), (r = (e.min.x - p.x) * f)),
            d >= 0
                ? ((s = (e.min.y - p.y) * d), (o = (e.max.y - p.y) * d))
                : ((s = (e.max.y - p.y) * d), (o = (e.min.y - p.y) * d)),
            i > o ||
            s > r ||
            ((s > i || isNaN(i)) && (i = s),
            (o < r || isNaN(r)) && (r = o),
            h >= 0
                ? ((a = (e.min.z - p.z) * h), (c = (e.max.z - p.z) * h))
                : ((a = (e.max.z - p.z) * h), (c = (e.min.z - p.z) * h)),
            i > c || a > r) ||
            ((a > i || i !== i) && (i = a), (c < r || r !== r) && (r = c), r < 0)
                ? null
                : this.at(i >= 0 ? i : r, t)
        );
    }
    intersectsBox(e) {
        return this.intersectBox(e, ws) !== null;
    }
    intersectTriangle(e, t, i, r, s) {
        Hv.subVectors(t, e), vh.subVectors(i, e), Vv.crossVectors(Hv, vh);
        let o = this.direction.dot(Vv),
            a;
        if (o > 0) {
            if (r) return null;
            a = 1;
        } else if (o < 0) (a = -1), (o = -o);
        else return null;
        lo.subVectors(this.origin, e);
        const c = a * this.direction.dot(vh.crossVectors(lo, vh));
        if (c < 0) return null;
        const f = a * this.direction.dot(Hv.cross(lo));
        if (f < 0 || c + f > o) return null;
        const d = -a * lo.dot(Vv);
        return d < 0 ? null : this.at(d / o, s);
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class ft {
    constructor(e, t, i, r, s, o, a, c, f, d, h, p, v, _, w, x) {
        (ft.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            e !== void 0 && this.set(e, t, i, r, s, o, a, c, f, d, h, p, v, _, w, x);
    }
    set(e, t, i, r, s, o, a, c, f, d, h, p, v, _, w, x) {
        const g = this.elements;
        return (
            (g[0] = e),
            (g[4] = t),
            (g[8] = i),
            (g[12] = r),
            (g[1] = s),
            (g[5] = o),
            (g[9] = a),
            (g[13] = c),
            (g[2] = f),
            (g[6] = d),
            (g[10] = h),
            (g[14] = p),
            (g[3] = v),
            (g[7] = _),
            (g[11] = w),
            (g[15] = x),
            this
        );
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
        return new ft().fromArray(this.elements);
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            (t[9] = i[9]),
            (t[10] = i[10]),
            (t[11] = i[11]),
            (t[12] = i[12]),
            (t[13] = i[13]),
            (t[14] = i[14]),
            (t[15] = i[15]),
            this
        );
    }
    copyPosition(e) {
        const t = this.elements,
            i = e.elements;
        return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return (
            this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
            this
        );
    }
    extractBasis(e, t, i) {
        return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
        );
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e) {
        const t = this.elements,
            i = e.elements,
            r = 1 / vl.setFromMatrixColumn(e, 0).length(),
            s = 1 / vl.setFromMatrixColumn(e, 1).length(),
            o = 1 / vl.setFromMatrixColumn(e, 2).length();
        return (
            (t[0] = i[0] * r),
            (t[1] = i[1] * r),
            (t[2] = i[2] * r),
            (t[3] = 0),
            (t[4] = i[4] * s),
            (t[5] = i[5] * s),
            (t[6] = i[6] * s),
            (t[7] = 0),
            (t[8] = i[8] * o),
            (t[9] = i[9] * o),
            (t[10] = i[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
        );
    }
    makeRotationFromEuler(e) {
        const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z,
            o = Math.cos(i),
            a = Math.sin(i),
            c = Math.cos(r),
            f = Math.sin(r),
            d = Math.cos(s),
            h = Math.sin(s);
        if (e.order === 'XYZ') {
            const p = o * d,
                v = o * h,
                _ = a * d,
                w = a * h;
            (t[0] = c * d),
                (t[4] = -c * h),
                (t[8] = f),
                (t[1] = v + _ * f),
                (t[5] = p - w * f),
                (t[9] = -a * c),
                (t[2] = w - p * f),
                (t[6] = _ + v * f),
                (t[10] = o * c);
        } else if (e.order === 'YXZ') {
            const p = c * d,
                v = c * h,
                _ = f * d,
                w = f * h;
            (t[0] = p + w * a),
                (t[4] = _ * a - v),
                (t[8] = o * f),
                (t[1] = o * h),
                (t[5] = o * d),
                (t[9] = -a),
                (t[2] = v * a - _),
                (t[6] = w + p * a),
                (t[10] = o * c);
        } else if (e.order === 'ZXY') {
            const p = c * d,
                v = c * h,
                _ = f * d,
                w = f * h;
            (t[0] = p - w * a),
                (t[4] = -o * h),
                (t[8] = _ + v * a),
                (t[1] = v + _ * a),
                (t[5] = o * d),
                (t[9] = w - p * a),
                (t[2] = -o * f),
                (t[6] = a),
                (t[10] = o * c);
        } else if (e.order === 'ZYX') {
            const p = o * d,
                v = o * h,
                _ = a * d,
                w = a * h;
            (t[0] = c * d),
                (t[4] = _ * f - v),
                (t[8] = p * f + w),
                (t[1] = c * h),
                (t[5] = w * f + p),
                (t[9] = v * f - _),
                (t[2] = -f),
                (t[6] = a * c),
                (t[10] = o * c);
        } else if (e.order === 'YZX') {
            const p = o * c,
                v = o * f,
                _ = a * c,
                w = a * f;
            (t[0] = c * d),
                (t[4] = w - p * h),
                (t[8] = _ * h + v),
                (t[1] = h),
                (t[5] = o * d),
                (t[9] = -a * d),
                (t[2] = -f * d),
                (t[6] = v * h + _),
                (t[10] = p - w * h);
        } else if (e.order === 'XZY') {
            const p = o * c,
                v = o * f,
                _ = a * c,
                w = a * f;
            (t[0] = c * d),
                (t[4] = -h),
                (t[8] = f * d),
                (t[1] = p * h + w),
                (t[5] = o * d),
                (t[9] = v * h - _),
                (t[2] = _ * h - v),
                (t[6] = a * d),
                (t[10] = w * h + p);
        }
        return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
        );
    }
    makeRotationFromQuaternion(e) {
        return this.compose(eD, e, tD);
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return (
            Yi.subVectors(e, t),
            Yi.lengthSq() === 0 && (Yi.z = 1),
            Yi.normalize(),
            uo.crossVectors(i, Yi),
            uo.lengthSq() === 0 &&
                (Math.abs(i.z) === 1 ? (Yi.x += 1e-4) : (Yi.z += 1e-4),
                Yi.normalize(),
                uo.crossVectors(i, Yi)),
            uo.normalize(),
            _h.crossVectors(Yi, uo),
            (r[0] = uo.x),
            (r[4] = _h.x),
            (r[8] = Yi.x),
            (r[1] = uo.y),
            (r[5] = _h.y),
            (r[9] = Yi.y),
            (r[2] = uo.z),
            (r[6] = _h.z),
            (r[10] = Yi.z),
            this
        );
    }
    multiply(e) {
        return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[4],
            c = i[8],
            f = i[12],
            d = i[1],
            h = i[5],
            p = i[9],
            v = i[13],
            _ = i[2],
            w = i[6],
            x = i[10],
            g = i[14],
            S = i[3],
            M = i[7],
            T = i[11],
            P = i[15],
            A = r[0],
            R = r[4],
            D = r[8],
            G = r[12],
            b = r[1],
            L = r[5],
            ee = r[9],
            ie = r[13],
            j = r[2],
            oe = r[6],
            te = r[10],
            ae = r[14],
            N = r[3],
            B = r[7],
            H = r[11],
            K = r[15];
        return (
            (s[0] = o * A + a * b + c * j + f * N),
            (s[4] = o * R + a * L + c * oe + f * B),
            (s[8] = o * D + a * ee + c * te + f * H),
            (s[12] = o * G + a * ie + c * ae + f * K),
            (s[1] = d * A + h * b + p * j + v * N),
            (s[5] = d * R + h * L + p * oe + v * B),
            (s[9] = d * D + h * ee + p * te + v * H),
            (s[13] = d * G + h * ie + p * ae + v * K),
            (s[2] = _ * A + w * b + x * j + g * N),
            (s[6] = _ * R + w * L + x * oe + g * B),
            (s[10] = _ * D + w * ee + x * te + g * H),
            (s[14] = _ * G + w * ie + x * ae + g * K),
            (s[3] = S * A + M * b + T * j + P * N),
            (s[7] = S * R + M * L + T * oe + P * B),
            (s[11] = S * D + M * ee + T * te + P * H),
            (s[15] = S * G + M * ie + T * ae + P * K),
            this
        );
    }
    multiplyScalar(e) {
        const t = this.elements;
        return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
        );
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[4],
            r = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            c = e[9],
            f = e[13],
            d = e[2],
            h = e[6],
            p = e[10],
            v = e[14],
            _ = e[3],
            w = e[7],
            x = e[11],
            g = e[15];
        return (
            _ * (+s * c * h - r * f * h - s * a * p + i * f * p + r * a * v - i * c * v) +
            w * (+t * c * v - t * f * p + s * o * p - r * o * v + r * f * d - s * c * d) +
            x * (+t * f * h - t * a * v - s * o * h + i * o * v + s * a * d - i * f * d) +
            g * (-r * a * d - t * c * h + t * a * p + r * o * h - i * o * p + i * c * d)
        );
    }
    transpose() {
        const e = this.elements;
        let t;
        return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
        );
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return (
            e.isVector3
                ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
                : ((r[12] = e), (r[13] = t), (r[14] = i)),
            this
        );
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            c = e[6],
            f = e[7],
            d = e[8],
            h = e[9],
            p = e[10],
            v = e[11],
            _ = e[12],
            w = e[13],
            x = e[14],
            g = e[15],
            S = h * x * f - w * p * f + w * c * v - a * x * v - h * c * g + a * p * g,
            M = _ * p * f - d * x * f - _ * c * v + o * x * v + d * c * g - o * p * g,
            T = d * w * f - _ * h * f + _ * a * v - o * w * v - d * a * g + o * h * g,
            P = _ * h * c - d * w * c - _ * a * p + o * w * p + d * a * x - o * h * x,
            A = t * S + i * M + r * T + s * P;
        if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / A;
        return (
            (e[0] = S * R),
            (e[1] = (w * p * s - h * x * s - w * r * v + i * x * v + h * r * g - i * p * g) * R),
            (e[2] = (a * x * s - w * c * s + w * r * f - i * x * f - a * r * g + i * c * g) * R),
            (e[3] = (h * c * s - a * p * s - h * r * f + i * p * f + a * r * v - i * c * v) * R),
            (e[4] = M * R),
            (e[5] = (d * x * s - _ * p * s + _ * r * v - t * x * v - d * r * g + t * p * g) * R),
            (e[6] = (_ * c * s - o * x * s - _ * r * f + t * x * f + o * r * g - t * c * g) * R),
            (e[7] = (o * p * s - d * c * s + d * r * f - t * p * f - o * r * v + t * c * v) * R),
            (e[8] = T * R),
            (e[9] = (_ * h * s - d * w * s - _ * i * v + t * w * v + d * i * g - t * h * g) * R),
            (e[10] = (o * w * s - _ * a * s + _ * i * f - t * w * f - o * i * g + t * a * g) * R),
            (e[11] = (d * a * s - o * h * s - d * i * f + t * h * f + o * i * v - t * a * v) * R),
            (e[12] = P * R),
            (e[13] = (d * w * r - _ * h * r + _ * i * p - t * w * p - d * i * x + t * h * x) * R),
            (e[14] = (_ * a * r - o * w * r - _ * i * c + t * w * c + o * i * x - t * a * x) * R),
            (e[15] = (o * h * r - d * a * r + d * i * c - t * h * c - o * i * p + t * a * p) * R),
            this
        );
    }
    scale(e) {
        const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z;
        return (
            (t[0] *= i),
            (t[4] *= r),
            (t[8] *= s),
            (t[1] *= i),
            (t[5] *= r),
            (t[9] *= s),
            (t[2] *= i),
            (t[6] *= r),
            (t[10] *= s),
            (t[3] *= i),
            (t[7] *= r),
            (t[11] *= s),
            this
        );
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r));
    }
    makeTranslation(e, t, i) {
        return (
            e.isVector3
                ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
                : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
            this
        );
    }
    makeRotationX(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t),
            r = Math.sin(t),
            s = 1 - i,
            o = e.x,
            a = e.y,
            c = e.z,
            f = s * o,
            d = s * a;
        return (
            this.set(
                f * o + i,
                f * a - r * c,
                f * c + r * a,
                0,
                f * a + r * c,
                d * a + i,
                d * c - r * o,
                0,
                f * c - r * a,
                d * c + r * o,
                s * c * c + i,
                0,
                0,
                0,
                0,
                1
            ),
            this
        );
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, i) {
        const r = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            c = t._w,
            f = s + s,
            d = o + o,
            h = a + a,
            p = s * f,
            v = s * d,
            _ = s * h,
            w = o * d,
            x = o * h,
            g = a * h,
            S = c * f,
            M = c * d,
            T = c * h,
            P = i.x,
            A = i.y,
            R = i.z;
        return (
            (r[0] = (1 - (w + g)) * P),
            (r[1] = (v + T) * P),
            (r[2] = (_ - M) * P),
            (r[3] = 0),
            (r[4] = (v - T) * A),
            (r[5] = (1 - (p + g)) * A),
            (r[6] = (x + S) * A),
            (r[7] = 0),
            (r[8] = (_ + M) * R),
            (r[9] = (x - S) * R),
            (r[10] = (1 - (p + w)) * R),
            (r[11] = 0),
            (r[12] = e.x),
            (r[13] = e.y),
            (r[14] = e.z),
            (r[15] = 1),
            this
        );
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = vl.set(r[0], r[1], r[2]).length();
        const o = vl.set(r[4], r[5], r[6]).length(),
            a = vl.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
            (e.x = r[12]),
            (e.y = r[13]),
            (e.z = r[14]),
            Lr.copy(this);
        const f = 1 / s,
            d = 1 / o,
            h = 1 / a;
        return (
            (Lr.elements[0] *= f),
            (Lr.elements[1] *= f),
            (Lr.elements[2] *= f),
            (Lr.elements[4] *= d),
            (Lr.elements[5] *= d),
            (Lr.elements[6] *= d),
            (Lr.elements[8] *= h),
            (Lr.elements[9] *= h),
            (Lr.elements[10] *= h),
            t.setFromRotationMatrix(Lr),
            (i.x = s),
            (i.y = o),
            (i.z = a),
            this
        );
    }
    makePerspective(e, t, i, r, s, o, a = ls) {
        const c = this.elements,
            f = (2 * s) / (t - e),
            d = (2 * s) / (i - r),
            h = (t + e) / (t - e),
            p = (i + r) / (i - r);
        let v, _;
        if (a === ls) (v = -(o + s) / (o - s)), (_ = (-2 * o * s) / (o - s));
        else if (a === Mf) (v = -o / (o - s)), (_ = (-o * s) / (o - s));
        else throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + a);
        return (
            (c[0] = f),
            (c[4] = 0),
            (c[8] = h),
            (c[12] = 0),
            (c[1] = 0),
            (c[5] = d),
            (c[9] = p),
            (c[13] = 0),
            (c[2] = 0),
            (c[6] = 0),
            (c[10] = v),
            (c[14] = _),
            (c[3] = 0),
            (c[7] = 0),
            (c[11] = -1),
            (c[15] = 0),
            this
        );
    }
    makeOrthographic(e, t, i, r, s, o, a = ls) {
        const c = this.elements,
            f = 1 / (t - e),
            d = 1 / (i - r),
            h = 1 / (o - s),
            p = (t + e) * f,
            v = (i + r) * d;
        let _, w;
        if (a === ls) (_ = (o + s) * h), (w = -2 * h);
        else if (a === Mf) (_ = s * h), (w = -1 * h);
        else throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + a);
        return (
            (c[0] = 2 * f),
            (c[4] = 0),
            (c[8] = 0),
            (c[12] = -p),
            (c[1] = 0),
            (c[5] = 2 * d),
            (c[9] = 0),
            (c[13] = -v),
            (c[2] = 0),
            (c[6] = 0),
            (c[10] = w),
            (c[14] = -_),
            (c[3] = 0),
            (c[7] = 0),
            (c[11] = 0),
            (c[15] = 1),
            this
        );
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this;
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            (e[t + 9] = i[9]),
            (e[t + 10] = i[10]),
            (e[t + 11] = i[11]),
            (e[t + 12] = i[12]),
            (e[t + 13] = i[13]),
            (e[t + 14] = i[14]),
            (e[t + 15] = i[15]),
            e
        );
    }
}
const vl = new k(),
    Lr = new ft(),
    eD = new k(0, 0, 0),
    tD = new k(1, 1, 1),
    uo = new k(),
    _h = new k(),
    Yi = new k(),
    iw = new ft(),
    rw = new Bi();
class nr {
    constructor(e = 0, t = 0, i = 0, r = nr.DEFAULT_ORDER) {
        (this.isEuler = !0), (this._x = e), (this._y = t), (this._z = i), (this._order = r);
    }
    get x() {
        return this._x;
    }
    set x(e) {
        (this._x = e), this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        (this._y = e), this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        (this._z = e), this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(e) {
        (this._order = e), this._onChangeCallback();
    }
    set(e, t, i, r = this._order) {
        return (
            (this._x = e),
            (this._y = t),
            (this._z = i),
            (this._order = r),
            this._onChangeCallback(),
            this
        );
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
        return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
        );
    }
    setFromRotationMatrix(e, t = this._order, i = !0) {
        const r = e.elements,
            s = r[0],
            o = r[4],
            a = r[8],
            c = r[1],
            f = r[5],
            d = r[9],
            h = r[2],
            p = r[6],
            v = r[10];
        switch (t) {
            case 'XYZ':
                (this._y = Math.asin(wn(a, -1, 1))),
                    Math.abs(a) < 0.9999999
                        ? ((this._x = Math.atan2(-d, v)), (this._z = Math.atan2(-o, s)))
                        : ((this._x = Math.atan2(p, f)), (this._z = 0));
                break;
            case 'YXZ':
                (this._x = Math.asin(-wn(d, -1, 1))),
                    Math.abs(d) < 0.9999999
                        ? ((this._y = Math.atan2(a, v)), (this._z = Math.atan2(c, f)))
                        : ((this._y = Math.atan2(-h, s)), (this._z = 0));
                break;
            case 'ZXY':
                (this._x = Math.asin(wn(p, -1, 1))),
                    Math.abs(p) < 0.9999999
                        ? ((this._y = Math.atan2(-h, v)), (this._z = Math.atan2(-o, f)))
                        : ((this._y = 0), (this._z = Math.atan2(c, s)));
                break;
            case 'ZYX':
                (this._y = Math.asin(-wn(h, -1, 1))),
                    Math.abs(h) < 0.9999999
                        ? ((this._x = Math.atan2(p, v)), (this._z = Math.atan2(c, s)))
                        : ((this._x = 0), (this._z = Math.atan2(-o, f)));
                break;
            case 'YZX':
                (this._z = Math.asin(wn(c, -1, 1))),
                    Math.abs(c) < 0.9999999
                        ? ((this._x = Math.atan2(-d, f)), (this._y = Math.atan2(-h, s)))
                        : ((this._x = 0), (this._y = Math.atan2(a, v)));
                break;
            case 'XZY':
                (this._z = Math.asin(-wn(o, -1, 1))),
                    Math.abs(o) < 0.9999999
                        ? ((this._x = Math.atan2(p, f)), (this._y = Math.atan2(a, s)))
                        : ((this._x = Math.atan2(-d, v)), (this._y = 0));
                break;
            default:
                console.warn(
                    'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + t
                );
        }
        return (this._order = t), i === !0 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, i) {
        return iw.makeRotationFromQuaternion(e), this.setFromRotationMatrix(iw, t, i);
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
        return rw.setFromEuler(this), this.setFromQuaternion(rw, e);
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
    }
    fromArray(e) {
        return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
        );
    }
    _onChange(e) {
        return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
    }
}
nr.DEFAULT_ORDER = 'XYZ';
class Da {
    constructor() {
        this.mask = 1;
    }
    set(e) {
        this.mask = ((1 << e) | 0) >>> 0;
    }
    enable(e) {
        this.mask |= (1 << e) | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(e) {
        this.mask ^= (1 << e) | 0;
    }
    disable(e) {
        this.mask &= ~((1 << e) | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(e) {
        return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
        return (this.mask & ((1 << e) | 0)) !== 0;
    }
}
let nD = 0;
const sw = new k(),
    _l = new Bi(),
    Es = new ft(),
    yh = new k(),
    cc = new k(),
    iD = new k(),
    rD = new Bi(),
    ow = new k(1, 0, 0),
    aw = new k(0, 1, 0),
    lw = new k(0, 0, 1),
    sD = { type: 'added' },
    oD = { type: 'removed' },
    Gv = { type: 'childadded', child: null },
    Wv = { type: 'childremoved', child: null };
class Ht extends qs {
    constructor() {
        super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, 'id', { value: nD++ }),
            (this.uuid = er()),
            (this.name = ''),
            (this.type = 'Object3D'),
            (this.parent = null),
            (this.children = []),
            (this.up = Ht.DEFAULT_UP.clone());
        const e = new k(),
            t = new nr(),
            i = new Bi(),
            r = new k(1, 1, 1);
        function s() {
            i.setFromEuler(t, !1);
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1);
        }
        t._onChange(s),
            i._onChange(o),
            Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: e },
                rotation: { configurable: !0, enumerable: !0, value: t },
                quaternion: { configurable: !0, enumerable: !0, value: i },
                scale: { configurable: !0, enumerable: !0, value: r },
                modelViewMatrix: { value: new ft() },
                normalMatrix: { value: new Et() },
            }),
            (this.matrix = new ft()),
            (this.matrixWorld = new ft()),
            (this.matrixAutoUpdate = Ht.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate = Ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Da()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
        return _l.setFromAxisAngle(e, t), this.quaternion.multiply(_l), this;
    }
    rotateOnWorldAxis(e, t) {
        return _l.setFromAxisAngle(e, t), this.quaternion.premultiply(_l), this;
    }
    rotateX(e) {
        return this.rotateOnAxis(ow, e);
    }
    rotateY(e) {
        return this.rotateOnAxis(aw, e);
    }
    rotateZ(e) {
        return this.rotateOnAxis(lw, e);
    }
    translateOnAxis(e, t) {
        return (
            sw.copy(e).applyQuaternion(this.quaternion),
            this.position.add(sw.multiplyScalar(t)),
            this
        );
    }
    translateX(e) {
        return this.translateOnAxis(ow, e);
    }
    translateY(e) {
        return this.translateOnAxis(aw, e);
    }
    translateZ(e) {
        return this.translateOnAxis(lw, e);
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Es.copy(this.matrixWorld).invert());
    }
    lookAt(e, t, i) {
        e.isVector3 ? yh.copy(e) : yh.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
            cc.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? Es.lookAt(cc, yh, this.up) : Es.lookAt(yh, cc, this.up),
            this.quaternion.setFromRotationMatrix(Es),
            r &&
                (Es.extractRotation(r.matrixWorld),
                _l.setFromRotationMatrix(Es),
                this.quaternion.premultiply(_l.invert()));
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
        }
        return e === this
            ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
              this)
            : (e && e.isObject3D
                  ? (e.parent !== null && e.parent.remove(e),
                    (e.parent = this),
                    this.children.push(e),
                    e.dispatchEvent(sD),
                    (Gv.child = e),
                    this.dispatchEvent(Gv),
                    (Gv.child = null))
                  : console.error(
                        'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                        e
                    ),
              this);
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
        }
        const t = this.children.indexOf(e);
        return (
            t !== -1 &&
                ((e.parent = null),
                this.children.splice(t, 1),
                e.dispatchEvent(oD),
                (Wv.child = e),
                this.dispatchEvent(Wv),
                (Wv.child = null)),
            this
        );
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this;
    }
    clear() {
        return this.remove(...this.children);
    }
    attach(e) {
        return (
            this.updateWorldMatrix(!0, !1),
            Es.copy(this.matrixWorld).invert(),
            e.parent !== null &&
                (e.parent.updateWorldMatrix(!0, !1), Es.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Es),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
        );
    }
    getObjectById(e) {
        return this.getObjectByProperty('id', e);
    }
    getObjectByName(e) {
        return this.getObjectByProperty('name', e);
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0) return o;
        }
    }
    getObjectsByProperty(e, t, i = []) {
        this[e] === t && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i);
        return i;
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cc, e, iD), e;
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cc, rD, e), e;
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
                (this.parent === null
                    ? this.matrixWorld.copy(this.matrix)
                    : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                (this.matrixWorldNeedsUpdate = !1),
                (e = !0));
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (
            (e === !0 &&
                i !== null &&
                i.matrixWorldAutoUpdate === !0 &&
                i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            t === !0)
        ) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string',
            i = {};
        t &&
            ((e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
            }),
            (i.metadata = { version: 4.6, type: 'Object', generator: 'Object3D.toJSON' }));
        const r = {};
        (r.uuid = this.uuid),
            (r.type = this.type),
            this.name !== '' && (r.name = this.name),
            this.castShadow === !0 && (r.castShadow = !0),
            this.receiveShadow === !0 && (r.receiveShadow = !0),
            this.visible === !1 && (r.visible = !1),
            this.frustumCulled === !1 && (r.frustumCulled = !1),
            this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 && (r.userData = this.userData),
            (r.layers = this.layers.mask),
            (r.matrix = this.matrix.toArray()),
            (r.up = this.up.toArray()),
            this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
                ((r.type = 'InstancedMesh'),
                (r.count = this.count),
                (r.instanceMatrix = this.instanceMatrix.toJSON()),
                this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
                ((r.type = 'BatchedMesh'),
                (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
                (r.sortObjects = this.sortObjects),
                (r.drawRanges = this._drawRanges),
                (r.reservedRanges = this._reservedRanges),
                (r.visibility = this._visibility),
                (r.active = this._active),
                (r.bounds = this._bounds.map((a) => ({
                    boxInitialized: a.boxInitialized,
                    boxMin: a.box.min.toArray(),
                    boxMax: a.box.max.toArray(),
                    sphereInitialized: a.sphereInitialized,
                    sphereRadius: a.sphere.radius,
                    sphereCenter: a.sphere.center.toArray(),
                }))),
                (r.maxGeometryCount = this._maxGeometryCount),
                (r.maxVertexCount = this._maxVertexCount),
                (r.maxIndexCount = this._maxIndexCount),
                (r.geometryInitialized = this._geometryInitialized),
                (r.geometryCount = this._geometryCount),
                (r.matricesTexture = this._matricesTexture.toJSON(e)),
                this.boundingSphere !== null &&
                    (r.boundingSphere = {
                        center: r.boundingSphere.center.toArray(),
                        radius: r.boundingSphere.radius,
                    }),
                this.boundingBox !== null &&
                    (r.boundingBox = {
                        min: r.boundingBox.min.toArray(),
                        max: r.boundingBox.max.toArray(),
                    }));
        function s(a, c) {
            return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)), c.uuid;
        }
        if (this.isScene)
            this.background &&
                (this.background.isColor
                    ? (r.background = this.background.toJSON())
                    : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
                this.environment &&
                    this.environment.isTexture &&
                    this.environment.isRenderTargetTexture !== !0 &&
                    (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const c = a.shapes;
                if (Array.isArray(c))
                    for (let f = 0, d = c.length; f < d; f++) {
                        const h = c[f];
                        s(e.shapes, h);
                    }
                else s(e.shapes, c);
            }
        }
        if (
            (this.isSkinnedMesh &&
                ((r.bindMode = this.bindMode),
                (r.bindMatrix = this.bindMatrix.toArray()),
                this.skeleton !== void 0 &&
                    (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
        )
            if (Array.isArray(this.material)) {
                const a = [];
                for (let c = 0, f = this.material.length; c < f; c++)
                    a.push(s(e.materials, this.material[c]));
                r.material = a;
            } else r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object);
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const c = this.animations[a];
                r.animations.push(s(e.animations, c));
            }
        }
        if (t) {
            const a = o(e.geometries),
                c = o(e.materials),
                f = o(e.textures),
                d = o(e.images),
                h = o(e.shapes),
                p = o(e.skeletons),
                v = o(e.animations),
                _ = o(e.nodes);
            a.length > 0 && (i.geometries = a),
                c.length > 0 && (i.materials = c),
                f.length > 0 && (i.textures = f),
                d.length > 0 && (i.images = d),
                h.length > 0 && (i.shapes = h),
                p.length > 0 && (i.skeletons = p),
                v.length > 0 && (i.animations = v),
                _.length > 0 && (i.nodes = _);
        }
        return (i.object = r), i;
        function o(a) {
            const c = [];
            for (const f in a) {
                const d = a[f];
                delete d.metadata, c.push(d);
            }
            return c;
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e);
    }
    copy(e, t = !0) {
        if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.animations = e.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
        )
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone());
            }
        return this;
    }
}
Ht.DEFAULT_UP = new k(0, 1, 0);
Ht.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ir = new k(),
    Ts = new k(),
    jv = new k(),
    As = new k(),
    yl = new k(),
    xl = new k(),
    uw = new k(),
    Xv = new k(),
    Yv = new k(),
    qv = new k();
class Ji {
    constructor(e = new k(), t = new k(), i = new k()) {
        (this.a = e), (this.b = t), (this.c = i);
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t), Ir.subVectors(e, t), r.cross(Ir);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
    }
    static getBarycoord(e, t, i, r, s) {
        Ir.subVectors(r, t), Ts.subVectors(i, t), jv.subVectors(e, t);
        const o = Ir.dot(Ir),
            a = Ir.dot(Ts),
            c = Ir.dot(jv),
            f = Ts.dot(Ts),
            d = Ts.dot(jv),
            h = o * f - a * a;
        if (h === 0) return s.set(0, 0, 0), null;
        const p = 1 / h,
            v = (f * c - a * d) * p,
            _ = (o * d - a * c) * p;
        return s.set(1 - v - _, _, v);
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, As) === null
            ? !1
            : As.x >= 0 && As.y >= 0 && As.x + As.y <= 1;
    }
    static getInterpolation(e, t, i, r, s, o, a, c) {
        return this.getBarycoord(e, t, i, r, As) === null
            ? ((c.x = 0), (c.y = 0), 'z' in c && (c.z = 0), 'w' in c && (c.w = 0), null)
            : (c.setScalar(0),
              c.addScaledVector(s, As.x),
              c.addScaledVector(o, As.y),
              c.addScaledVector(a, As.z),
              c);
    }
    static isFrontFacing(e, t, i, r) {
        return Ir.subVectors(i, t), Ts.subVectors(e, t), Ir.cross(Ts).dot(r) < 0;
    }
    set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, i),
            this.c.fromBufferAttribute(e, r),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
        return (
            Ir.subVectors(this.c, this.b),
            Ts.subVectors(this.a, this.b),
            Ir.cross(Ts).length() * 0.5
        );
    }
    getMidpoint(e) {
        return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
    }
    getNormal(e) {
        return Ji.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
        return Ji.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getInterpolation(e, t, i, r, s) {
        return Ji.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
    }
    containsPoint(e) {
        return Ji.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
        return Ji.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
        const i = this.a,
            r = this.b,
            s = this.c;
        let o, a;
        yl.subVectors(r, i), xl.subVectors(s, i), Xv.subVectors(e, i);
        const c = yl.dot(Xv),
            f = xl.dot(Xv);
        if (c <= 0 && f <= 0) return t.copy(i);
        Yv.subVectors(e, r);
        const d = yl.dot(Yv),
            h = xl.dot(Yv);
        if (d >= 0 && h <= d) return t.copy(r);
        const p = c * h - d * f;
        if (p <= 0 && c >= 0 && d <= 0) return (o = c / (c - d)), t.copy(i).addScaledVector(yl, o);
        qv.subVectors(e, s);
        const v = yl.dot(qv),
            _ = xl.dot(qv);
        if (_ >= 0 && v <= _) return t.copy(s);
        const w = v * f - c * _;
        if (w <= 0 && f >= 0 && _ <= 0) return (a = f / (f - _)), t.copy(i).addScaledVector(xl, a);
        const x = d * _ - v * h;
        if (x <= 0 && h - d >= 0 && v - _ >= 0)
            return (
                uw.subVectors(s, r),
                (a = (h - d) / (h - d + (v - _))),
                t.copy(r).addScaledVector(uw, a)
            );
        const g = 1 / (x + w + p);
        return (o = w * g), (a = p * g), t.copy(i).addScaledVector(yl, o).addScaledVector(xl, a);
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
}
const UC = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
    },
    co = { h: 0, s: 0, l: 0 },
    xh = { h: 0, s: 0, l: 0 };
function Zv(n, e, t) {
    return (
        t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6
            ? n + (e - n) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? n + (e - n) * 6 * (2 / 3 - t)
            : n
    );
}
class je {
    constructor(e, t, i) {
        return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(e, t, i);
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor
                ? this.copy(r)
                : typeof r == 'number'
                ? this.setHex(r)
                : typeof r == 'string' && this.setStyle(r);
        } else this.setRGB(e, t, i);
        return this;
    }
    setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
    }
    setHex(e, t = _r) {
        return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            Gt.toWorkingColorSpace(this, t),
            this
        );
    }
    setRGB(e, t, i, r = Gt.workingColorSpace) {
        return (this.r = e), (this.g = t), (this.b = i), Gt.toWorkingColorSpace(this, r), this;
    }
    setHSL(e, t, i, r = Gt.workingColorSpace) {
        if (((e = Rx(e, 1)), (t = wn(t, 0, 1)), (i = wn(i, 0, 1)), t === 0))
            this.r = this.g = this.b = i;
        else {
            const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
                o = 2 * i - s;
            (this.r = Zv(o, s, e + 1 / 3)), (this.g = Zv(o, s, e)), (this.b = Zv(o, s, e - 1 / 3));
        }
        return Gt.toWorkingColorSpace(this, r), this;
    }
    setStyle(e, t = _r) {
        function i(s) {
            s !== void 0 &&
                parseFloat(s) < 1 &&
                console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.');
        }
        let r;
        if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let s;
            const o = r[1],
                a = r[2];
            switch (o) {
                case 'rgb':
                case 'rgba':
                    if (
                        (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    )
                        return (
                            i(s[4]),
                            this.setRGB(
                                Math.min(255, parseInt(s[1], 10)) / 255,
                                Math.min(255, parseInt(s[2], 10)) / 255,
                                Math.min(255, parseInt(s[3], 10)) / 255,
                                t
                            )
                        );
                    if (
                        (s =
                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                a
                            ))
                    )
                        return (
                            i(s[4]),
                            this.setRGB(
                                Math.min(100, parseInt(s[1], 10)) / 100,
                                Math.min(100, parseInt(s[2], 10)) / 100,
                                Math.min(100, parseInt(s[3], 10)) / 100,
                                t
                            )
                        );
                    break;
                case 'hsl':
                case 'hsla':
                    if (
                        (s =
                            /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                a
                            ))
                    )
                        return (
                            i(s[4]),
                            this.setHSL(
                                parseFloat(s[1]) / 360,
                                parseFloat(s[2]) / 100,
                                parseFloat(s[3]) / 100,
                                t
                            )
                        );
                    break;
                default:
                    console.warn('THREE.Color: Unknown color model ' + e);
            }
        } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const s = r[1],
                o = s.length;
            if (o === 3)
                return this.setRGB(
                    parseInt(s.charAt(0), 16) / 15,
                    parseInt(s.charAt(1), 16) / 15,
                    parseInt(s.charAt(2), 16) / 15,
                    t
                );
            if (o === 6) return this.setHex(parseInt(s, 16), t);
            console.warn('THREE.Color: Invalid hex color ' + e);
        } else if (e && e.length > 0) return this.setColorName(e, t);
        return this;
    }
    setColorName(e, t = _r) {
        const i = UC[e.toLowerCase()];
        return (
            i !== void 0 ? this.setHex(i, t) : console.warn('THREE.Color: Unknown color ' + e), this
        );
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    }
    copySRGBToLinear(e) {
        return (this.r = cu(e.r)), (this.g = cu(e.g)), (this.b = cu(e.b)), this;
    }
    copyLinearToSRGB(e) {
        return (this.r = Uv(e.r)), (this.g = Uv(e.g)), (this.b = Uv(e.b)), this;
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
    }
    getHex(e = _r) {
        return (
            Gt.fromWorkingColorSpace(fi.copy(this), e),
            Math.round(wn(fi.r * 255, 0, 255)) * 65536 +
                Math.round(wn(fi.g * 255, 0, 255)) * 256 +
                Math.round(wn(fi.b * 255, 0, 255))
        );
    }
    getHexString(e = _r) {
        return ('000000' + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = Gt.workingColorSpace) {
        Gt.fromWorkingColorSpace(fi.copy(this), t);
        const i = fi.r,
            r = fi.g,
            s = fi.b,
            o = Math.max(i, r, s),
            a = Math.min(i, r, s);
        let c, f;
        const d = (a + o) / 2;
        if (a === o) (c = 0), (f = 0);
        else {
            const h = o - a;
            switch (((f = d <= 0.5 ? h / (o + a) : h / (2 - o - a)), o)) {
                case i:
                    c = (r - s) / h + (r < s ? 6 : 0);
                    break;
                case r:
                    c = (s - i) / h + 2;
                    break;
                case s:
                    c = (i - r) / h + 4;
                    break;
            }
            c /= 6;
        }
        return (e.h = c), (e.s = f), (e.l = d), e;
    }
    getRGB(e, t = Gt.workingColorSpace) {
        return (
            Gt.fromWorkingColorSpace(fi.copy(this), t), (e.r = fi.r), (e.g = fi.g), (e.b = fi.b), e
        );
    }
    getStyle(e = _r) {
        Gt.fromWorkingColorSpace(fi.copy(this), e);
        const t = fi.r,
            i = fi.g,
            r = fi.b;
        return e !== _r
            ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
            : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
    }
    offsetHSL(e, t, i) {
        return this.getHSL(co), this.setHSL(co.h + e, co.s + t, co.l + i);
    }
    add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
    }
    addColors(e, t) {
        return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
    }
    addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
    }
    sub(e) {
        return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
        );
    }
    multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
    }
    multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
    }
    lerp(e, t) {
        return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
        );
    }
    lerpColors(e, t, i) {
        return (
            (this.r = e.r + (t.r - e.r) * i),
            (this.g = e.g + (t.g - e.g) * i),
            (this.b = e.b + (t.b - e.b) * i),
            this
        );
    }
    lerpHSL(e, t) {
        this.getHSL(co), e.getHSL(xh);
        const i = Vc(co.h, xh.h, t),
            r = Vc(co.s, xh.s, t),
            s = Vc(co.l, xh.l, t);
        return this.setHSL(i, r, s), this;
    }
    setFromVector3(e) {
        return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
    }
    applyMatrix3(e) {
        const t = this.r,
            i = this.g,
            r = this.b,
            s = e.elements;
        return (
            (this.r = s[0] * t + s[3] * i + s[6] * r),
            (this.g = s[1] * t + s[4] * i + s[7] * r),
            (this.b = s[2] * t + s[5] * i + s[8] * r),
            this
        );
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
    }
    fromBufferAttribute(e, t) {
        return (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this;
    }
    toJSON() {
        return this.getHex();
    }
    *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
    }
}
const fi = new je();
je.NAMES = UC;
let aD = 0;
class ii extends qs {
    constructor() {
        super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, 'id', { value: aD++ }),
            (this.uuid = er()),
            (this.name = ''),
            (this.type = 'Material'),
            (this.blending = Ia),
            (this.side = Gs),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = Jp),
            (this.blendDst = Qp),
            (this.blendEquation = So),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new je(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = cf),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = iy),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = va),
            (this.stencilZFail = va),
            (this.stencilZPass = va),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
    }
    get alphaTest() {
        return this._alphaTest;
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue;
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue;
                }
                r && r.isColor
                    ? r.set(i)
                    : r && r.isVector3 && i && i.isVector3
                    ? r.copy(i)
                    : (this[t] = i);
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string';
        t && (e = { textures: {}, images: {} });
        const i = { metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' } };
        (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== '' && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            this.roughness !== void 0 && (i.roughness = this.roughness),
            this.metalness !== void 0 && (i.metalness = this.metalness),
            this.sheen !== void 0 && (i.sheen = this.sheen),
            this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity !== void 0 &&
                this.emissiveIntensity !== 1 &&
                (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
            this.specularColor &&
                this.specularColor.isColor &&
                (i.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (i.shininess = this.shininess),
            this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
                (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.iridescence !== void 0 && (i.iridescence = this.iridescence),
            this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
            this.iridescenceThicknessRange !== void 0 &&
                (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
            this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
            this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
                this.anisotropyMap.isTexture &&
                (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
                this.lightMap.isTexture &&
                ((i.lightMap = this.lightMap.toJSON(e).uuid),
                (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
                this.aoMap.isTexture &&
                ((i.aoMap = this.aoMap.toJSON(e).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
                this.bumpMap.isTexture &&
                ((i.bumpMap = this.bumpMap.toJSON(e).uuid), (i.bumpScale = this.bumpScale)),
            this.normalMap &&
                this.normalMap.isTexture &&
                ((i.normalMap = this.normalMap.toJSON(e).uuid),
                (i.normalMapType = this.normalMapType),
                (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
                this.displacementMap.isTexture &&
                ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
                (i.displacementScale = this.displacementScale),
                (i.displacementBias = this.displacementBias)),
            this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
                this.specularMap.isTexture &&
                (i.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
                this.envMap.isTexture &&
                ((i.envMap = this.envMap.toJSON(e).uuid),
                this.combine !== void 0 && (i.combine = this.combine)),
            this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
            this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
            this.gradientMap &&
                this.gradientMap.isTexture &&
                (i.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 && (i.transmission = this.transmission),
            this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (i.thickness = this.thickness),
            this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
                this.attenuationDistance !== 1 / 0 &&
                (i.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
                (i.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (i.size = this.size),
            this.shadowSide !== null && (i.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
            this.blending !== Ia && (i.blending = this.blending),
            this.side !== Gs && (i.side = this.side),
            this.vertexColors === !0 && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            this.transparent === !0 && (i.transparent = !0),
            this.blendSrc !== Jp && (i.blendSrc = this.blendSrc),
            this.blendDst !== Qp && (i.blendDst = this.blendDst),
            this.blendEquation !== So && (i.blendEquation = this.blendEquation),
            this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
            this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
            this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
            this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
            this.depthFunc !== cf && (i.depthFunc = this.depthFunc),
            this.depthTest === !1 && (i.depthTest = this.depthTest),
            this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
            this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
            this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
            this.stencilFunc !== iy && (i.stencilFunc = this.stencilFunc),
            this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
            this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== va && (i.stencilFail = this.stencilFail),
            this.stencilZFail !== va && (i.stencilZFail = this.stencilZFail),
            this.stencilZPass !== va && (i.stencilZPass = this.stencilZPass),
            this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
            this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
            this.polygonOffset === !0 && (i.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
            this.dashSize !== void 0 && (i.dashSize = this.dashSize),
            this.gapSize !== void 0 && (i.gapSize = this.gapSize),
            this.scale !== void 0 && (i.scale = this.scale),
            this.dithering === !0 && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            this.alphaHash === !0 && (i.alphaHash = !0),
            this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
            this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
            this.forceSinglePass === !0 && (i.forceSinglePass = !0),
            this.wireframe === !0 && (i.wireframe = !0),
            this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== 'round' && (i.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== 'round' && (i.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (i.flatShading = !0),
            this.visible === !1 && (i.visible = !1),
            this.toneMapped === !1 && (i.toneMapped = !1),
            this.fog === !1 && (i.fog = !1),
            Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const c = s[a];
                delete c.metadata, o.push(c);
            }
            return o;
        }
        if (t) {
            const s = r(e.textures),
                o = r(e.images);
            s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
        }
        return i;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            this.blendColor.copy(e.blendColor),
            (this.blendAlpha = e.blendAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
        }
        return (
            (this.clippingPlanes = i),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
}
class Go extends ii {
    constructor(e) {
        super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = 'MeshBasicMaterial'),
            (this.color = new je(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new nr()),
            (this.combine = zf),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
        );
    }
}
const Ls = lD();
function lD() {
    const n = new ArrayBuffer(4),
        e = new Float32Array(n),
        t = new Uint32Array(n),
        i = new Uint32Array(512),
        r = new Uint32Array(512);
    for (let c = 0; c < 256; ++c) {
        const f = c - 127;
        f < -27
            ? ((i[c] = 0), (i[c | 256] = 32768), (r[c] = 24), (r[c | 256] = 24))
            : f < -14
            ? ((i[c] = 1024 >> (-f - 14)),
              (i[c | 256] = (1024 >> (-f - 14)) | 32768),
              (r[c] = -f - 1),
              (r[c | 256] = -f - 1))
            : f <= 15
            ? ((i[c] = (f + 15) << 10),
              (i[c | 256] = ((f + 15) << 10) | 32768),
              (r[c] = 13),
              (r[c | 256] = 13))
            : f < 128
            ? ((i[c] = 31744), (i[c | 256] = 64512), (r[c] = 24), (r[c | 256] = 24))
            : ((i[c] = 31744), (i[c | 256] = 64512), (r[c] = 13), (r[c | 256] = 13));
    }
    const s = new Uint32Array(2048),
        o = new Uint32Array(64),
        a = new Uint32Array(64);
    for (let c = 1; c < 1024; ++c) {
        let f = c << 13,
            d = 0;
        for (; !(f & 8388608); ) (f <<= 1), (d -= 8388608);
        (f &= -8388609), (d += 947912704), (s[c] = f | d);
    }
    for (let c = 1024; c < 2048; ++c) s[c] = 939524096 + ((c - 1024) << 13);
    for (let c = 1; c < 31; ++c) o[c] = c << 23;
    (o[31] = 1199570944), (o[32] = 2147483648);
    for (let c = 33; c < 63; ++c) o[c] = 2147483648 + ((c - 32) << 23);
    o[63] = 3347054592;
    for (let c = 1; c < 64; ++c) c !== 32 && (a[c] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a,
    };
}
function Di(n) {
    Math.abs(n) > 65504 && console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
        (n = wn(n, -65504, 65504)),
        (Ls.floatView[0] = n);
    const e = Ls.uint32View[0],
        t = (e >> 23) & 511;
    return Ls.baseTable[t] + ((e & 8388607) >> Ls.shiftTable[t]);
}
function Pc(n) {
    const e = n >> 10;
    return (
        (Ls.uint32View[0] = Ls.mantissaTable[Ls.offsetTable[e] + (n & 1023)] + Ls.exponentTable[e]),
        Ls.floatView[0]
    );
}
const uD = { toHalfFloat: Di, fromHalfFloat: Pc },
    Dn = new k(),
    Sh = new _e();
class Yt {
    constructor(e, t, i = !1) {
        if (Array.isArray(e))
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        (this.isBufferAttribute = !0),
            (this.name = ''),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = i),
            (this.usage = Sf),
            (this._updateRange = { offset: 0, count: -1 }),
            (this.updateRanges = []),
            (this.gpuType = Ki),
            (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    get updateRange() {
        return (
            NC(
                'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'
            ),
            this._updateRange
        );
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({ start: e, count: t });
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0;
    }
    copy(e) {
        return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
        );
    }
    copyAt(e, t, i) {
        (e *= this.itemSize), (i *= t.itemSize);
        for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
        return this;
    }
    copyArray(e) {
        return this.array.set(e), this;
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                Sh.fromBufferAttribute(this, t), Sh.applyMatrix3(e), this.setXY(t, Sh.x, Sh.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                Dn.fromBufferAttribute(this, t),
                    Dn.applyMatrix3(e),
                    this.setXYZ(t, Dn.x, Dn.y, Dn.z);
        return this;
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Dn.fromBufferAttribute(this, t), Dn.applyMatrix4(e), this.setXYZ(t, Dn.x, Dn.y, Dn.z);
        return this;
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Dn.fromBufferAttribute(this, t),
                Dn.applyNormalMatrix(e),
                this.setXYZ(t, Dn.x, Dn.y, Dn.z);
        return this;
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Dn.fromBufferAttribute(this, t),
                Dn.transformDirection(e),
                this.setXYZ(t, Dn.x, Dn.y, Dn.z);
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = Ei(i, this.array)), i;
    }
    setComponent(e, t, i) {
        return (
            this.normalized && (i = Tt(i, this.array)),
            (this.array[e * this.itemSize + t] = i),
            this
        );
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setX(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)), (this.array[e * this.itemSize] = t), this
        );
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setY(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 1] = t),
            this
        );
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setZ(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 2] = t),
            this
        );
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setW(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 3] = t),
            this
        );
    }
    setXY(e, t, i) {
        return (
            (e *= this.itemSize),
            this.normalized && ((t = Tt(t, this.array)), (i = Tt(i, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            this
        );
    }
    setXYZ(e, t, i, r) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Tt(t, this.array)), (i = Tt(i, this.array)), (r = Tt(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = r),
            this
        );
    }
    setXYZW(e, t, i, r, s) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Tt(t, this.array)),
                (i = Tt(i, this.array)),
                (r = Tt(r, this.array)),
                (s = Tt(s, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = r),
            (this.array[e + 3] = s),
            this
        );
    }
    onUpload(e) {
        return (this.onUploadCallback = e), this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
        };
        return (
            this.name !== '' && (e.name = this.name), this.usage !== Sf && (e.usage = this.usage), e
        );
    }
}
class cD extends Yt {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i);
    }
}
class fD extends Yt {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i);
    }
}
class dD extends Yt {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i);
    }
}
class hD extends Yt {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i);
    }
}
class Ix extends Yt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i);
    }
}
class pD extends Yt {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i);
    }
}
class Nx extends Yt {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i);
    }
}
class mD extends Yt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
    }
    getX(e) {
        let t = Pc(this.array[e * this.itemSize]);
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setX(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize] = Di(t)),
            this
        );
    }
    getY(e) {
        let t = Pc(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setY(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 1] = Di(t)),
            this
        );
    }
    getZ(e) {
        let t = Pc(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setZ(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 2] = Di(t)),
            this
        );
    }
    getW(e) {
        let t = Pc(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setW(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 3] = Di(t)),
            this
        );
    }
    setXY(e, t, i) {
        return (
            (e *= this.itemSize),
            this.normalized && ((t = Tt(t, this.array)), (i = Tt(i, this.array))),
            (this.array[e + 0] = Di(t)),
            (this.array[e + 1] = Di(i)),
            this
        );
    }
    setXYZ(e, t, i, r) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Tt(t, this.array)), (i = Tt(i, this.array)), (r = Tt(r, this.array))),
            (this.array[e + 0] = Di(t)),
            (this.array[e + 1] = Di(i)),
            (this.array[e + 2] = Di(r)),
            this
        );
    }
    setXYZW(e, t, i, r, s) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Tt(t, this.array)),
                (i = Tt(i, this.array)),
                (r = Tt(r, this.array)),
                (s = Tt(s, this.array))),
            (this.array[e + 0] = Di(t)),
            (this.array[e + 1] = Di(i)),
            (this.array[e + 2] = Di(r)),
            (this.array[e + 3] = Di(s)),
            this
        );
    }
}
class nt extends Yt {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i);
    }
}
let gD = 0;
const gr = new ft(),
    Kv = new Ht(),
    Sl = new k(),
    qi = new Ci(),
    fc = new Ci(),
    Yn = new k();
class bt extends qs {
    constructor() {
        super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, 'id', { value: gD++ }),
            (this.uuid = er()),
            (this.name = ''),
            (this.type = 'BufferGeometry'),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
    }
    getIndex() {
        return this.index;
    }
    setIndex(e) {
        return (
            Array.isArray(e) ? (this.index = new (LC(e) ? Nx : Ix)(e, 1)) : (this.index = e), this
        );
    }
    getAttribute(e) {
        return this.attributes[e];
    }
    setAttribute(e, t) {
        return (this.attributes[e] = t), this;
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this;
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0;
    }
    addGroup(e, t, i = 0) {
        this.groups.push({ start: e, count: t, materialIndex: i });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new Et().getNormalMatrix(e);
            i.applyNormalMatrix(s), (i.needsUpdate = !0);
        }
        const r = this.attributes.tangent;
        return (
            r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
        );
    }
    applyQuaternion(e) {
        return gr.makeRotationFromQuaternion(e), this.applyMatrix4(gr), this;
    }
    rotateX(e) {
        return gr.makeRotationX(e), this.applyMatrix4(gr), this;
    }
    rotateY(e) {
        return gr.makeRotationY(e), this.applyMatrix4(gr), this;
    }
    rotateZ(e) {
        return gr.makeRotationZ(e), this.applyMatrix4(gr), this;
    }
    translate(e, t, i) {
        return gr.makeTranslation(e, t, i), this.applyMatrix4(gr), this;
    }
    scale(e, t, i) {
        return gr.makeScale(e, t, i), this.applyMatrix4(gr), this;
    }
    lookAt(e) {
        return Kv.lookAt(e), Kv.updateMatrix(), this.applyMatrix4(Kv.matrix), this;
    }
    center() {
        return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Sl).negate(),
            this.translate(Sl.x, Sl.y, Sl.z),
            this
        );
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0);
        }
        return this.setAttribute('position', new nt(t, 3)), this;
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Ci());
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
                this
            ),
                this.boundingBox.set(new k(-1 / 0, -1 / 0, -1 / 0), new k(1 / 0, 1 / 0, 1 / 0));
            return;
        }
        if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    qi.setFromBufferAttribute(s),
                        this.morphTargetsRelative
                            ? (Yn.addVectors(this.boundingBox.min, qi.min),
                              this.boundingBox.expandByPoint(Yn),
                              Yn.addVectors(this.boundingBox.max, qi.max),
                              this.boundingBox.expandByPoint(Yn))
                            : (this.boundingBox.expandByPoint(qi.min),
                              this.boundingBox.expandByPoint(qi.max));
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
            );
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new mi());
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
                this
            ),
                this.boundingSphere.set(new k(), 1 / 0);
            return;
        }
        if (e) {
            const i = this.boundingSphere.center;
            if ((qi.setFromBufferAttribute(e), t))
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    fc.setFromBufferAttribute(a),
                        this.morphTargetsRelative
                            ? (Yn.addVectors(qi.min, fc.min),
                              qi.expandByPoint(Yn),
                              Yn.addVectors(qi.max, fc.max),
                              qi.expandByPoint(Yn))
                            : (qi.expandByPoint(fc.min), qi.expandByPoint(fc.max));
                }
            qi.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Yn.fromBufferAttribute(e, s), (r = Math.max(r, i.distanceToSquared(Yn)));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s],
                        c = this.morphTargetsRelative;
                    for (let f = 0, d = a.count; f < d; f++)
                        Yn.fromBufferAttribute(a, f),
                            c && (Sl.fromBufferAttribute(e, f), Yn.add(Sl)),
                            (r = Math.max(r, i.distanceToSquared(Yn)));
                }
            (this.boundingSphere.radius = Math.sqrt(r)),
                isNaN(this.boundingSphere.radius) &&
                    console.error(
                        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                        this
                    );
        }
    }
    computeTangents() {
        const e = this.index,
            t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error(
                'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
            );
            return;
        }
        const i = t.position,
            r = t.normal,
            s = t.uv;
        this.hasAttribute('tangent') === !1 &&
            this.setAttribute('tangent', new Yt(new Float32Array(4 * i.count), 4));
        const o = this.getAttribute('tangent'),
            a = [],
            c = [];
        for (let D = 0; D < i.count; D++) (a[D] = new k()), (c[D] = new k());
        const f = new k(),
            d = new k(),
            h = new k(),
            p = new _e(),
            v = new _e(),
            _ = new _e(),
            w = new k(),
            x = new k();
        function g(D, G, b) {
            f.fromBufferAttribute(i, D),
                d.fromBufferAttribute(i, G),
                h.fromBufferAttribute(i, b),
                p.fromBufferAttribute(s, D),
                v.fromBufferAttribute(s, G),
                _.fromBufferAttribute(s, b),
                d.sub(f),
                h.sub(f),
                v.sub(p),
                _.sub(p);
            const L = 1 / (v.x * _.y - _.x * v.y);
            isFinite(L) &&
                (w.copy(d).multiplyScalar(_.y).addScaledVector(h, -v.y).multiplyScalar(L),
                x.copy(h).multiplyScalar(v.x).addScaledVector(d, -_.x).multiplyScalar(L),
                a[D].add(w),
                a[G].add(w),
                a[b].add(w),
                c[D].add(x),
                c[G].add(x),
                c[b].add(x));
        }
        let S = this.groups;
        S.length === 0 && (S = [{ start: 0, count: e.count }]);
        for (let D = 0, G = S.length; D < G; ++D) {
            const b = S[D],
                L = b.start,
                ee = b.count;
            for (let ie = L, j = L + ee; ie < j; ie += 3)
                g(e.getX(ie + 0), e.getX(ie + 1), e.getX(ie + 2));
        }
        const M = new k(),
            T = new k(),
            P = new k(),
            A = new k();
        function R(D) {
            P.fromBufferAttribute(r, D), A.copy(P);
            const G = a[D];
            M.copy(G), M.sub(P.multiplyScalar(P.dot(G))).normalize(), T.crossVectors(A, G);
            const L = T.dot(c[D]) < 0 ? -1 : 1;
            o.setXYZW(D, M.x, M.y, M.z, L);
        }
        for (let D = 0, G = S.length; D < G; ++D) {
            const b = S[D],
                L = b.start,
                ee = b.count;
            for (let ie = L, j = L + ee; ie < j; ie += 3)
                R(e.getX(ie + 0)), R(e.getX(ie + 1)), R(e.getX(ie + 2));
        }
    }
    computeVertexNormals() {
        const e = this.index,
            t = this.getAttribute('position');
        if (t !== void 0) {
            let i = this.getAttribute('normal');
            if (i === void 0)
                (i = new Yt(new Float32Array(t.count * 3), 3)), this.setAttribute('normal', i);
            else for (let p = 0, v = i.count; p < v; p++) i.setXYZ(p, 0, 0, 0);
            const r = new k(),
                s = new k(),
                o = new k(),
                a = new k(),
                c = new k(),
                f = new k(),
                d = new k(),
                h = new k();
            if (e)
                for (let p = 0, v = e.count; p < v; p += 3) {
                    const _ = e.getX(p + 0),
                        w = e.getX(p + 1),
                        x = e.getX(p + 2);
                    r.fromBufferAttribute(t, _),
                        s.fromBufferAttribute(t, w),
                        o.fromBufferAttribute(t, x),
                        d.subVectors(o, s),
                        h.subVectors(r, s),
                        d.cross(h),
                        a.fromBufferAttribute(i, _),
                        c.fromBufferAttribute(i, w),
                        f.fromBufferAttribute(i, x),
                        a.add(d),
                        c.add(d),
                        f.add(d),
                        i.setXYZ(_, a.x, a.y, a.z),
                        i.setXYZ(w, c.x, c.y, c.z),
                        i.setXYZ(x, f.x, f.y, f.z);
                }
            else
                for (let p = 0, v = t.count; p < v; p += 3)
                    r.fromBufferAttribute(t, p + 0),
                        s.fromBufferAttribute(t, p + 1),
                        o.fromBufferAttribute(t, p + 2),
                        d.subVectors(o, s),
                        h.subVectors(r, s),
                        d.cross(h),
                        i.setXYZ(p + 0, d.x, d.y, d.z),
                        i.setXYZ(p + 1, d.x, d.y, d.z),
                        i.setXYZ(p + 2, d.x, d.y, d.z);
            this.normalizeNormals(), (i.needsUpdate = !0);
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            Yn.fromBufferAttribute(e, t), Yn.normalize(), e.setXYZ(t, Yn.x, Yn.y, Yn.z);
    }
    toNonIndexed() {
        function e(a, c) {
            const f = a.array,
                d = a.itemSize,
                h = a.normalized,
                p = new f.constructor(c.length * d);
            let v = 0,
                _ = 0;
            for (let w = 0, x = c.length; w < x; w++) {
                a.isInterleavedBufferAttribute
                    ? (v = c[w] * a.data.stride + a.offset)
                    : (v = c[w] * d);
                for (let g = 0; g < d; g++) p[_++] = f[v++];
            }
            return new Yt(p, d, h);
        }
        if (this.index === null)
            return (
                console.warn(
                    'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
                ),
                this
            );
        const t = new bt(),
            i = this.index.array,
            r = this.attributes;
        for (const a in r) {
            const c = r[a],
                f = e(c, i);
            t.setAttribute(a, f);
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const c = [],
                f = s[a];
            for (let d = 0, h = f.length; d < h; d++) {
                const p = f[d],
                    v = e(p, i);
                c.push(v);
            }
            t.morphAttributes[a] = c;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, c = o.length; a < c; a++) {
            const f = o[a];
            t.addGroup(f.start, f.count, f.materialIndex);
        }
        return t;
    }
    toJSON() {
        const e = {
            metadata: { version: 4.6, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' },
        };
        if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== '' && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            this.parameters !== void 0)
        ) {
            const c = this.parameters;
            for (const f in c) c[f] !== void 0 && (e[f] = c[f]);
            return e;
        }
        e.data = { attributes: {} };
        const t = this.index;
        t !== null &&
            (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array),
            });
        const i = this.attributes;
        for (const c in i) {
            const f = i[c];
            e.data.attributes[c] = f.toJSON(e.data);
        }
        const r = {};
        let s = !1;
        for (const c in this.morphAttributes) {
            const f = this.morphAttributes[c],
                d = [];
            for (let h = 0, p = f.length; h < p; h++) {
                const v = f[h];
                d.push(v.toJSON(e.data));
            }
            d.length > 0 && ((r[c] = d), (s = !0));
        }
        s &&
            ((e.data.morphAttributes = r),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return (
            a !== null &&
                (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }),
            e
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const f in r) {
            const d = r[f];
            this.setAttribute(f, d.clone(t));
        }
        const s = e.morphAttributes;
        for (const f in s) {
            const d = [],
                h = s[f];
            for (let p = 0, v = h.length; p < v; p++) d.push(h[p].clone(t));
            this.morphAttributes[f] = d;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let f = 0, d = o.length; f < d; f++) {
            const h = o[f];
            this.addGroup(h.start, h.count, h.materialIndex);
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const c = e.boundingSphere;
        return (
            c !== null && (this.boundingSphere = c.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
}
const cw = new ft(),
    sa = new bu(),
    Mh = new mi(),
    fw = new k(),
    Ml = new k(),
    wl = new k(),
    El = new k(),
    Jv = new k(),
    wh = new k(),
    Eh = new _e(),
    Th = new _e(),
    Ah = new _e(),
    dw = new k(),
    hw = new k(),
    pw = new k(),
    Ch = new k(),
    bh = new k();
class On extends Ht {
    constructor(e = new bt(), t = new Go()) {
        super(),
            (this.isMesh = !0),
            (this.type = 'Mesh'),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.morphTargetInfluences !== void 0 &&
                (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
                (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
            (this.geometry = e.geometry),
            this
        );
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = s);
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry,
            r = i.attributes.position,
            s = i.morphAttributes.position,
            o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            wh.set(0, 0, 0);
            for (let c = 0, f = s.length; c < f; c++) {
                const d = a[c],
                    h = s[c];
                d !== 0 &&
                    (Jv.fromBufferAttribute(h, e),
                    o ? wh.addScaledVector(Jv, d) : wh.addScaledVector(Jv.sub(t), d));
            }
            t.add(wh);
        }
        return t;
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.material,
            s = this.matrixWorld;
        r !== void 0 &&
            (i.boundingSphere === null && i.computeBoundingSphere(),
            Mh.copy(i.boundingSphere),
            Mh.applyMatrix4(s),
            sa.copy(e.ray).recast(e.near),
            !(
                Mh.containsPoint(sa.origin) === !1 &&
                (sa.intersectSphere(Mh, fw) === null ||
                    sa.origin.distanceToSquared(fw) > (e.far - e.near) ** 2)
            ) &&
                (cw.copy(s).invert(),
                sa.copy(e.ray).applyMatrix4(cw),
                !(i.boundingBox !== null && sa.intersectsBox(i.boundingBox) === !1) &&
                    this._computeIntersections(e, t, sa)));
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry,
            o = this.material,
            a = s.index,
            c = s.attributes.position,
            f = s.attributes.uv,
            d = s.attributes.uv1,
            h = s.attributes.normal,
            p = s.groups,
            v = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let _ = 0, w = p.length; _ < w; _++) {
                    const x = p[_],
                        g = o[x.materialIndex],
                        S = Math.max(x.start, v.start),
                        M = Math.min(a.count, Math.min(x.start + x.count, v.start + v.count));
                    for (let T = S, P = M; T < P; T += 3) {
                        const A = a.getX(T),
                            R = a.getX(T + 1),
                            D = a.getX(T + 2);
                        (r = Rh(this, g, e, i, f, d, h, A, R, D)),
                            r &&
                                ((r.faceIndex = Math.floor(T / 3)),
                                (r.face.materialIndex = x.materialIndex),
                                t.push(r));
                    }
                }
            else {
                const _ = Math.max(0, v.start),
                    w = Math.min(a.count, v.start + v.count);
                for (let x = _, g = w; x < g; x += 3) {
                    const S = a.getX(x),
                        M = a.getX(x + 1),
                        T = a.getX(x + 2);
                    (r = Rh(this, o, e, i, f, d, h, S, M, T)),
                        r && ((r.faceIndex = Math.floor(x / 3)), t.push(r));
                }
            }
        else if (c !== void 0)
            if (Array.isArray(o))
                for (let _ = 0, w = p.length; _ < w; _++) {
                    const x = p[_],
                        g = o[x.materialIndex],
                        S = Math.max(x.start, v.start),
                        M = Math.min(c.count, Math.min(x.start + x.count, v.start + v.count));
                    for (let T = S, P = M; T < P; T += 3) {
                        const A = T,
                            R = T + 1,
                            D = T + 2;
                        (r = Rh(this, g, e, i, f, d, h, A, R, D)),
                            r &&
                                ((r.faceIndex = Math.floor(T / 3)),
                                (r.face.materialIndex = x.materialIndex),
                                t.push(r));
                    }
                }
            else {
                const _ = Math.max(0, v.start),
                    w = Math.min(c.count, v.start + v.count);
                for (let x = _, g = w; x < g; x += 3) {
                    const S = x,
                        M = x + 1,
                        T = x + 2;
                    (r = Rh(this, o, e, i, f, d, h, S, M, T)),
                        r && ((r.faceIndex = Math.floor(x / 3)), t.push(r));
                }
            }
    }
}
function vD(n, e, t, i, r, s, o, a) {
    let c;
    if (
        (e.side === Ai
            ? (c = i.intersectTriangle(o, s, r, !0, a))
            : (c = i.intersectTriangle(r, s, o, e.side === Gs, a)),
        c === null)
    )
        return null;
    bh.copy(a), bh.applyMatrix4(n.matrixWorld);
    const f = t.ray.origin.distanceTo(bh);
    return f < t.near || f > t.far ? null : { distance: f, point: bh.clone(), object: n };
}
function Rh(n, e, t, i, r, s, o, a, c, f) {
    n.getVertexPosition(a, Ml), n.getVertexPosition(c, wl), n.getVertexPosition(f, El);
    const d = vD(n, e, t, i, Ml, wl, El, Ch);
    if (d) {
        r &&
            (Eh.fromBufferAttribute(r, a),
            Th.fromBufferAttribute(r, c),
            Ah.fromBufferAttribute(r, f),
            (d.uv = Ji.getInterpolation(Ch, Ml, wl, El, Eh, Th, Ah, new _e()))),
            s &&
                (Eh.fromBufferAttribute(s, a),
                Th.fromBufferAttribute(s, c),
                Ah.fromBufferAttribute(s, f),
                (d.uv1 = Ji.getInterpolation(Ch, Ml, wl, El, Eh, Th, Ah, new _e()))),
            o &&
                (dw.fromBufferAttribute(o, a),
                hw.fromBufferAttribute(o, c),
                pw.fromBufferAttribute(o, f),
                (d.normal = Ji.getInterpolation(Ch, Ml, wl, El, dw, hw, pw, new k())),
                d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
        const h = { a, b: c, c: f, normal: new k(), materialIndex: 0 };
        Ji.getNormal(Ml, wl, El, h.normal), (d.face = h);
    }
    return d;
}
class Ya extends bt {
    constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
        super(),
            (this.type = 'BoxGeometry'),
            (this.parameters = {
                width: e,
                height: t,
                depth: i,
                widthSegments: r,
                heightSegments: s,
                depthSegments: o,
            });
        const a = this;
        (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
        const c = [],
            f = [],
            d = [],
            h = [];
        let p = 0,
            v = 0;
        _('z', 'y', 'x', -1, -1, i, t, e, o, s, 0),
            _('z', 'y', 'x', 1, -1, i, t, -e, o, s, 1),
            _('x', 'z', 'y', 1, 1, e, i, t, r, o, 2),
            _('x', 'z', 'y', 1, -1, e, i, -t, r, o, 3),
            _('x', 'y', 'z', 1, -1, e, t, i, r, s, 4),
            _('x', 'y', 'z', -1, -1, e, t, -i, r, s, 5),
            this.setIndex(c),
            this.setAttribute('position', new nt(f, 3)),
            this.setAttribute('normal', new nt(d, 3)),
            this.setAttribute('uv', new nt(h, 2));
        function _(w, x, g, S, M, T, P, A, R, D, G) {
            const b = T / R,
                L = P / D,
                ee = T / 2,
                ie = P / 2,
                j = A / 2,
                oe = R + 1,
                te = D + 1;
            let ae = 0,
                N = 0;
            const B = new k();
            for (let H = 0; H < te; H++) {
                const K = H * L - ie;
                for (let le = 0; le < oe; le++) {
                    const be = le * b - ee;
                    (B[w] = be * S),
                        (B[x] = K * M),
                        (B[g] = j),
                        f.push(B.x, B.y, B.z),
                        (B[w] = 0),
                        (B[x] = 0),
                        (B[g] = A > 0 ? 1 : -1),
                        d.push(B.x, B.y, B.z),
                        h.push(le / R),
                        h.push(1 - H / D),
                        (ae += 1);
                }
            }
            for (let H = 0; H < D; H++)
                for (let K = 0; K < R; K++) {
                    const le = p + K + oe * H,
                        be = p + K + oe * (H + 1),
                        Q = p + (K + 1) + oe * (H + 1),
                        me = p + (K + 1) + oe * H;
                    c.push(le, be, me), c.push(be, Q, me), (N += 6);
                }
            a.addGroup(v, N, G), (v += N), (p += ae);
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Ya(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
        );
    }
}
function xu(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r &&
            (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? r.isRenderTargetTexture
                    ? (console.warn(
                          'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
                      ),
                      (e[t][i] = null))
                    : (e[t][i] = r.clone())
                : Array.isArray(r)
                ? (e[t][i] = r.slice())
                : (e[t][i] = r);
        }
    }
    return e;
}
function Si(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = xu(n[t]);
        for (const r in i) e[r] = i[r];
    }
    return e;
}
function _D(n) {
    const e = [];
    for (let t = 0; t < n.length; t++) e.push(n[t].clone());
    return e;
}
function OC(n) {
    return n.getRenderTarget() === null ? n.outputColorSpace : Gt.workingColorSpace;
}
const FC = { clone: xu, merge: Si };
var yD = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    xD = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Gr extends ii {
    constructor(e) {
        super(),
            (this.isShaderMaterial = !0),
            (this.type = 'ShaderMaterial'),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader = yD),
            (this.fragmentShader = xD),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
                clipCullDistance: !1,
                multiDraw: !1,
            }),
            (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 && this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = xu(e.uniforms)),
            (this.uniformsGroups = _D(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
        );
    }
    toJSON(e) {
        const t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture
                ? (t.uniforms[r] = { type: 't', value: o.toJSON(e).uuid })
                : o && o.isColor
                ? (t.uniforms[r] = { type: 'c', value: o.getHex() })
                : o && o.isVector2
                ? (t.uniforms[r] = { type: 'v2', value: o.toArray() })
                : o && o.isVector3
                ? (t.uniforms[r] = { type: 'v3', value: o.toArray() })
                : o && o.isVector4
                ? (t.uniforms[r] = { type: 'v4', value: o.toArray() })
                : o && o.isMatrix3
                ? (t.uniforms[r] = { type: 'm3', value: o.toArray() })
                : o && o.isMatrix4
                ? (t.uniforms[r] = { type: 'm4', value: o.toArray() })
                : (t.uniforms[r] = { value: o });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
        const i = {};
        for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t;
    }
}
class Hf extends Ht {
    constructor() {
        super(),
            (this.isCamera = !0),
            (this.type = 'Camera'),
            (this.matrixWorldInverse = new ft()),
            (this.projectionMatrix = new ft()),
            (this.projectionMatrixInverse = new ft()),
            (this.coordinateSystem = ls);
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
        );
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate();
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const fo = new k(),
    mw = new _e(),
    gw = new _e();
class Zn extends Hf {
    constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
        super(),
            (this.isPerspectiveCamera = !0),
            (this.type = 'PerspectiveCamera'),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = i),
            (this.far = r),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
        );
    }
    setFocalLength(e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = yu * 2 * Math.atan(t)), this.updateProjectionMatrix();
    }
    getFocalLength() {
        const e = Math.tan(Na * 0.5 * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
    }
    getEffectiveFOV() {
        return yu * 2 * Math.atan(Math.tan(Na * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    getViewBounds(e, t, i) {
        fo.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            t.set(fo.x, fo.y).multiplyScalar(-e / fo.z),
            fo.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            i.set(fo.x, fo.y).multiplyScalar(-e / fo.z);
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, mw, gw), t.subVectors(gw, mw);
    }
    setViewOffset(e, t, i, r, s, o) {
        (this.aspect = e / t),
            this.view === null &&
                (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1,
                }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = (e * Math.tan(Na * 0.5 * this.fov)) / this.zoom,
            i = 2 * t,
            r = this.aspect * i,
            s = -0.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const c = o.fullWidth,
                f = o.fullHeight;
            (s += (o.offsetX * r) / c),
                (t -= (o.offsetY * i) / f),
                (r *= o.width / c),
                (i *= o.height / f);
        }
        const a = this.filmOffset;
        a !== 0 && (s += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
                s,
                s + r,
                t,
                t - i,
                e,
                this.far,
                this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null && (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
        );
    }
}
const Tl = -90,
    Al = 1;
class kC extends Ht {
    constructor(e, t, i) {
        super(),
            (this.type = 'CubeCamera'),
            (this.renderTarget = i),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
        const r = new Zn(Tl, Al, e, t);
        (r.layers = this.layers), this.add(r);
        const s = new Zn(Tl, Al, e, t);
        (s.layers = this.layers), this.add(s);
        const o = new Zn(Tl, Al, e, t);
        (o.layers = this.layers), this.add(o);
        const a = new Zn(Tl, Al, e, t);
        (a.layers = this.layers), this.add(a);
        const c = new Zn(Tl, Al, e, t);
        (c.layers = this.layers), this.add(c);
        const f = new Zn(Tl, Al, e, t);
        (f.layers = this.layers), this.add(f);
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem,
            t = this.children.concat(),
            [i, r, s, o, a, c] = t;
        for (const f of t) this.remove(f);
        if (e === ls)
            i.up.set(0, 1, 0),
                i.lookAt(1, 0, 0),
                r.up.set(0, 1, 0),
                r.lookAt(-1, 0, 0),
                s.up.set(0, 0, -1),
                s.lookAt(0, 1, 0),
                o.up.set(0, 0, 1),
                o.lookAt(0, -1, 0),
                a.up.set(0, 1, 0),
                a.lookAt(0, 0, 1),
                c.up.set(0, 1, 0),
                c.lookAt(0, 0, -1);
        else if (e === Mf)
            i.up.set(0, -1, 0),
                i.lookAt(-1, 0, 0),
                r.up.set(0, -1, 0),
                r.lookAt(1, 0, 0),
                s.up.set(0, 0, 1),
                s.lookAt(0, 1, 0),
                o.up.set(0, 0, -1),
                o.lookAt(0, -1, 0),
                a.up.set(0, -1, 0),
                a.lookAt(0, 0, 1),
                c.up.set(0, -1, 0),
                c.lookAt(0, 0, -1);
        else
            throw new Error(
                'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + e
            );
        for (const f of t) this.add(f), f.updateMatrixWorld();
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const { renderTarget: i, activeMipmapLevel: r } = this;
        this.coordinateSystem !== e.coordinateSystem &&
            ((this.coordinateSystem = e.coordinateSystem), this.updateCoordinateSystem());
        const [s, o, a, c, f, d] = this.children,
            h = e.getRenderTarget(),
            p = e.getActiveCubeFace(),
            v = e.getActiveMipmapLevel(),
            _ = e.xr.enabled;
        e.xr.enabled = !1;
        const w = i.texture.generateMipmaps;
        (i.texture.generateMipmaps = !1),
            e.setRenderTarget(i, 0, r),
            e.render(t, s),
            e.setRenderTarget(i, 1, r),
            e.render(t, o),
            e.setRenderTarget(i, 2, r),
            e.render(t, a),
            e.setRenderTarget(i, 3, r),
            e.render(t, c),
            e.setRenderTarget(i, 4, r),
            e.render(t, f),
            (i.texture.generateMipmaps = w),
            e.setRenderTarget(i, 5, r),
            e.render(t, d),
            e.setRenderTarget(h, p, v),
            (e.xr.enabled = _),
            (i.texture.needsPMREMUpdate = !0);
    }
}
class Vf extends mn {
    constructor(e, t, i, r, s, o, a, c, f, d) {
        (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : Ws),
            super(e, t, i, r, s, o, a, c, f, d),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
    }
    get images() {
        return this.image;
    }
    set images(e) {
        this.image = e;
    }
}
class zC extends Vr {
    constructor(e = 1, t = {}) {
        super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
        const i = { width: e, height: e, depth: 1 },
            r = [i, i, i, i, i, i];
        (this.texture = new Vf(
            r,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.colorSpace
        )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : dn);
    }
    fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
        const i = {
                uniforms: { tEquirect: { value: null } },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            r = new Ya(5, 5, 5),
            s = new Gr({
                name: 'CubemapFromEquirect',
                uniforms: xu(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: Ai,
                blending: ks,
            });
        s.uniforms.tEquirect.value = t;
        const o = new On(r, s),
            a = t.minFilter;
        return (
            t.minFilter === as && (t.minFilter = dn),
            new kC(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
        );
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
        e.setRenderTarget(s);
    }
}
const Qv = new k(),
    SD = new k(),
    MD = new Et();
class _o {
    constructor(e = new k(1, 0, 0), t = 0) {
        (this.isPlane = !0), (this.normal = e), (this.constant = t);
    }
    set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i), (this.constant = r), this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Qv.subVectors(i, t).cross(SD.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this;
    }
    copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
    }
    negate() {
        return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
    }
    intersectLine(e, t) {
        const i = e.delta(Qv),
            r = this.normal.dot(i);
        if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
        return (t < 0 && i > 0) || (i < 0 && t > 0);
    }
    intersectsBox(e) {
        return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
        const i = t || MD.getNormalMatrix(e),
            r = this.coplanarPoint(Qv).applyMatrix4(e),
            s = this.normal.applyMatrix3(i).normalize();
        return (this.constant = -r.dot(s)), this;
    }
    translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const oa = new mi(),
    Ph = new k();
class Gf {
    constructor(
        e = new _o(),
        t = new _o(),
        i = new _o(),
        r = new _o(),
        s = new _o(),
        o = new _o()
    ) {
        this.planes = [e, t, i, r, s, o];
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return (
            a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this
        );
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this;
    }
    setFromProjectionMatrix(e, t = ls) {
        const i = this.planes,
            r = e.elements,
            s = r[0],
            o = r[1],
            a = r[2],
            c = r[3],
            f = r[4],
            d = r[5],
            h = r[6],
            p = r[7],
            v = r[8],
            _ = r[9],
            w = r[10],
            x = r[11],
            g = r[12],
            S = r[13],
            M = r[14],
            T = r[15];
        if (
            (i[0].setComponents(c - s, p - f, x - v, T - g).normalize(),
            i[1].setComponents(c + s, p + f, x + v, T + g).normalize(),
            i[2].setComponents(c + o, p + d, x + _, T + S).normalize(),
            i[3].setComponents(c - o, p - d, x - _, T - S).normalize(),
            i[4].setComponents(c - a, p - h, x - w, T - M).normalize(),
            t === ls)
        )
            i[5].setComponents(c + a, p + h, x + w, T + M).normalize();
        else if (t === Mf) i[5].setComponents(a, h, w, M).normalize();
        else
            throw new Error(
                'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + t
            );
        return this;
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
                oa.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
                oa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
        }
        return this.intersectsSphere(oa);
    }
    intersectsSprite(e) {
        return (
            oa.center.set(0, 0, 0),
            (oa.radius = 0.7071067811865476),
            oa.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(oa)
        );
    }
    intersectsSphere(e) {
        const t = this.planes,
            i = e.center,
            r = -e.radius;
        for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
        return !0;
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (
                ((Ph.x = r.normal.x > 0 ? e.max.x : e.min.x),
                (Ph.y = r.normal.y > 0 ? e.max.y : e.min.y),
                (Ph.z = r.normal.z > 0 ? e.max.z : e.min.z),
                r.distanceToPoint(Ph) < 0)
            )
                return !1;
        }
        return !0;
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
        return !0;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
function BC() {
    let n = null,
        e = !1,
        t = null,
        i = null;
    function r(s, o) {
        t(s, o), (i = n.requestAnimationFrame(r));
    }
    return {
        start: function () {
            e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
        },
        stop: function () {
            n.cancelAnimationFrame(i), (e = !1);
        },
        setAnimationLoop: function (s) {
            t = s;
        },
        setContext: function (s) {
            n = s;
        },
    };
}
function wD(n, e) {
    const t = e.isWebGL2,
        i = new WeakMap();
    function r(f, d) {
        const h = f.array,
            p = f.usage,
            v = h.byteLength,
            _ = n.createBuffer();
        n.bindBuffer(d, _), n.bufferData(d, h, p), f.onUploadCallback();
        let w;
        if (h instanceof Float32Array) w = n.FLOAT;
        else if (h instanceof Uint16Array)
            if (f.isFloat16BufferAttribute)
                if (t) w = n.HALF_FLOAT;
                else
                    throw new Error(
                        'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
                    );
            else w = n.UNSIGNED_SHORT;
        else if (h instanceof Int16Array) w = n.SHORT;
        else if (h instanceof Uint32Array) w = n.UNSIGNED_INT;
        else if (h instanceof Int32Array) w = n.INT;
        else if (h instanceof Int8Array) w = n.BYTE;
        else if (h instanceof Uint8Array) w = n.UNSIGNED_BYTE;
        else if (h instanceof Uint8ClampedArray) w = n.UNSIGNED_BYTE;
        else throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + h);
        return {
            buffer: _,
            type: w,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: f.version,
            size: v,
        };
    }
    function s(f, d, h) {
        const p = d.array,
            v = d._updateRange,
            _ = d.updateRanges;
        if (
            (n.bindBuffer(h, f),
            v.count === -1 && _.length === 0 && n.bufferSubData(h, 0, p),
            _.length !== 0)
        ) {
            for (let w = 0, x = _.length; w < x; w++) {
                const g = _[w];
                t
                    ? n.bufferSubData(h, g.start * p.BYTES_PER_ELEMENT, p, g.start, g.count)
                    : n.bufferSubData(
                          h,
                          g.start * p.BYTES_PER_ELEMENT,
                          p.subarray(g.start, g.start + g.count)
                      );
            }
            d.clearUpdateRanges();
        }
        v.count !== -1 &&
            (t
                ? n.bufferSubData(h, v.offset * p.BYTES_PER_ELEMENT, p, v.offset, v.count)
                : n.bufferSubData(
                      h,
                      v.offset * p.BYTES_PER_ELEMENT,
                      p.subarray(v.offset, v.offset + v.count)
                  ),
            (v.count = -1)),
            d.onUploadCallback();
    }
    function o(f) {
        return f.isInterleavedBufferAttribute && (f = f.data), i.get(f);
    }
    function a(f) {
        f.isInterleavedBufferAttribute && (f = f.data);
        const d = i.get(f);
        d && (n.deleteBuffer(d.buffer), i.delete(f));
    }
    function c(f, d) {
        if (f.isGLBufferAttribute) {
            const p = i.get(f);
            (!p || p.version < f.version) &&
                i.set(f, {
                    buffer: f.buffer,
                    type: f.type,
                    bytesPerElement: f.elementSize,
                    version: f.version,
                });
            return;
        }
        f.isInterleavedBufferAttribute && (f = f.data);
        const h = i.get(f);
        if (h === void 0) i.set(f, r(f, d));
        else if (h.version < f.version) {
            if (h.size !== f.array.byteLength)
                throw new Error(
                    "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
                );
            s(h.buffer, f, d), (h.version = f.version);
        }
    }
    return { get: o, remove: a, update: c };
}
class Ru extends bt {
    constructor(e = 1, t = 1, i = 1, r = 1) {
        super(),
            (this.type = 'PlaneGeometry'),
            (this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r });
        const s = e / 2,
            o = t / 2,
            a = Math.floor(i),
            c = Math.floor(r),
            f = a + 1,
            d = c + 1,
            h = e / a,
            p = t / c,
            v = [],
            _ = [],
            w = [],
            x = [];
        for (let g = 0; g < d; g++) {
            const S = g * p - o;
            for (let M = 0; M < f; M++) {
                const T = M * h - s;
                _.push(T, -S, 0), w.push(0, 0, 1), x.push(M / a), x.push(1 - g / c);
            }
        }
        for (let g = 0; g < c; g++)
            for (let S = 0; S < a; S++) {
                const M = S + f * g,
                    T = S + f * (g + 1),
                    P = S + 1 + f * (g + 1),
                    A = S + 1 + f * g;
                v.push(M, T, A), v.push(T, P, A);
            }
        this.setIndex(v),
            this.setAttribute('position', new nt(_, 3)),
            this.setAttribute('normal', new nt(w, 3)),
            this.setAttribute('uv', new nt(x, 2));
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Ru(e.width, e.height, e.widthSegments, e.heightSegments);
    }
}
var ED = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
    TD = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
    AD = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    CD = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    bD = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
    RD = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    PD = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    LD = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    ID = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    ND = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
    DD = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
    UD = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    OD = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    FD = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    kD = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    zD = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
    BD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    HD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    VD = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    GD = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    WD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    jD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    XD = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    YD = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    qD = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    ZD = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    KD = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    JD = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    QD = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    $D = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    eU = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
    tU = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
    nU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    iU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    rU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    sU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    oU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    aU = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    lU = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    uU = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    cU = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    fU = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    dU = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    hU = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    pU = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    mU = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    gU = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    vU = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    _U = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    yU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    xU = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    SU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    MU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
    wU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    EU = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    TU = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    AU = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
    CU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    bU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    RU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    PU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    LU = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    IU = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    NU = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    DU = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    UU = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    OU = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    FU = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
    kU = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    zU = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    BU = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    HU = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    VU = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
    GU = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    WU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    jU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    XU = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    YU = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    qU = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
    ZU = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    KU = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    JU = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    QU = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    $U = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    eO = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    tO = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    nO = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    iO = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    rO = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    sO = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    oO = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    aO = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    lO = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    uO = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    cO = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    fO = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    dO = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    hO = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    pO = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    mO = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    gO = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    vO = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    _O = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    yO = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    xO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    SO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    MO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    wO = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const EO = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    TO = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    AO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    CO = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    bO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    RO = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    PO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    LO = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    IO = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    NO = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    DO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    UO = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    OO = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    FO = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    kO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    zO = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    BO = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    HO = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    VO = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    GO = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    WO = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    jO = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    XO = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    YO = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    qO = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    ZO = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    KO = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    JO = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    QO = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    $O = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    eF = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    tF = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    nF = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    iF = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    Ct = {
        alphahash_fragment: ED,
        alphahash_pars_fragment: TD,
        alphamap_fragment: AD,
        alphamap_pars_fragment: CD,
        alphatest_fragment: bD,
        alphatest_pars_fragment: RD,
        aomap_fragment: PD,
        aomap_pars_fragment: LD,
        batching_pars_vertex: ID,
        batching_vertex: ND,
        begin_vertex: DD,
        beginnormal_vertex: UD,
        bsdfs: OD,
        iridescence_fragment: FD,
        bumpmap_pars_fragment: kD,
        clipping_planes_fragment: zD,
        clipping_planes_pars_fragment: BD,
        clipping_planes_pars_vertex: HD,
        clipping_planes_vertex: VD,
        color_fragment: GD,
        color_pars_fragment: WD,
        color_pars_vertex: jD,
        color_vertex: XD,
        common: YD,
        cube_uv_reflection_fragment: qD,
        defaultnormal_vertex: ZD,
        displacementmap_pars_vertex: KD,
        displacementmap_vertex: JD,
        emissivemap_fragment: QD,
        emissivemap_pars_fragment: $D,
        colorspace_fragment: eU,
        colorspace_pars_fragment: tU,
        envmap_fragment: nU,
        envmap_common_pars_fragment: iU,
        envmap_pars_fragment: rU,
        envmap_pars_vertex: sU,
        envmap_physical_pars_fragment: vU,
        envmap_vertex: oU,
        fog_vertex: aU,
        fog_pars_vertex: lU,
        fog_fragment: uU,
        fog_pars_fragment: cU,
        gradientmap_pars_fragment: fU,
        lightmap_fragment: dU,
        lightmap_pars_fragment: hU,
        lights_lambert_fragment: pU,
        lights_lambert_pars_fragment: mU,
        lights_pars_begin: gU,
        lights_toon_fragment: _U,
        lights_toon_pars_fragment: yU,
        lights_phong_fragment: xU,
        lights_phong_pars_fragment: SU,
        lights_physical_fragment: MU,
        lights_physical_pars_fragment: wU,
        lights_fragment_begin: EU,
        lights_fragment_maps: TU,
        lights_fragment_end: AU,
        logdepthbuf_fragment: CU,
        logdepthbuf_pars_fragment: bU,
        logdepthbuf_pars_vertex: RU,
        logdepthbuf_vertex: PU,
        map_fragment: LU,
        map_pars_fragment: IU,
        map_particle_fragment: NU,
        map_particle_pars_fragment: DU,
        metalnessmap_fragment: UU,
        metalnessmap_pars_fragment: OU,
        morphinstance_vertex: FU,
        morphcolor_vertex: kU,
        morphnormal_vertex: zU,
        morphtarget_pars_vertex: BU,
        morphtarget_vertex: HU,
        normal_fragment_begin: VU,
        normal_fragment_maps: GU,
        normal_pars_fragment: WU,
        normal_pars_vertex: jU,
        normal_vertex: XU,
        normalmap_pars_fragment: YU,
        clearcoat_normal_fragment_begin: qU,
        clearcoat_normal_fragment_maps: ZU,
        clearcoat_pars_fragment: KU,
        iridescence_pars_fragment: JU,
        opaque_fragment: QU,
        packing: $U,
        premultiplied_alpha_fragment: eO,
        project_vertex: tO,
        dithering_fragment: nO,
        dithering_pars_fragment: iO,
        roughnessmap_fragment: rO,
        roughnessmap_pars_fragment: sO,
        shadowmap_pars_fragment: oO,
        shadowmap_pars_vertex: aO,
        shadowmap_vertex: lO,
        shadowmask_pars_fragment: uO,
        skinbase_vertex: cO,
        skinning_pars_vertex: fO,
        skinning_vertex: dO,
        skinnormal_vertex: hO,
        specularmap_fragment: pO,
        specularmap_pars_fragment: mO,
        tonemapping_fragment: gO,
        tonemapping_pars_fragment: vO,
        transmission_fragment: _O,
        transmission_pars_fragment: yO,
        uv_pars_fragment: xO,
        uv_pars_vertex: SO,
        uv_vertex: MO,
        worldpos_vertex: wO,
        background_vert: EO,
        background_frag: TO,
        backgroundCube_vert: AO,
        backgroundCube_frag: CO,
        cube_vert: bO,
        cube_frag: RO,
        depth_vert: PO,
        depth_frag: LO,
        distanceRGBA_vert: IO,
        distanceRGBA_frag: NO,
        equirect_vert: DO,
        equirect_frag: UO,
        linedashed_vert: OO,
        linedashed_frag: FO,
        meshbasic_vert: kO,
        meshbasic_frag: zO,
        meshlambert_vert: BO,
        meshlambert_frag: HO,
        meshmatcap_vert: VO,
        meshmatcap_frag: GO,
        meshnormal_vert: WO,
        meshnormal_frag: jO,
        meshphong_vert: XO,
        meshphong_frag: YO,
        meshphysical_vert: qO,
        meshphysical_frag: ZO,
        meshtoon_vert: KO,
        meshtoon_frag: JO,
        points_vert: QO,
        points_frag: $O,
        shadow_vert: eF,
        shadow_frag: tF,
        sprite_vert: nF,
        sprite_frag: iF,
    },
    Ne = {
        common: {
            diffuse: { value: new je(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new Et() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Et() },
            alphaTest: { value: 0 },
        },
        specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Et() } },
        envmap: {
            envMap: { value: null },
            envMapRotation: { value: new Et() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
        },
        aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new Et() },
        },
        lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new Et() },
        },
        bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new Et() },
            bumpScale: { value: 1 },
        },
        normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new Et() },
            normalScale: { value: new _e(1, 1) },
        },
        displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new Et() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
        },
        emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Et() } },
        metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Et() } },
        roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Et() } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new je(16777215) },
        },
        lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: { value: [], properties: { direction: {}, color: {} } },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                },
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
                value: [],
                properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {},
                },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
        },
        points: {
            diffuse: { value: new je(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Et() },
            alphaTest: { value: 0 },
            uvTransform: { value: new Et() },
        },
        sprite: {
            diffuse: { value: new je(16777215) },
            opacity: { value: 1 },
            center: { value: new _e(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new Et() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Et() },
            alphaTest: { value: 0 },
        },
    },
    kr = {
        basic: {
            uniforms: Si([Ne.common, Ne.specularmap, Ne.envmap, Ne.aomap, Ne.lightmap, Ne.fog]),
            vertexShader: Ct.meshbasic_vert,
            fragmentShader: Ct.meshbasic_frag,
        },
        lambert: {
            uniforms: Si([
                Ne.common,
                Ne.specularmap,
                Ne.envmap,
                Ne.aomap,
                Ne.lightmap,
                Ne.emissivemap,
                Ne.bumpmap,
                Ne.normalmap,
                Ne.displacementmap,
                Ne.fog,
                Ne.lights,
                { emissive: { value: new je(0) } },
            ]),
            vertexShader: Ct.meshlambert_vert,
            fragmentShader: Ct.meshlambert_frag,
        },
        phong: {
            uniforms: Si([
                Ne.common,
                Ne.specularmap,
                Ne.envmap,
                Ne.aomap,
                Ne.lightmap,
                Ne.emissivemap,
                Ne.bumpmap,
                Ne.normalmap,
                Ne.displacementmap,
                Ne.fog,
                Ne.lights,
                {
                    emissive: { value: new je(0) },
                    specular: { value: new je(1118481) },
                    shininess: { value: 30 },
                },
            ]),
            vertexShader: Ct.meshphong_vert,
            fragmentShader: Ct.meshphong_frag,
        },
        standard: {
            uniforms: Si([
                Ne.common,
                Ne.envmap,
                Ne.aomap,
                Ne.lightmap,
                Ne.emissivemap,
                Ne.bumpmap,
                Ne.normalmap,
                Ne.displacementmap,
                Ne.roughnessmap,
                Ne.metalnessmap,
                Ne.fog,
                Ne.lights,
                {
                    emissive: { value: new je(0) },
                    roughness: { value: 1 },
                    metalness: { value: 0 },
                    envMapIntensity: { value: 1 },
                },
            ]),
            vertexShader: Ct.meshphysical_vert,
            fragmentShader: Ct.meshphysical_frag,
        },
        toon: {
            uniforms: Si([
                Ne.common,
                Ne.aomap,
                Ne.lightmap,
                Ne.emissivemap,
                Ne.bumpmap,
                Ne.normalmap,
                Ne.displacementmap,
                Ne.gradientmap,
                Ne.fog,
                Ne.lights,
                { emissive: { value: new je(0) } },
            ]),
            vertexShader: Ct.meshtoon_vert,
            fragmentShader: Ct.meshtoon_frag,
        },
        matcap: {
            uniforms: Si([
                Ne.common,
                Ne.bumpmap,
                Ne.normalmap,
                Ne.displacementmap,
                Ne.fog,
                { matcap: { value: null } },
            ]),
            vertexShader: Ct.meshmatcap_vert,
            fragmentShader: Ct.meshmatcap_frag,
        },
        points: {
            uniforms: Si([Ne.points, Ne.fog]),
            vertexShader: Ct.points_vert,
            fragmentShader: Ct.points_frag,
        },
        dashed: {
            uniforms: Si([
                Ne.common,
                Ne.fog,
                { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
            ]),
            vertexShader: Ct.linedashed_vert,
            fragmentShader: Ct.linedashed_frag,
        },
        depth: {
            uniforms: Si([Ne.common, Ne.displacementmap]),
            vertexShader: Ct.depth_vert,
            fragmentShader: Ct.depth_frag,
        },
        normal: {
            uniforms: Si([
                Ne.common,
                Ne.bumpmap,
                Ne.normalmap,
                Ne.displacementmap,
                { opacity: { value: 1 } },
            ]),
            vertexShader: Ct.meshnormal_vert,
            fragmentShader: Ct.meshnormal_frag,
        },
        sprite: {
            uniforms: Si([Ne.sprite, Ne.fog]),
            vertexShader: Ct.sprite_vert,
            fragmentShader: Ct.sprite_frag,
        },
        background: {
            uniforms: {
                uvTransform: { value: new Et() },
                t2D: { value: null },
                backgroundIntensity: { value: 1 },
            },
            vertexShader: Ct.background_vert,
            fragmentShader: Ct.background_frag,
        },
        backgroundCube: {
            uniforms: {
                envMap: { value: null },
                flipEnvMap: { value: -1 },
                backgroundBlurriness: { value: 0 },
                backgroundIntensity: { value: 1 },
                backgroundRotation: { value: new Et() },
            },
            vertexShader: Ct.backgroundCube_vert,
            fragmentShader: Ct.backgroundCube_frag,
        },
        cube: {
            uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
            vertexShader: Ct.cube_vert,
            fragmentShader: Ct.cube_frag,
        },
        equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Ct.equirect_vert,
            fragmentShader: Ct.equirect_frag,
        },
        distanceRGBA: {
            uniforms: Si([
                Ne.common,
                Ne.displacementmap,
                {
                    referencePosition: { value: new k() },
                    nearDistance: { value: 1 },
                    farDistance: { value: 1e3 },
                },
            ]),
            vertexShader: Ct.distanceRGBA_vert,
            fragmentShader: Ct.distanceRGBA_frag,
        },
        shadow: {
            uniforms: Si([
                Ne.lights,
                Ne.fog,
                { color: { value: new je(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Ct.shadow_vert,
            fragmentShader: Ct.shadow_frag,
        },
    };
kr.physical = {
    uniforms: Si([
        kr.standard.uniforms,
        {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new Et() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new Et() },
            clearcoatNormalScale: { value: new _e(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new Et() },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new Et() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new Et() },
            sheen: { value: 0 },
            sheenColor: { value: new je(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new Et() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new Et() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new Et() },
            transmissionSamplerSize: { value: new _e() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new Et() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new je(0) },
            specularColor: { value: new je(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new Et() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new Et() },
            anisotropyVector: { value: new _e() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new Et() },
        },
    ]),
    vertexShader: Ct.meshphysical_vert,
    fragmentShader: Ct.meshphysical_frag,
};
const Lh = { r: 0, b: 0, g: 0 },
    aa = new nr(),
    rF = new ft();
function sF(n, e, t, i, r, s, o) {
    const a = new je(0);
    let c = s === !0 ? 0 : 1,
        f,
        d,
        h = null,
        p = 0,
        v = null;
    function _(x, g) {
        let S = !1,
            M = g.isScene === !0 ? g.background : null;
        M && M.isTexture && (M = (g.backgroundBlurriness > 0 ? t : e).get(M)),
            M === null ? w(a, c) : M && M.isColor && (w(M, 1), (S = !0));
        const T = n.xr.getEnvironmentBlendMode();
        T === 'additive'
            ? i.buffers.color.setClear(0, 0, 0, 1, o)
            : T === 'alpha-blend' && i.buffers.color.setClear(0, 0, 0, 0, o),
            (n.autoClear || S) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
            M && (M.isCubeTexture || M.mapping === Cu)
                ? (d === void 0 &&
                      ((d = new On(
                          new Ya(1, 1, 1),
                          new Gr({
                              name: 'BackgroundCubeMaterial',
                              uniforms: xu(kr.backgroundCube.uniforms),
                              vertexShader: kr.backgroundCube.vertexShader,
                              fragmentShader: kr.backgroundCube.fragmentShader,
                              side: Ai,
                              depthTest: !1,
                              depthWrite: !1,
                              fog: !1,
                          })
                      )),
                      d.geometry.deleteAttribute('normal'),
                      d.geometry.deleteAttribute('uv'),
                      (d.onBeforeRender = function (P, A, R) {
                          this.matrixWorld.copyPosition(R.matrixWorld);
                      }),
                      Object.defineProperty(d.material, 'envMap', {
                          get: function () {
                              return this.uniforms.envMap.value;
                          },
                      }),
                      r.update(d)),
                  aa.copy(g.backgroundRotation),
                  (aa.x *= -1),
                  (aa.y *= -1),
                  (aa.z *= -1),
                  M.isCubeTexture && M.isRenderTargetTexture === !1 && ((aa.y *= -1), (aa.z *= -1)),
                  (d.material.uniforms.envMap.value = M),
                  (d.material.uniforms.flipEnvMap.value =
                      M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1),
                  (d.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness),
                  (d.material.uniforms.backgroundIntensity.value = g.backgroundIntensity),
                  d.material.uniforms.backgroundRotation.value.setFromMatrix4(
                      rF.makeRotationFromEuler(aa)
                  ),
                  (d.material.toneMapped = Gt.getTransfer(M.colorSpace) !== Jt),
                  (h !== M || p !== M.version || v !== n.toneMapping) &&
                      ((d.material.needsUpdate = !0),
                      (h = M),
                      (p = M.version),
                      (v = n.toneMapping)),
                  d.layers.enableAll(),
                  x.unshift(d, d.geometry, d.material, 0, 0, null))
                : M &&
                  M.isTexture &&
                  (f === void 0 &&
                      ((f = new On(
                          new Ru(2, 2),
                          new Gr({
                              name: 'BackgroundMaterial',
                              uniforms: xu(kr.background.uniforms),
                              vertexShader: kr.background.vertexShader,
                              fragmentShader: kr.background.fragmentShader,
                              side: Gs,
                              depthTest: !1,
                              depthWrite: !1,
                              fog: !1,
                          })
                      )),
                      f.geometry.deleteAttribute('normal'),
                      Object.defineProperty(f.material, 'map', {
                          get: function () {
                              return this.uniforms.t2D.value;
                          },
                      }),
                      r.update(f)),
                  (f.material.uniforms.t2D.value = M),
                  (f.material.uniforms.backgroundIntensity.value = g.backgroundIntensity),
                  (f.material.toneMapped = Gt.getTransfer(M.colorSpace) !== Jt),
                  M.matrixAutoUpdate === !0 && M.updateMatrix(),
                  f.material.uniforms.uvTransform.value.copy(M.matrix),
                  (h !== M || p !== M.version || v !== n.toneMapping) &&
                      ((f.material.needsUpdate = !0),
                      (h = M),
                      (p = M.version),
                      (v = n.toneMapping)),
                  f.layers.enableAll(),
                  x.unshift(f, f.geometry, f.material, 0, 0, null));
    }
    function w(x, g) {
        x.getRGB(Lh, OC(n)), i.buffers.color.setClear(Lh.r, Lh.g, Lh.b, g, o);
    }
    return {
        getClearColor: function () {
            return a;
        },
        setClearColor: function (x, g = 1) {
            a.set(x), (c = g), w(a, c);
        },
        getClearAlpha: function () {
            return c;
        },
        setClearAlpha: function (x) {
            (c = x), w(a, c);
        },
        render: _,
    };
}
function oF(n, e, t, i) {
    const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
        s = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
        o = i.isWebGL2 || s !== null,
        a = {},
        c = x(null);
    let f = c,
        d = !1;
    function h(j, oe, te, ae, N) {
        let B = !1;
        if (o) {
            const H = w(ae, te, oe);
            f !== H && ((f = H), v(f.object)), (B = g(j, ae, te, N)), B && S(j, ae, te, N);
        } else {
            const H = oe.wireframe === !0;
            (f.geometry !== ae.id || f.program !== te.id || f.wireframe !== H) &&
                ((f.geometry = ae.id), (f.program = te.id), (f.wireframe = H), (B = !0));
        }
        N !== null && t.update(N, n.ELEMENT_ARRAY_BUFFER),
            (B || d) &&
                ((d = !1),
                D(j, oe, te, ae),
                N !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(N).buffer));
    }
    function p() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
    }
    function v(j) {
        return i.isWebGL2 ? n.bindVertexArray(j) : s.bindVertexArrayOES(j);
    }
    function _(j) {
        return i.isWebGL2 ? n.deleteVertexArray(j) : s.deleteVertexArrayOES(j);
    }
    function w(j, oe, te) {
        const ae = te.wireframe === !0;
        let N = a[j.id];
        N === void 0 && ((N = {}), (a[j.id] = N));
        let B = N[oe.id];
        B === void 0 && ((B = {}), (N[oe.id] = B));
        let H = B[ae];
        return H === void 0 && ((H = x(p())), (B[ae] = H)), H;
    }
    function x(j) {
        const oe = [],
            te = [],
            ae = [];
        for (let N = 0; N < r; N++) (oe[N] = 0), (te[N] = 0), (ae[N] = 0);
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: oe,
            enabledAttributes: te,
            attributeDivisors: ae,
            object: j,
            attributes: {},
            index: null,
        };
    }
    function g(j, oe, te, ae) {
        const N = f.attributes,
            B = oe.attributes;
        let H = 0;
        const K = te.getAttributes();
        for (const le in K)
            if (K[le].location >= 0) {
                const Q = N[le];
                let me = B[le];
                if (
                    (me === void 0 &&
                        (le === 'instanceMatrix' && j.instanceMatrix && (me = j.instanceMatrix),
                        le === 'instanceColor' && j.instanceColor && (me = j.instanceColor)),
                    Q === void 0 || Q.attribute !== me || (me && Q.data !== me.data))
                )
                    return !0;
                H++;
            }
        return f.attributesNum !== H || f.index !== ae;
    }
    function S(j, oe, te, ae) {
        const N = {},
            B = oe.attributes;
        let H = 0;
        const K = te.getAttributes();
        for (const le in K)
            if (K[le].location >= 0) {
                let Q = B[le];
                Q === void 0 &&
                    (le === 'instanceMatrix' && j.instanceMatrix && (Q = j.instanceMatrix),
                    le === 'instanceColor' && j.instanceColor && (Q = j.instanceColor));
                const me = {};
                (me.attribute = Q), Q && Q.data && (me.data = Q.data), (N[le] = me), H++;
            }
        (f.attributes = N), (f.attributesNum = H), (f.index = ae);
    }
    function M() {
        const j = f.newAttributes;
        for (let oe = 0, te = j.length; oe < te; oe++) j[oe] = 0;
    }
    function T(j) {
        P(j, 0);
    }
    function P(j, oe) {
        const te = f.newAttributes,
            ae = f.enabledAttributes,
            N = f.attributeDivisors;
        (te[j] = 1),
            ae[j] === 0 && (n.enableVertexAttribArray(j), (ae[j] = 1)),
            N[j] !== oe &&
                ((i.isWebGL2 ? n : e.get('ANGLE_instanced_arrays'))[
                    i.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
                ](j, oe),
                (N[j] = oe));
    }
    function A() {
        const j = f.newAttributes,
            oe = f.enabledAttributes;
        for (let te = 0, ae = oe.length; te < ae; te++)
            oe[te] !== j[te] && (n.disableVertexAttribArray(te), (oe[te] = 0));
    }
    function R(j, oe, te, ae, N, B, H) {
        H === !0
            ? n.vertexAttribIPointer(j, oe, te, N, B)
            : n.vertexAttribPointer(j, oe, te, ae, N, B);
    }
    function D(j, oe, te, ae) {
        if (
            i.isWebGL2 === !1 &&
            (j.isInstancedMesh || ae.isInstancedBufferGeometry) &&
            e.get('ANGLE_instanced_arrays') === null
        )
            return;
        M();
        const N = ae.attributes,
            B = te.getAttributes(),
            H = oe.defaultAttributeValues;
        for (const K in B) {
            const le = B[K];
            if (le.location >= 0) {
                let be = N[K];
                if (
                    (be === void 0 &&
                        (K === 'instanceMatrix' && j.instanceMatrix && (be = j.instanceMatrix),
                        K === 'instanceColor' && j.instanceColor && (be = j.instanceColor)),
                    be !== void 0)
                ) {
                    const Q = be.normalized,
                        me = be.itemSize,
                        Se = t.get(be);
                    if (Se === void 0) continue;
                    const ke = Se.buffer,
                        et = Se.type,
                        Xe = Se.bytesPerElement,
                        gt =
                            i.isWebGL2 === !0 &&
                            (et === n.INT || et === n.UNSIGNED_INT || be.gpuType === yx);
                    if (be.isInterleavedBufferAttribute) {
                        const De = be.data,
                            V = De.stride,
                            we = be.offset;
                        if (De.isInstancedInterleavedBuffer) {
                            for (let ve = 0; ve < le.locationSize; ve++)
                                P(le.location + ve, De.meshPerAttribute);
                            j.isInstancedMesh !== !0 &&
                                ae._maxInstanceCount === void 0 &&
                                (ae._maxInstanceCount = De.meshPerAttribute * De.count);
                        } else for (let ve = 0; ve < le.locationSize; ve++) T(le.location + ve);
                        n.bindBuffer(n.ARRAY_BUFFER, ke);
                        for (let ve = 0; ve < le.locationSize; ve++)
                            R(
                                le.location + ve,
                                me / le.locationSize,
                                et,
                                Q,
                                V * Xe,
                                (we + (me / le.locationSize) * ve) * Xe,
                                gt
                            );
                    } else {
                        if (be.isInstancedBufferAttribute) {
                            for (let De = 0; De < le.locationSize; De++)
                                P(le.location + De, be.meshPerAttribute);
                            j.isInstancedMesh !== !0 &&
                                ae._maxInstanceCount === void 0 &&
                                (ae._maxInstanceCount = be.meshPerAttribute * be.count);
                        } else for (let De = 0; De < le.locationSize; De++) T(le.location + De);
                        n.bindBuffer(n.ARRAY_BUFFER, ke);
                        for (let De = 0; De < le.locationSize; De++)
                            R(
                                le.location + De,
                                me / le.locationSize,
                                et,
                                Q,
                                me * Xe,
                                (me / le.locationSize) * De * Xe,
                                gt
                            );
                    }
                } else if (H !== void 0) {
                    const Q = H[K];
                    if (Q !== void 0)
                        switch (Q.length) {
                            case 2:
                                n.vertexAttrib2fv(le.location, Q);
                                break;
                            case 3:
                                n.vertexAttrib3fv(le.location, Q);
                                break;
                            case 4:
                                n.vertexAttrib4fv(le.location, Q);
                                break;
                            default:
                                n.vertexAttrib1fv(le.location, Q);
                        }
                }
            }
        }
        A();
    }
    function G() {
        ee();
        for (const j in a) {
            const oe = a[j];
            for (const te in oe) {
                const ae = oe[te];
                for (const N in ae) _(ae[N].object), delete ae[N];
                delete oe[te];
            }
            delete a[j];
        }
    }
    function b(j) {
        if (a[j.id] === void 0) return;
        const oe = a[j.id];
        for (const te in oe) {
            const ae = oe[te];
            for (const N in ae) _(ae[N].object), delete ae[N];
            delete oe[te];
        }
        delete a[j.id];
    }
    function L(j) {
        for (const oe in a) {
            const te = a[oe];
            if (te[j.id] === void 0) continue;
            const ae = te[j.id];
            for (const N in ae) _(ae[N].object), delete ae[N];
            delete te[j.id];
        }
    }
    function ee() {
        ie(), (d = !0), f !== c && ((f = c), v(f.object));
    }
    function ie() {
        (c.geometry = null), (c.program = null), (c.wireframe = !1);
    }
    return {
        setup: h,
        reset: ee,
        resetDefaultState: ie,
        dispose: G,
        releaseStatesOfGeometry: b,
        releaseStatesOfProgram: L,
        initAttributes: M,
        enableAttribute: T,
        disableUnusedAttributes: A,
    };
}
function aF(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(d) {
        s = d;
    }
    function a(d, h) {
        n.drawArrays(s, d, h), t.update(h, s, 1);
    }
    function c(d, h, p) {
        if (p === 0) return;
        let v, _;
        if (r) (v = n), (_ = 'drawArraysInstanced');
        else if (
            ((v = e.get('ANGLE_instanced_arrays')), (_ = 'drawArraysInstancedANGLE'), v === null)
        ) {
            console.error(
                'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
            );
            return;
        }
        v[_](s, d, h, p), t.update(h, s, p);
    }
    function f(d, h, p) {
        if (p === 0) return;
        const v = e.get('WEBGL_multi_draw');
        if (v === null) for (let _ = 0; _ < p; _++) this.render(d[_], h[_]);
        else {
            v.multiDrawArraysWEBGL(s, d, 0, h, 0, p);
            let _ = 0;
            for (let w = 0; w < p; w++) _ += h[w];
            t.update(_, s, 1);
        }
    }
    (this.setMode = o), (this.render = a), (this.renderInstances = c), (this.renderMultiDraw = f);
}
function lF(n, e, t) {
    let i;
    function r() {
        if (i !== void 0) return i;
        if (e.has('EXT_texture_filter_anisotropic') === !0) {
            const R = e.get('EXT_texture_filter_anisotropic');
            i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else i = 0;
        return i;
    }
    function s(R) {
        if (R === 'highp') {
            if (
                n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 &&
                n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0
            )
                return 'highp';
            R = 'mediump';
        }
        return R === 'mediump' &&
            n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 &&
            n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0
            ? 'mediump'
            : 'lowp';
    }
    const o =
        typeof WebGL2RenderingContext < 'u' && n.constructor.name === 'WebGL2RenderingContext';
    let a = t.precision !== void 0 ? t.precision : 'highp';
    const c = s(a);
    c !== a &&
        (console.warn('THREE.WebGLRenderer:', a, 'not supported, using', c, 'instead.'), (a = c));
    const f = o || e.has('WEBGL_draw_buffers'),
        d = t.logarithmicDepthBuffer === !0,
        h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
        p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        v = n.getParameter(n.MAX_TEXTURE_SIZE),
        _ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
        w = n.getParameter(n.MAX_VERTEX_ATTRIBS),
        x = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
        g = n.getParameter(n.MAX_VARYING_VECTORS),
        S = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
        M = p > 0,
        T = o || e.has('OES_texture_float'),
        P = M && T,
        A = o ? n.getParameter(n.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: f,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: d,
        maxTextures: h,
        maxVertexTextures: p,
        maxTextureSize: v,
        maxCubemapSize: _,
        maxAttributes: w,
        maxVertexUniforms: x,
        maxVaryings: g,
        maxFragmentUniforms: S,
        vertexTextures: M,
        floatFragmentTextures: T,
        floatVertexTextures: P,
        maxSamples: A,
    };
}
function uF(n) {
    const e = this;
    let t = null,
        i = 0,
        r = !1,
        s = !1;
    const o = new _o(),
        a = new Et(),
        c = { value: null, needsUpdate: !1 };
    (this.uniform = c),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (h, p) {
            const v = h.length !== 0 || p || i !== 0 || r;
            return (r = p), (i = h.length), v;
        }),
        (this.beginShadows = function () {
            (s = !0), d(null);
        }),
        (this.endShadows = function () {
            s = !1;
        }),
        (this.setGlobalState = function (h, p) {
            t = d(h, p, 0);
        }),
        (this.setState = function (h, p, v) {
            const _ = h.clippingPlanes,
                w = h.clipIntersection,
                x = h.clipShadows,
                g = n.get(h);
            if (!r || _ === null || _.length === 0 || (s && !x)) s ? d(null) : f();
            else {
                const S = s ? 0 : i,
                    M = S * 4;
                let T = g.clippingState || null;
                (c.value = T), (T = d(_, p, M, v));
                for (let P = 0; P !== M; ++P) T[P] = t[P];
                (g.clippingState = T),
                    (this.numIntersection = w ? this.numPlanes : 0),
                    (this.numPlanes += S);
            }
        });
    function f() {
        c.value !== t && ((c.value = t), (c.needsUpdate = i > 0)),
            (e.numPlanes = i),
            (e.numIntersection = 0);
    }
    function d(h, p, v, _) {
        const w = h !== null ? h.length : 0;
        let x = null;
        if (w !== 0) {
            if (((x = c.value), _ !== !0 || x === null)) {
                const g = v + w * 4,
                    S = p.matrixWorldInverse;
                a.getNormalMatrix(S), (x === null || x.length < g) && (x = new Float32Array(g));
                for (let M = 0, T = v; M !== w; ++M, T += 4)
                    o.copy(h[M]).applyMatrix4(S, a),
                        o.normal.toArray(x, T),
                        (x[T + 3] = o.constant);
            }
            (c.value = x), (c.needsUpdate = !0);
        }
        return (e.numPlanes = w), (e.numIntersection = 0), x;
    }
}
function cF(n) {
    let e = new WeakMap();
    function t(o, a) {
        return a === ff ? (o.mapping = Ws) : a === df && (o.mapping = Fo), o;
    }
    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === ff || a === df)
                if (e.has(o)) {
                    const c = e.get(o).texture;
                    return t(c, o.mapping);
                } else {
                    const c = o.image;
                    if (c && c.height > 0) {
                        const f = new zC(c.height);
                        return (
                            f.fromEquirectangularTexture(n, o),
                            e.set(o, f),
                            o.addEventListener('dispose', r),
                            t(f.texture, o.mapping)
                        );
                    } else return null;
                }
        }
        return o;
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener('dispose', r);
        const c = e.get(a);
        c !== void 0 && (e.delete(a), c.dispose());
    }
    function s() {
        e = new WeakMap();
    }
    return { get: i, dispose: s };
}
class Wf extends Hf {
    constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
        super(),
            (this.isOrthographicCamera = !0),
            (this.type = 'OrthographicCamera'),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = i),
            (this.bottom = r),
            (this.near = s),
            (this.far = o),
            this.updateProjectionMatrix();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
        );
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null &&
            (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        let s = i - e,
            o = i + e,
            a = r + t,
            c = r - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom,
                d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += f * this.view.offsetX),
                (o = s + f * this.view.width),
                (a -= d * this.view.offsetY),
                (c = a - d * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(
            s,
            o,
            a,
            c,
            this.near,
            this.far,
            this.coordinateSystem
        ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null && (t.object.view = Object.assign({}, this.view)),
            t
        );
    }
}
const Jl = 4,
    vw = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    xa = 20,
    $v = new Wf(),
    _w = new je();
let e0 = null,
    t0 = 0,
    n0 = 0;
const _a = (1 + Math.sqrt(5)) / 2,
    Cl = 1 / _a,
    yw = [
        new k(1, 1, 1),
        new k(-1, 1, 1),
        new k(1, 1, -1),
        new k(-1, 1, -1),
        new k(0, _a, Cl),
        new k(0, _a, -Cl),
        new k(Cl, 0, _a),
        new k(-Cl, 0, _a),
        new k(_a, Cl, 0),
        new k(-_a, Cl, 0),
    ];
class oy {
    constructor(e) {
        (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, i = 0.1, r = 100) {
        (e0 = this._renderer.getRenderTarget()),
            (t0 = this._renderer.getActiveCubeFace()),
            (n0 = this._renderer.getActiveMipmapLevel()),
            this._setSize(256);
        const s = this._allocateTargets();
        return (
            (s.depthBuffer = !0),
            this._sceneToCubeUV(e, i, r, s),
            t > 0 && this._blur(s, 0, 0, t),
            this._applyPMREM(s),
            this._cleanup(s),
            s
        );
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
    }
    compileCubemapShader() {
        this._cubemapMaterial === null &&
            ((this._cubemapMaterial = Mw()), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null &&
            ((this._equirectMaterial = Sw()), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
        this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
        (this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(e0, t0, n0),
            (e.scissorTest = !1),
            Ih(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
        e.mapping === Ws || e.mapping === Fo
            ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width)
            : this._setSize(e.image.width / 4),
            (e0 = this._renderer.getRenderTarget()),
            (t0 = this._renderer.getActiveCubeFace()),
            (n0 = this._renderer.getActiveMipmapLevel());
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = {
                magFilter: dn,
                minFilter: dn,
                generateMipmaps: !1,
                type: _u,
                format: wi,
                colorSpace: Ys,
                depthBuffer: !1,
            },
            r = xw(e, t, i);
        if (
            this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
        ) {
            this._pingPongRenderTarget !== null && this._dispose(),
                (this._pingPongRenderTarget = xw(e, t, i));
            const { _lodMax: s } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
            } = fF(s)),
                (this._blurMaterial = dF(s, e, t));
        }
        return r;
    }
    _compileMaterial(e) {
        const t = new On(this._lodPlanes[0], e);
        this._renderer.compile(t, $v);
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Zn(90, 1, t, i),
            c = [1, -1, 1, 1, 1, 1],
            f = [1, 1, 1, -1, -1, -1],
            d = this._renderer,
            h = d.autoClear,
            p = d.toneMapping;
        d.getClearColor(_w), (d.toneMapping = fs), (d.autoClear = !1);
        const v = new Go({ name: 'PMREM.Background', side: Ai, depthWrite: !1, depthTest: !1 }),
            _ = new On(new Ya(), v);
        let w = !1;
        const x = e.background;
        x
            ? x.isColor && (v.color.copy(x), (e.background = null), (w = !0))
            : (v.color.copy(_w), (w = !0));
        for (let g = 0; g < 6; g++) {
            const S = g % 3;
            S === 0
                ? (a.up.set(0, c[g], 0), a.lookAt(f[g], 0, 0))
                : S === 1
                ? (a.up.set(0, 0, c[g]), a.lookAt(0, f[g], 0))
                : (a.up.set(0, c[g], 0), a.lookAt(0, 0, f[g]));
            const M = this._cubeSize;
            Ih(r, S * M, g > 2 ? M : 0, M, M),
                d.setRenderTarget(r),
                w && d.render(_, a),
                d.render(e, a);
        }
        _.geometry.dispose(),
            _.material.dispose(),
            (d.toneMapping = p),
            (d.autoClear = h),
            (e.background = x);
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer,
            r = e.mapping === Ws || e.mapping === Fo;
        r
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = Mw()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  e.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null && (this._equirectMaterial = Sw());
        const s = r ? this._cubemapMaterial : this._equirectMaterial,
            o = new On(this._lodPlanes[0], s),
            a = s.uniforms;
        a.envMap.value = e;
        const c = this._cubeSize;
        Ih(t, 0, 0, 3 * c, 2 * c), i.setRenderTarget(t), i.render(o, $v);
    }
    _applyPMREM(e) {
        const t = this._renderer,
            i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(
                    this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]
                ),
                o = yw[(r - 1) % yw.length];
            this._blur(e, r - 1, r, s, o);
        }
        t.autoClear = i;
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, 'latitudinal', s),
            this._halfBlur(o, e, i, i, r, 'longitudinal', s);
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const c = this._renderer,
            f = this._blurMaterial;
        o !== 'latitudinal' &&
            o !== 'longitudinal' &&
            console.error('blur direction must be either latitudinal or longitudinal!');
        const d = 3,
            h = new On(this._lodPlanes[r], f),
            p = f.uniforms,
            v = this._sizeLods[i] - 1,
            _ = isFinite(s) ? Math.PI / (2 * v) : (2 * Math.PI) / (2 * xa - 1),
            w = s / _,
            x = isFinite(s) ? 1 + Math.floor(d * w) : xa;
        x > xa &&
            console.warn(
                `sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${xa}`
            );
        const g = [];
        let S = 0;
        for (let R = 0; R < xa; ++R) {
            const D = R / w,
                G = Math.exp((-D * D) / 2);
            g.push(G), R === 0 ? (S += G) : R < x && (S += 2 * G);
        }
        for (let R = 0; R < g.length; R++) g[R] = g[R] / S;
        (p.envMap.value = e.texture),
            (p.samples.value = x),
            (p.weights.value = g),
            (p.latitudinal.value = o === 'latitudinal'),
            a && (p.poleAxis.value = a);
        const { _lodMax: M } = this;
        (p.dTheta.value = _), (p.mipInt.value = M - i);
        const T = this._sizeLods[r],
            P = 3 * T * (r > M - Jl ? r - M + Jl : 0),
            A = 4 * (this._cubeSize - T);
        Ih(t, P, A, 3 * T, 2 * T), c.setRenderTarget(t), c.render(h, $v);
    }
}
function fF(n) {
    const e = [],
        t = [],
        i = [];
    let r = n;
    const s = n - Jl + 1 + vw.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let c = 1 / a;
        o > n - Jl ? (c = vw[o - n + Jl - 1]) : o === 0 && (c = 0), i.push(c);
        const f = 1 / (a - 2),
            d = -f,
            h = 1 + f,
            p = [d, d, h, d, h, h, d, d, h, h, d, h],
            v = 6,
            _ = 6,
            w = 3,
            x = 2,
            g = 1,
            S = new Float32Array(w * _ * v),
            M = new Float32Array(x * _ * v),
            T = new Float32Array(g * _ * v);
        for (let A = 0; A < v; A++) {
            const R = ((A % 3) * 2) / 3 - 1,
                D = A > 2 ? 0 : -1,
                G = [
                    R,
                    D,
                    0,
                    R + 2 / 3,
                    D,
                    0,
                    R + 2 / 3,
                    D + 1,
                    0,
                    R,
                    D,
                    0,
                    R + 2 / 3,
                    D + 1,
                    0,
                    R,
                    D + 1,
                    0,
                ];
            S.set(G, w * _ * A), M.set(p, x * _ * A);
            const b = [A, A, A, A, A, A];
            T.set(b, g * _ * A);
        }
        const P = new bt();
        P.setAttribute('position', new Yt(S, w)),
            P.setAttribute('uv', new Yt(M, x)),
            P.setAttribute('faceIndex', new Yt(T, g)),
            e.push(P),
            r > Jl && r--;
    }
    return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function xw(n, e, t) {
    const i = new Vr(n, e, t);
    return (i.texture.mapping = Cu), (i.texture.name = 'PMREM.cubeUv'), (i.scissorTest = !0), i;
}
function Ih(n, e, t, i, r) {
    n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function dF(n, e, t) {
    const i = new Float32Array(xa),
        r = new k(0, 1, 0);
    return new Gr({
        name: 'SphericalGaussianBlur',
        defines: {
            n: xa,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`,
        },
        uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: i },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: r },
        },
        vertexShader: Dx(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: ks,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Sw() {
    return new Gr({
        name: 'EquirectangularToCubeUV',
        uniforms: { envMap: { value: null } },
        vertexShader: Dx(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: ks,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Mw() {
    return new Gr({
        name: 'CubemapToCubeUV',
        uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
        vertexShader: Dx(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: ks,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Dx() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function hF(n) {
    let e = new WeakMap(),
        t = null;
    function i(a) {
        if (a && a.isTexture) {
            const c = a.mapping,
                f = c === ff || c === df,
                d = c === Ws || c === Fo;
            if (f || d)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return (
                        t === null && (t = new oy(n)),
                        (h = f ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h)),
                        e.set(a, h),
                        h.texture
                    );
                } else {
                    if (e.has(a)) return e.get(a).texture;
                    {
                        const h = a.image;
                        if ((f && h && h.height > 0) || (d && h && r(h))) {
                            t === null && (t = new oy(n));
                            const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, p), a.addEventListener('dispose', s), p.texture;
                        } else return null;
                    }
                }
        }
        return a;
    }
    function r(a) {
        let c = 0;
        const f = 6;
        for (let d = 0; d < f; d++) a[d] !== void 0 && c++;
        return c === f;
    }
    function s(a) {
        const c = a.target;
        c.removeEventListener('dispose', s);
        const f = e.get(c);
        f !== void 0 && (e.delete(c), f.dispose());
    }
    function o() {
        (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
    }
    return { get: i, dispose: o };
}
function pF(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0) return e[i];
        let r;
        switch (i) {
            case 'WEBGL_depth_texture':
                r =
                    n.getExtension('WEBGL_depth_texture') ||
                    n.getExtension('MOZ_WEBGL_depth_texture') ||
                    n.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                r =
                    n.getExtension('EXT_texture_filter_anisotropic') ||
                    n.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                    n.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                r =
                    n.getExtension('WEBGL_compressed_texture_s3tc') ||
                    n.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                    n.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                r =
                    n.getExtension('WEBGL_compressed_texture_pvrtc') ||
                    n.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            default:
                r = n.getExtension(i);
        }
        return (e[i] = r), r;
    }
    return {
        has: function (i) {
            return t(i) !== null;
        },
        init: function (i) {
            i.isWebGL2
                ? (t('EXT_color_buffer_float'), t('WEBGL_clip_cull_distance'))
                : (t('WEBGL_depth_texture'),
                  t('OES_texture_float'),
                  t('OES_texture_half_float'),
                  t('OES_texture_half_float_linear'),
                  t('OES_standard_derivatives'),
                  t('OES_element_index_uint'),
                  t('OES_vertex_array_object'),
                  t('ANGLE_instanced_arrays')),
                t('OES_texture_float_linear'),
                t('EXT_color_buffer_half_float'),
                t('WEBGL_multisampled_render_to_texture');
        },
        get: function (i) {
            const r = t(i);
            return (
                r === null &&
                    console.warn('THREE.WebGLRenderer: ' + i + ' extension not supported.'),
                r
            );
        },
    };
}
function mF(n, e, t, i) {
    const r = {},
        s = new WeakMap();
    function o(h) {
        const p = h.target;
        p.index !== null && e.remove(p.index);
        for (const _ in p.attributes) e.remove(p.attributes[_]);
        for (const _ in p.morphAttributes) {
            const w = p.morphAttributes[_];
            for (let x = 0, g = w.length; x < g; x++) e.remove(w[x]);
        }
        p.removeEventListener('dispose', o), delete r[p.id];
        const v = s.get(p);
        v && (e.remove(v), s.delete(p)),
            i.releaseStatesOfGeometry(p),
            p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
            t.memory.geometries--;
    }
    function a(h, p) {
        return (
            r[p.id] === !0 ||
                (p.addEventListener('dispose', o), (r[p.id] = !0), t.memory.geometries++),
            p
        );
    }
    function c(h) {
        const p = h.attributes;
        for (const _ in p) e.update(p[_], n.ARRAY_BUFFER);
        const v = h.morphAttributes;
        for (const _ in v) {
            const w = v[_];
            for (let x = 0, g = w.length; x < g; x++) e.update(w[x], n.ARRAY_BUFFER);
        }
    }
    function f(h) {
        const p = [],
            v = h.index,
            _ = h.attributes.position;
        let w = 0;
        if (v !== null) {
            const S = v.array;
            w = v.version;
            for (let M = 0, T = S.length; M < T; M += 3) {
                const P = S[M + 0],
                    A = S[M + 1],
                    R = S[M + 2];
                p.push(P, A, A, R, R, P);
            }
        } else if (_ !== void 0) {
            const S = _.array;
            w = _.version;
            for (let M = 0, T = S.length / 3 - 1; M < T; M += 3) {
                const P = M + 0,
                    A = M + 1,
                    R = M + 2;
                p.push(P, A, A, R, R, P);
            }
        } else return;
        const x = new (LC(p) ? Nx : Ix)(p, 1);
        x.version = w;
        const g = s.get(h);
        g && e.remove(g), s.set(h, x);
    }
    function d(h) {
        const p = s.get(h);
        if (p) {
            const v = h.index;
            v !== null && p.version < v.version && f(h);
        } else f(h);
        return s.get(h);
    }
    return { get: a, update: c, getWireframeAttribute: d };
}
function gF(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(v) {
        s = v;
    }
    let a, c;
    function f(v) {
        (a = v.type), (c = v.bytesPerElement);
    }
    function d(v, _) {
        n.drawElements(s, _, a, v * c), t.update(_, s, 1);
    }
    function h(v, _, w) {
        if (w === 0) return;
        let x, g;
        if (r) (x = n), (g = 'drawElementsInstanced');
        else if (
            ((x = e.get('ANGLE_instanced_arrays')), (g = 'drawElementsInstancedANGLE'), x === null)
        ) {
            console.error(
                'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
            );
            return;
        }
        x[g](s, _, a, v * c, w), t.update(_, s, w);
    }
    function p(v, _, w) {
        if (w === 0) return;
        const x = e.get('WEBGL_multi_draw');
        if (x === null) for (let g = 0; g < w; g++) this.render(v[g] / c, _[g]);
        else {
            x.multiDrawElementsWEBGL(s, _, 0, a, v, 0, w);
            let g = 0;
            for (let S = 0; S < w; S++) g += _[S];
            t.update(g, s, 1);
        }
    }
    (this.setMode = o),
        (this.setIndex = f),
        (this.render = d),
        (this.renderInstances = h),
        (this.renderMultiDraw = p);
}
function vF(n) {
    const e = { geometries: 0, textures: 0 },
        t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    function i(s, o, a) {
        switch ((t.calls++, o)) {
            case n.TRIANGLES:
                t.triangles += a * (s / 3);
                break;
            case n.LINES:
                t.lines += a * (s / 2);
                break;
            case n.LINE_STRIP:
                t.lines += a * (s - 1);
                break;
            case n.LINE_LOOP:
                t.lines += a * s;
                break;
            case n.POINTS:
                t.points += a * s;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', o);
                break;
        }
    }
    function r() {
        (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
    }
    return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: i };
}
function _F(n, e) {
    return n[0] - e[0];
}
function yF(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1]);
}
function xF(n, e, t) {
    const i = {},
        r = new Float32Array(8),
        s = new WeakMap(),
        o = new Wt(),
        a = [];
    for (let f = 0; f < 8; f++) a[f] = [f, 0];
    function c(f, d, h) {
        const p = f.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const _ =
                    d.morphAttributes.position ||
                    d.morphAttributes.normal ||
                    d.morphAttributes.color,
                w = _ !== void 0 ? _.length : 0;
            let x = s.get(d);
            if (x === void 0 || x.count !== w) {
                let ie = function () {
                    L.dispose(), s.delete(d), d.removeEventListener('dispose', ie);
                };
                var v = ie;
                x !== void 0 && x.texture.dispose();
                const g = d.morphAttributes.position !== void 0,
                    S = d.morphAttributes.normal !== void 0,
                    M = d.morphAttributes.color !== void 0,
                    T = d.morphAttributes.position || [],
                    P = d.morphAttributes.normal || [],
                    A = d.morphAttributes.color || [];
                let R = 0;
                g === !0 && (R = 1), S === !0 && (R = 2), M === !0 && (R = 3);
                let D = d.attributes.position.count * R,
                    G = 1;
                D > e.maxTextureSize &&
                    ((G = Math.ceil(D / e.maxTextureSize)), (D = e.maxTextureSize));
                const b = new Float32Array(D * G * 4 * w),
                    L = new Lm(b, D, G, w);
                (L.type = Ki), (L.needsUpdate = !0);
                const ee = R * 4;
                for (let j = 0; j < w; j++) {
                    const oe = T[j],
                        te = P[j],
                        ae = A[j],
                        N = D * G * 4 * j;
                    for (let B = 0; B < oe.count; B++) {
                        const H = B * ee;
                        g === !0 &&
                            (o.fromBufferAttribute(oe, B),
                            (b[N + H + 0] = o.x),
                            (b[N + H + 1] = o.y),
                            (b[N + H + 2] = o.z),
                            (b[N + H + 3] = 0)),
                            S === !0 &&
                                (o.fromBufferAttribute(te, B),
                                (b[N + H + 4] = o.x),
                                (b[N + H + 5] = o.y),
                                (b[N + H + 6] = o.z),
                                (b[N + H + 7] = 0)),
                            M === !0 &&
                                (o.fromBufferAttribute(ae, B),
                                (b[N + H + 8] = o.x),
                                (b[N + H + 9] = o.y),
                                (b[N + H + 10] = o.z),
                                (b[N + H + 11] = ae.itemSize === 4 ? o.w : 1));
                    }
                }
                (x = { count: w, texture: L, size: new _e(D, G) }),
                    s.set(d, x),
                    d.addEventListener('dispose', ie);
            }
            if (f.isInstancedMesh === !0 && f.morphTexture !== null)
                h.getUniforms().setValue(n, 'morphTexture', f.morphTexture, t);
            else {
                let g = 0;
                for (let M = 0; M < p.length; M++) g += p[M];
                const S = d.morphTargetsRelative ? 1 : 1 - g;
                h.getUniforms().setValue(n, 'morphTargetBaseInfluence', S),
                    h.getUniforms().setValue(n, 'morphTargetInfluences', p);
            }
            h.getUniforms().setValue(n, 'morphTargetsTexture', x.texture, t),
                h.getUniforms().setValue(n, 'morphTargetsTextureSize', x.size);
        } else {
            const _ = p === void 0 ? 0 : p.length;
            let w = i[d.id];
            if (w === void 0 || w.length !== _) {
                w = [];
                for (let T = 0; T < _; T++) w[T] = [T, 0];
                i[d.id] = w;
            }
            for (let T = 0; T < _; T++) {
                const P = w[T];
                (P[0] = T), (P[1] = p[T]);
            }
            w.sort(yF);
            for (let T = 0; T < 8; T++)
                T < _ && w[T][1]
                    ? ((a[T][0] = w[T][0]), (a[T][1] = w[T][1]))
                    : ((a[T][0] = Number.MAX_SAFE_INTEGER), (a[T][1] = 0));
            a.sort(_F);
            const x = d.morphAttributes.position,
                g = d.morphAttributes.normal;
            let S = 0;
            for (let T = 0; T < 8; T++) {
                const P = a[T],
                    A = P[0],
                    R = P[1];
                A !== Number.MAX_SAFE_INTEGER && R
                    ? (x &&
                          d.getAttribute('morphTarget' + T) !== x[A] &&
                          d.setAttribute('morphTarget' + T, x[A]),
                      g &&
                          d.getAttribute('morphNormal' + T) !== g[A] &&
                          d.setAttribute('morphNormal' + T, g[A]),
                      (r[T] = R),
                      (S += R))
                    : (x &&
                          d.hasAttribute('morphTarget' + T) === !0 &&
                          d.deleteAttribute('morphTarget' + T),
                      g &&
                          d.hasAttribute('morphNormal' + T) === !0 &&
                          d.deleteAttribute('morphNormal' + T),
                      (r[T] = 0));
            }
            const M = d.morphTargetsRelative ? 1 : 1 - S;
            h.getUniforms().setValue(n, 'morphTargetBaseInfluence', M),
                h.getUniforms().setValue(n, 'morphTargetInfluences', r);
        }
    }
    return { update: c };
}
function SF(n, e, t, i) {
    let r = new WeakMap();
    function s(c) {
        const f = i.render.frame,
            d = c.geometry,
            h = e.get(c, d);
        if (
            (r.get(h) !== f && (e.update(h), r.set(h, f)),
            c.isInstancedMesh &&
                (c.hasEventListener('dispose', a) === !1 && c.addEventListener('dispose', a),
                r.get(c) !== f &&
                    (t.update(c.instanceMatrix, n.ARRAY_BUFFER),
                    c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER),
                    r.set(c, f))),
            c.isSkinnedMesh)
        ) {
            const p = c.skeleton;
            r.get(p) !== f && (p.update(), r.set(p, f));
        }
        return h;
    }
    function o() {
        r = new WeakMap();
    }
    function a(c) {
        const f = c.target;
        f.removeEventListener('dispose', a),
            t.remove(f.instanceMatrix),
            f.instanceColor !== null && t.remove(f.instanceColor);
    }
    return { update: s, dispose: o };
}
class Ux extends mn {
    constructor(e, t, i, r, s, o, a, c, f, d) {
        if (((d = d !== void 0 ? d : No), d !== No && d !== Va))
            throw new Error(
                'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
            );
        i === void 0 && d === No && (i = Ds),
            i === void 0 && d === Va && (i = Io),
            super(null, r, s, o, a, c, d, i, f),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : bn),
            (this.minFilter = c !== void 0 ? c : bn),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
    }
    copy(e) {
        return super.copy(e), (this.compareFunction = e.compareFunction), this;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
    }
}
const HC = new mn(),
    VC = new Ux(1, 1);
VC.compareFunction = bx;
const GC = new Lm(),
    WC = new Lx(),
    jC = new Vf(),
    ww = [],
    Ew = [],
    Tw = new Float32Array(16),
    Aw = new Float32Array(9),
    Cw = new Float32Array(4);
function Pu(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0) return n;
    const r = e * t;
    let s = ww[r];
    if ((s === void 0 && ((s = new Float32Array(r)), (ww[r] = s)), e !== 0)) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
    }
    return s;
}
function Bn(n, e) {
    if (n.length !== e.length) return !1;
    for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
    return !0;
}
function Hn(n, e) {
    for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Im(n, e) {
    let t = Ew[e];
    t === void 0 && ((t = new Int32Array(e)), (Ew[e] = t));
    for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
    return t;
}
function MF(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function wF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (Bn(t, e)) return;
        n.uniform2fv(this.addr, e), Hn(t, e);
    }
}
function EF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3f(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (n.uniform3f(this.addr, e.r, e.g, e.b), (t[0] = e.r), (t[1] = e.g), (t[2] = e.b));
    else {
        if (Bn(t, e)) return;
        n.uniform3fv(this.addr, e), Hn(t, e);
    }
}
function TF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (Bn(t, e)) return;
        n.uniform4fv(this.addr, e), Hn(t, e);
    }
}
function AF(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Bn(t, e)) return;
        n.uniformMatrix2fv(this.addr, !1, e), Hn(t, e);
    } else {
        if (Bn(t, i)) return;
        Cw.set(i), n.uniformMatrix2fv(this.addr, !1, Cw), Hn(t, i);
    }
}
function CF(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Bn(t, e)) return;
        n.uniformMatrix3fv(this.addr, !1, e), Hn(t, e);
    } else {
        if (Bn(t, i)) return;
        Aw.set(i), n.uniformMatrix3fv(this.addr, !1, Aw), Hn(t, i);
    }
}
function bF(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Bn(t, e)) return;
        n.uniformMatrix4fv(this.addr, !1, e), Hn(t, e);
    } else {
        if (Bn(t, i)) return;
        Tw.set(i), n.uniformMatrix4fv(this.addr, !1, Tw), Hn(t, i);
    }
}
function RF(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function PF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (Bn(t, e)) return;
        n.uniform2iv(this.addr, e), Hn(t, e);
    }
}
function LF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3i(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
    else {
        if (Bn(t, e)) return;
        n.uniform3iv(this.addr, e), Hn(t, e);
    }
}
function IF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (Bn(t, e)) return;
        n.uniform4iv(this.addr, e), Hn(t, e);
    }
}
function NF(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function DF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (Bn(t, e)) return;
        n.uniform2uiv(this.addr, e), Hn(t, e);
    }
}
function UF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3ui(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
    else {
        if (Bn(t, e)) return;
        n.uniform3uiv(this.addr, e), Hn(t, e);
    }
}
function OF(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (Bn(t, e)) return;
        n.uniform4uiv(this.addr, e), Hn(t, e);
    }
}
function FF(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
    const s = this.type === n.SAMPLER_2D_SHADOW ? VC : HC;
    t.setTexture2D(e || s, r);
}
function kF(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTexture3D(e || WC, r);
}
function zF(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTextureCube(e || jC, r);
}
function BF(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTexture2DArray(e || GC, r);
}
function HF(n) {
    switch (n) {
        case 5126:
            return MF;
        case 35664:
            return wF;
        case 35665:
            return EF;
        case 35666:
            return TF;
        case 35674:
            return AF;
        case 35675:
            return CF;
        case 35676:
            return bF;
        case 5124:
        case 35670:
            return RF;
        case 35667:
        case 35671:
            return PF;
        case 35668:
        case 35672:
            return LF;
        case 35669:
        case 35673:
            return IF;
        case 5125:
            return NF;
        case 36294:
            return DF;
        case 36295:
            return UF;
        case 36296:
            return OF;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return FF;
        case 35679:
        case 36299:
        case 36307:
            return kF;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return zF;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return BF;
    }
}
function VF(n, e) {
    n.uniform1fv(this.addr, e);
}
function GF(n, e) {
    const t = Pu(e, this.size, 2);
    n.uniform2fv(this.addr, t);
}
function WF(n, e) {
    const t = Pu(e, this.size, 3);
    n.uniform3fv(this.addr, t);
}
function jF(n, e) {
    const t = Pu(e, this.size, 4);
    n.uniform4fv(this.addr, t);
}
function XF(n, e) {
    const t = Pu(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t);
}
function YF(n, e) {
    const t = Pu(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t);
}
function qF(n, e) {
    const t = Pu(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t);
}
function ZF(n, e) {
    n.uniform1iv(this.addr, e);
}
function KF(n, e) {
    n.uniform2iv(this.addr, e);
}
function JF(n, e) {
    n.uniform3iv(this.addr, e);
}
function QF(n, e) {
    n.uniform4iv(this.addr, e);
}
function $F(n, e) {
    n.uniform1uiv(this.addr, e);
}
function ek(n, e) {
    n.uniform2uiv(this.addr, e);
}
function tk(n, e) {
    n.uniform3uiv(this.addr, e);
}
function nk(n, e) {
    n.uniform4uiv(this.addr, e);
}
function ik(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Im(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s), Hn(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || HC, s[o]);
}
function rk(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Im(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s), Hn(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || WC, s[o]);
}
function sk(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Im(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s), Hn(i, s));
    for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || jC, s[o]);
}
function ok(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Im(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s), Hn(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || GC, s[o]);
}
function ak(n) {
    switch (n) {
        case 5126:
            return VF;
        case 35664:
            return GF;
        case 35665:
            return WF;
        case 35666:
            return jF;
        case 35674:
            return XF;
        case 35675:
            return YF;
        case 35676:
            return qF;
        case 5124:
        case 35670:
            return ZF;
        case 35667:
        case 35671:
            return KF;
        case 35668:
        case 35672:
            return JF;
        case 35669:
        case 35673:
            return QF;
        case 5125:
            return $F;
        case 36294:
            return ek;
        case 36295:
            return tk;
        case 36296:
            return nk;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return ik;
        case 35679:
        case 36299:
        case 36307:
            return rk;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return sk;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return ok;
    }
}
class lk {
    constructor(e, t, i) {
        (this.id = e),
            (this.addr = i),
            (this.cache = []),
            (this.type = t.type),
            (this.setValue = HF(t.type));
    }
}
class uk {
    constructor(e, t, i) {
        (this.id = e),
            (this.addr = i),
            (this.cache = []),
            (this.type = t.type),
            (this.size = t.size),
            (this.setValue = ak(t.type));
    }
}
class ck {
    constructor(e) {
        (this.id = e), (this.seq = []), (this.map = {});
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i);
        }
    }
}
const i0 = /(\w+)(\])?(\[|\.)?/g;
function bw(n, e) {
    n.seq.push(e), (n.map[e.id] = e);
}
function fk(n, e, t) {
    const i = n.name,
        r = i.length;
    for (i0.lastIndex = 0; ; ) {
        const s = i0.exec(i),
            o = i0.lastIndex;
        let a = s[1];
        const c = s[2] === ']',
            f = s[3];
        if ((c && (a = a | 0), f === void 0 || (f === '[' && o + 2 === r))) {
            bw(t, f === void 0 ? new lk(a, n, e) : new uk(a, n, e));
            break;
        } else {
            let h = t.map[a];
            h === void 0 && ((h = new ck(a)), bw(t, h)), (t = h);
        }
    }
}
class wp {
    constructor(e, t) {
        (this.seq = []), (this.map = {});
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r),
                o = e.getUniformLocation(t, s.name);
            fk(s, o, this);
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r);
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r);
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s],
                c = i[a.id];
            c.needsUpdate !== !1 && a.setValue(e, c.value, r);
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o);
        }
        return i;
    }
}
function Rw(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t), n.compileShader(i), i;
}
const dk = 37297;
let hk = 0;
function pk(n, e) {
    const t = n.split(`
`),
        i = [],
        r = Math.max(e - 6, 0),
        s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? '>' : ' '} ${a}: ${t[o]}`);
    }
    return i.join(`
`);
}
function mk(n) {
    const e = Gt.getPrimaries(Gt.workingColorSpace),
        t = Gt.getPrimaries(n);
    let i;
    switch (
        (e === t
            ? (i = '')
            : e === xf && t === yf
            ? (i = 'LinearDisplayP3ToLinearSRGB')
            : e === yf && t === xf && (i = 'LinearSRGBToLinearDisplayP3'),
        n)
    ) {
        case Ys:
        case Bf:
            return [i, 'LinearTransferOETF'];
        case _r:
        case Pm:
            return [i, 'sRGBTransferOETF'];
        default:
            return (
                console.warn('THREE.WebGLProgram: Unsupported color space:', n),
                [i, 'LinearTransferOETF']
            );
    }
}
function Pw(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS),
        r = n.getShaderInfoLog(e).trim();
    if (i && r === '') return '';
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return (
            t.toUpperCase() +
            `

` +
            r +
            `

` +
            pk(n.getShaderSource(e), o)
        );
    } else return r;
}
function gk(n, e) {
    const t = mk(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function vk(n, e) {
    let t;
    switch (e) {
        case rC:
            t = 'Linear';
            break;
        case sC:
            t = 'Reinhard';
            break;
        case oC:
            t = 'OptimizedCineon';
            break;
        case _x:
            t = 'ACESFilmic';
            break;
        case lC:
            t = 'AgX';
            break;
        case uC:
            t = 'Neutral';
            break;
        case aC:
            t = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (t = 'Linear');
    }
    return 'vec3 ' + n + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }';
}
function _k(n) {
    return [
        n.extensionDerivatives ||
        n.envMapCubeUVHeight ||
        n.bumpMap ||
        n.normalMapTangentSpace ||
        n.clearcoatNormalMap ||
        n.flatShading ||
        n.alphaToCoverage ||
        n.shaderID === 'physical'
            ? '#extension GL_OES_standard_derivatives : enable'
            : '',
        (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth
            ? '#extension GL_EXT_frag_depth : enable'
            : '',
        n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
            ? '#extension GL_EXT_draw_buffers : require'
            : '',
        (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
        n.rendererExtensionShaderTextureLod
            ? '#extension GL_EXT_shader_texture_lod : enable'
            : '',
    ].filter(Ql).join(`
`);
}
function yk(n) {
    return [
        n.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
        n.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
    ].filter(Ql).join(`
`);
}
function xk(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push('#define ' + t + ' ' + i);
    }
    return e.join(`
`);
}
function Sk(n, e) {
    const t = {},
        i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r),
            o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
            s.type === n.FLOAT_MAT3 && (a = 3),
            s.type === n.FLOAT_MAT4 && (a = 4),
            (t[o] = { type: s.type, location: n.getAttribLocation(e, o), locationSize: a });
    }
    return t;
}
function Ql(n) {
    return n !== '';
}
function Lw(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
        .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Iw(n, e) {
    return n
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Mk = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ay(n) {
    return n.replace(Mk, Ek);
}
const wk = new Map([
    ['encodings_fragment', 'colorspace_fragment'],
    ['encodings_pars_fragment', 'colorspace_pars_fragment'],
    ['output_fragment', 'opaque_fragment'],
]);
function Ek(n, e) {
    let t = Ct[e];
    if (t === void 0) {
        const i = wk.get(e);
        if (i !== void 0)
            (t = Ct[i]),
                console.warn(
                    'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
                    e,
                    i
                );
        else throw new Error('Can not resolve #include <' + e + '>');
    }
    return ay(t);
}
const Tk =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Nw(n) {
    return n.replace(Tk, Ak);
}
function Ak(n, e, t, i) {
    let r = '';
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, '[ ' + s + ' ]').replace(/UNROLLED_LOOP_INDEX/g, s);
    return r;
}
function Dw(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	`;
    return (
        n.isWebGL2 &&
            (e += `precision ${n.precision} sampler3D;
		precision ${n.precision} sampler2DArray;
		precision ${n.precision} sampler2DShadow;
		precision ${n.precision} samplerCubeShadow;
		precision ${n.precision} sampler2DArrayShadow;
		precision ${n.precision} isampler2D;
		precision ${n.precision} isampler3D;
		precision ${n.precision} isamplerCube;
		precision ${n.precision} isampler2DArray;
		precision ${n.precision} usampler2D;
		precision ${n.precision} usampler3D;
		precision ${n.precision} usamplerCube;
		precision ${n.precision} usampler2DArray;
		`),
        n.precision === 'highp'
            ? (e += `
#define HIGH_PRECISION`)
            : n.precision === 'mediump'
            ? (e += `
#define MEDIUM_PRECISION`)
            : n.precision === 'lowp' &&
              (e += `
#define LOW_PRECISION`),
        e
    );
}
function Ck(n) {
    let e = 'SHADOWMAP_TYPE_BASIC';
    return (
        n.shadowMapType === Am
            ? (e = 'SHADOWMAP_TYPE_PCF')
            : n.shadowMapType === Bc
            ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
            : n.shadowMapType === Dr && (e = 'SHADOWMAP_TYPE_VSM'),
        e
    );
}
function bk(n) {
    let e = 'ENVMAP_TYPE_CUBE';
    if (n.envMap)
        switch (n.envMapMode) {
            case Ws:
            case Fo:
                e = 'ENVMAP_TYPE_CUBE';
                break;
            case Cu:
                e = 'ENVMAP_TYPE_CUBE_UV';
                break;
        }
    return e;
}
function Rk(n) {
    let e = 'ENVMAP_MODE_REFLECTION';
    if (n.envMap)
        switch (n.envMapMode) {
            case Fo:
                e = 'ENVMAP_MODE_REFRACTION';
                break;
        }
    return e;
}
function Pk(n) {
    let e = 'ENVMAP_BLENDING_NONE';
    if (n.envMap)
        switch (n.combine) {
            case zf:
                e = 'ENVMAP_BLENDING_MULTIPLY';
                break;
            case nC:
                e = 'ENVMAP_BLENDING_MIX';
                break;
            case iC:
                e = 'ENVMAP_BLENDING_ADD';
                break;
        }
    return e;
}
function Lk(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2,
        i = 1 / e;
    return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function Ik(n, e, t, i) {
    const r = n.getContext(),
        s = t.defines;
    let o = t.vertexShader,
        a = t.fragmentShader;
    const c = Ck(t),
        f = bk(t),
        d = Rk(t),
        h = Pk(t),
        p = Lk(t),
        v = t.isWebGL2 ? '' : _k(t),
        _ = yk(t),
        w = xk(s),
        x = r.createProgram();
    let g,
        S,
        M = t.glslVersion
            ? '#version ' +
              t.glslVersion +
              `
`
            : '';
    t.isRawShaderMaterial
        ? ((g = [
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              w,
          ].filter(Ql).join(`
`)),
          g.length > 0 &&
              (g += `
`),
          (S = [
              v,
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              w,
          ].filter(Ql).join(`
`)),
          S.length > 0 &&
              (S += `
`))
        : ((g = [
              Dw(t),
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              w,
              t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
              t.batching ? '#define USE_BATCHING' : '',
              t.instancing ? '#define USE_INSTANCING' : '',
              t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
              t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
              t.useFog && t.fog ? '#define USE_FOG' : '',
              t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
              t.map ? '#define USE_MAP' : '',
              t.envMap ? '#define USE_ENVMAP' : '',
              t.envMap ? '#define ' + d : '',
              t.lightMap ? '#define USE_LIGHTMAP' : '',
              t.aoMap ? '#define USE_AOMAP' : '',
              t.bumpMap ? '#define USE_BUMPMAP' : '',
              t.normalMap ? '#define USE_NORMALMAP' : '',
              t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
              t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
              t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
              t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              t.anisotropy ? '#define USE_ANISOTROPY' : '',
              t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
              t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
              t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
              t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
              t.specularMap ? '#define USE_SPECULARMAP' : '',
              t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
              t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
              t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              t.metalnessMap ? '#define USE_METALNESSMAP' : '',
              t.alphaMap ? '#define USE_ALPHAMAP' : '',
              t.alphaHash ? '#define USE_ALPHAHASH' : '',
              t.transmission ? '#define USE_TRANSMISSION' : '',
              t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
              t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
              t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
              t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
              t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
              t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
              t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
              t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
              t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
              t.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv : '',
              t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
              t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
              t.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv : '',
              t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
              t.clearcoatNormalMapUv
                  ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv
                  : '',
              t.clearcoatRoughnessMapUv
                  ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv
                  : '',
              t.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv : '',
              t.iridescenceThicknessMapUv
                  ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv
                  : '',
              t.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv : '',
              t.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv : '',
              t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
              t.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv : '',
              t.specularIntensityMapUv
                  ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv
                  : '',
              t.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv : '',
              t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
              t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
              t.vertexColors ? '#define USE_COLOR' : '',
              t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              t.vertexUv1s ? '#define USE_UV1' : '',
              t.vertexUv2s ? '#define USE_UV2' : '',
              t.vertexUv3s ? '#define USE_UV3' : '',
              t.pointsUvs ? '#define USE_POINTS_UV' : '',
              t.flatShading ? '#define FLAT_SHADED' : '',
              t.skinning ? '#define USE_SKINNING' : '',
              t.morphTargets ? '#define USE_MORPHTARGETS' : '',
              t.morphNormals && t.flatShading === !1 ? '#define USE_MORPHNORMALS' : '',
              t.morphColors && t.isWebGL2 ? '#define USE_MORPHCOLORS' : '',
              t.morphTargetsCount > 0 && t.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '',
              t.morphTargetsCount > 0 && t.isWebGL2
                  ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride
                  : '',
              t.morphTargetsCount > 0 && t.isWebGL2
                  ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount
                  : '',
              t.doubleSided ? '#define DOUBLE_SIDED' : '',
              t.flipSided ? '#define FLIP_SIDED' : '',
              t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              t.shadowMapEnabled ? '#define ' + c : '',
              t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
              t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
              t.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
              t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                  ? '#define USE_LOGDEPTHBUF_EXT'
                  : '',
              'uniform mat4 modelMatrix;',
              'uniform mat4 modelViewMatrix;',
              'uniform mat4 projectionMatrix;',
              'uniform mat4 viewMatrix;',
              'uniform mat3 normalMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              '#ifdef USE_INSTANCING',
              '	attribute mat4 instanceMatrix;',
              '#endif',
              '#ifdef USE_INSTANCING_COLOR',
              '	attribute vec3 instanceColor;',
              '#endif',
              '#ifdef USE_INSTANCING_MORPH',
              '	uniform sampler2D morphTexture;',
              '#endif',
              'attribute vec3 position;',
              'attribute vec3 normal;',
              'attribute vec2 uv;',
              '#ifdef USE_UV1',
              '	attribute vec2 uv1;',
              '#endif',
              '#ifdef USE_UV2',
              '	attribute vec2 uv2;',
              '#endif',
              '#ifdef USE_UV3',
              '	attribute vec2 uv3;',
              '#endif',
              '#ifdef USE_TANGENT',
              '	attribute vec4 tangent;',
              '#endif',
              '#if defined( USE_COLOR_ALPHA )',
              '	attribute vec4 color;',
              '#elif defined( USE_COLOR )',
              '	attribute vec3 color;',
              '#endif',
              '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
              '	attribute vec3 morphTarget0;',
              '	attribute vec3 morphTarget1;',
              '	attribute vec3 morphTarget2;',
              '	attribute vec3 morphTarget3;',
              '	#ifdef USE_MORPHNORMALS',
              '		attribute vec3 morphNormal0;',
              '		attribute vec3 morphNormal1;',
              '		attribute vec3 morphNormal2;',
              '		attribute vec3 morphNormal3;',
              '	#else',
              '		attribute vec3 morphTarget4;',
              '		attribute vec3 morphTarget5;',
              '		attribute vec3 morphTarget6;',
              '		attribute vec3 morphTarget7;',
              '	#endif',
              '#endif',
              '#ifdef USE_SKINNING',
              '	attribute vec4 skinIndex;',
              '	attribute vec4 skinWeight;',
              '#endif',
              `
`,
          ].filter(Ql).join(`
`)),
          (S = [
              v,
              Dw(t),
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              w,
              t.useFog && t.fog ? '#define USE_FOG' : '',
              t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
              t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
              t.map ? '#define USE_MAP' : '',
              t.matcap ? '#define USE_MATCAP' : '',
              t.envMap ? '#define USE_ENVMAP' : '',
              t.envMap ? '#define ' + f : '',
              t.envMap ? '#define ' + d : '',
              t.envMap ? '#define ' + h : '',
              p ? '#define CUBEUV_TEXEL_WIDTH ' + p.texelWidth : '',
              p ? '#define CUBEUV_TEXEL_HEIGHT ' + p.texelHeight : '',
              p ? '#define CUBEUV_MAX_MIP ' + p.maxMip + '.0' : '',
              t.lightMap ? '#define USE_LIGHTMAP' : '',
              t.aoMap ? '#define USE_AOMAP' : '',
              t.bumpMap ? '#define USE_BUMPMAP' : '',
              t.normalMap ? '#define USE_NORMALMAP' : '',
              t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
              t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
              t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              t.anisotropy ? '#define USE_ANISOTROPY' : '',
              t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
              t.clearcoat ? '#define USE_CLEARCOAT' : '',
              t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
              t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              t.iridescence ? '#define USE_IRIDESCENCE' : '',
              t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
              t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
              t.specularMap ? '#define USE_SPECULARMAP' : '',
              t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
              t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
              t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              t.metalnessMap ? '#define USE_METALNESSMAP' : '',
              t.alphaMap ? '#define USE_ALPHAMAP' : '',
              t.alphaTest ? '#define USE_ALPHATEST' : '',
              t.alphaHash ? '#define USE_ALPHAHASH' : '',
              t.sheen ? '#define USE_SHEEN' : '',
              t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
              t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
              t.transmission ? '#define USE_TRANSMISSION' : '',
              t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
              t.vertexColors || t.instancingColor ? '#define USE_COLOR' : '',
              t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              t.vertexUv1s ? '#define USE_UV1' : '',
              t.vertexUv2s ? '#define USE_UV2' : '',
              t.vertexUv3s ? '#define USE_UV3' : '',
              t.pointsUvs ? '#define USE_POINTS_UV' : '',
              t.gradientMap ? '#define USE_GRADIENTMAP' : '',
              t.flatShading ? '#define FLAT_SHADED' : '',
              t.doubleSided ? '#define DOUBLE_SIDED' : '',
              t.flipSided ? '#define FLIP_SIDED' : '',
              t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              t.shadowMapEnabled ? '#define ' + c : '',
              t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
              t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
              t.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
              t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
              t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                  ? '#define USE_LOGDEPTHBUF_EXT'
                  : '',
              'uniform mat4 viewMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              t.toneMapping !== fs ? '#define TONE_MAPPING' : '',
              t.toneMapping !== fs ? Ct.tonemapping_pars_fragment : '',
              t.toneMapping !== fs ? vk('toneMapping', t.toneMapping) : '',
              t.dithering ? '#define DITHERING' : '',
              t.opaque ? '#define OPAQUE' : '',
              Ct.colorspace_pars_fragment,
              gk('linearToOutputTexel', t.outputColorSpace),
              t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
              `
`,
          ].filter(Ql).join(`
`))),
        (o = ay(o)),
        (o = Lw(o, t)),
        (o = Iw(o, t)),
        (a = ay(a)),
        (a = Lw(a, t)),
        (a = Iw(a, t)),
        (o = Nw(o)),
        (a = Nw(a)),
        t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((M = `#version 300 es
`),
            (g =
                [
                    _,
                    'precision mediump sampler2DArray;',
                    '#define attribute in',
                    '#define varying out',
                    '#define texture2D texture',
                ].join(`
`) +
                `
` +
                g),
            (S =
                [
                    'precision mediump sampler2DArray;',
                    '#define varying in',
                    t.glslVersion === ry ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
                    t.glslVersion === ry ? '' : '#define gl_FragColor pc_fragColor',
                    '#define gl_FragDepthEXT gl_FragDepth',
                    '#define texture2D texture',
                    '#define textureCube texture',
                    '#define texture2DProj textureProj',
                    '#define texture2DLodEXT textureLod',
                    '#define texture2DProjLodEXT textureProjLod',
                    '#define textureCubeLodEXT textureLod',
                    '#define texture2DGradEXT textureGrad',
                    '#define texture2DProjGradEXT textureProjGrad',
                    '#define textureCubeGradEXT textureGrad',
                ].join(`
`) +
                `
` +
                S));
    const T = M + g + o,
        P = M + S + a,
        A = Rw(r, r.VERTEX_SHADER, T),
        R = Rw(r, r.FRAGMENT_SHADER, P);
    r.attachShader(x, A),
        r.attachShader(x, R),
        t.index0AttributeName !== void 0
            ? r.bindAttribLocation(x, 0, t.index0AttributeName)
            : t.morphTargets === !0 && r.bindAttribLocation(x, 0, 'position'),
        r.linkProgram(x);
    function D(ee) {
        if (n.debug.checkShaderErrors) {
            const ie = r.getProgramInfoLog(x).trim(),
                j = r.getShaderInfoLog(A).trim(),
                oe = r.getShaderInfoLog(R).trim();
            let te = !0,
                ae = !0;
            if (r.getProgramParameter(x, r.LINK_STATUS) === !1)
                if (((te = !1), typeof n.debug.onShaderError == 'function'))
                    n.debug.onShaderError(r, x, A, R);
                else {
                    const N = Pw(r, A, 'vertex'),
                        B = Pw(r, R, 'fragment');
                    console.error(
                        'THREE.WebGLProgram: Shader Error ' +
                            r.getError() +
                            ' - VALIDATE_STATUS ' +
                            r.getProgramParameter(x, r.VALIDATE_STATUS) +
                            `

Material Name: ` +
                            ee.name +
                            `
Material Type: ` +
                            ee.type +
                            `

Program Info Log: ` +
                            ie +
                            `
` +
                            N +
                            `
` +
                            B
                    );
                }
            else
                ie !== ''
                    ? console.warn('THREE.WebGLProgram: Program Info Log:', ie)
                    : (j === '' || oe === '') && (ae = !1);
            ae &&
                (ee.diagnostics = {
                    runnable: te,
                    programLog: ie,
                    vertexShader: { log: j, prefix: g },
                    fragmentShader: { log: oe, prefix: S },
                });
        }
        r.deleteShader(A), r.deleteShader(R), (G = new wp(r, x)), (b = Sk(r, x));
    }
    let G;
    this.getUniforms = function () {
        return G === void 0 && D(this), G;
    };
    let b;
    this.getAttributes = function () {
        return b === void 0 && D(this), b;
    };
    let L = t.rendererExtensionParallelShaderCompile === !1;
    return (
        (this.isReady = function () {
            return L === !1 && (L = r.getProgramParameter(x, dk)), L;
        }),
        (this.destroy = function () {
            i.releaseStatesOfProgram(this), r.deleteProgram(x), (this.program = void 0);
        }),
        (this.type = t.shaderType),
        (this.name = t.shaderName),
        (this.id = hk++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = x),
        (this.vertexShader = A),
        (this.fragmentShader = R),
        this
    );
}
let Nk = 0;
class Dk {
    constructor() {
        (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(e) {
        const t = e.vertexShader,
            i = e.fragmentShader,
            r = this._getShaderStage(t),
            s = this._getShaderStage(i),
            o = this._getShaderCacheForMaterial(e);
        return (
            o.has(r) === !1 && (o.add(r), r.usedTimes++),
            o.has(s) === !1 && (o.add(s), s.usedTimes++),
            this
        );
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && ((i = new Set()), t.set(e, i)), i;
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && ((i = new Uk(e)), t.set(e, i)), i;
    }
}
class Uk {
    constructor(e) {
        (this.id = Nk++), (this.code = e), (this.usedTimes = 0);
    }
}
function Ok(n, e, t, i, r, s, o) {
    const a = new Da(),
        c = new Dk(),
        f = new Set(),
        d = [],
        h = r.isWebGL2,
        p = r.logarithmicDepthBuffer,
        v = r.vertexTextures;
    let _ = r.precision;
    const w = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite',
    };
    function x(b) {
        return f.add(b), b === 0 ? 'uv' : `uv${b}`;
    }
    function g(b, L, ee, ie, j) {
        const oe = ie.fog,
            te = j.geometry,
            ae = b.isMeshStandardMaterial ? ie.environment : null,
            N = (b.isMeshStandardMaterial ? t : e).get(b.envMap || ae),
            B = N && N.mapping === Cu ? N.image.height : null,
            H = w[b.type];
        b.precision !== null &&
            ((_ = r.getMaxPrecision(b.precision)),
            _ !== b.precision &&
                console.warn(
                    'THREE.WebGLProgram.getParameters:',
                    b.precision,
                    'not supported, using',
                    _,
                    'instead.'
                ));
        const K =
                te.morphAttributes.position ||
                te.morphAttributes.normal ||
                te.morphAttributes.color,
            le = K !== void 0 ? K.length : 0;
        let be = 0;
        te.morphAttributes.position !== void 0 && (be = 1),
            te.morphAttributes.normal !== void 0 && (be = 2),
            te.morphAttributes.color !== void 0 && (be = 3);
        let Q, me, Se, ke;
        if (H) {
            const Ce = kr[H];
            (Q = Ce.vertexShader), (me = Ce.fragmentShader);
        } else
            (Q = b.vertexShader),
                (me = b.fragmentShader),
                c.update(b),
                (Se = c.getVertexShaderID(b)),
                (ke = c.getFragmentShaderID(b));
        const et = n.getRenderTarget(),
            Xe = j.isInstancedMesh === !0,
            gt = j.isBatchedMesh === !0,
            De = !!b.map,
            V = !!b.matcap,
            we = !!N,
            ve = !!b.aoMap,
            Ee = !!b.lightMap,
            ye = !!b.bumpMap,
            We = !!b.normalMap,
            He = !!b.displacementMap,
            Ke = !!b.emissiveMap,
            yt = !!b.metalnessMap,
            F = !!b.roughnessMap,
            I = b.anisotropy > 0,
            ce = b.clearcoat > 0,
            de = b.iridescence > 0,
            Me = b.sheen > 0,
            xe = b.transmission > 0,
            ut = I && !!b.anisotropyMap,
            at = ce && !!b.clearcoatMap,
            Ae = ce && !!b.clearcoatNormalMap,
            Ie = ce && !!b.clearcoatRoughnessMap,
            ht = de && !!b.iridescenceMap,
            Pe = de && !!b.iridescenceThicknessMap,
            nn = Me && !!b.sheenColorMap,
            wt = Me && !!b.sheenRoughnessMap,
            rt = !!b.specularMap,
            tt = !!b.specularColorMap,
            Qe = !!b.specularIntensityMap,
            Lt = xe && !!b.transmissionMap,
            vt = xe && !!b.thicknessMap,
            Xt = !!b.gradientMap,
            q = !!b.alphaMap,
            Fe = b.alphaTest > 0,
            U = !!b.alphaHash,
            W = !!b.extensions;
        let Y = fs;
        b.toneMapped && (et === null || et.isXRRenderTarget === !0) && (Y = n.toneMapping);
        const ge = {
            isWebGL2: h,
            shaderID: H,
            shaderType: b.type,
            shaderName: b.name,
            vertexShader: Q,
            fragmentShader: me,
            defines: b.defines,
            customVertexShaderID: Se,
            customFragmentShaderID: ke,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: _,
            batching: gt,
            instancing: Xe,
            instancingColor: Xe && j.instanceColor !== null,
            instancingMorph: Xe && j.morphTexture !== null,
            supportsVertexTextures: v,
            outputColorSpace:
                et === null
                    ? n.outputColorSpace
                    : et.isXRRenderTarget === !0
                    ? et.texture.colorSpace
                    : Ys,
            alphaToCoverage: !!b.alphaToCoverage,
            map: De,
            matcap: V,
            envMap: we,
            envMapMode: we && N.mapping,
            envMapCubeUVHeight: B,
            aoMap: ve,
            lightMap: Ee,
            bumpMap: ye,
            normalMap: We,
            displacementMap: v && He,
            emissiveMap: Ke,
            normalMapObjectSpace: We && b.normalMapType === wC,
            normalMapTangentSpace: We && b.normalMapType === Vo,
            metalnessMap: yt,
            roughnessMap: F,
            anisotropy: I,
            anisotropyMap: ut,
            clearcoat: ce,
            clearcoatMap: at,
            clearcoatNormalMap: Ae,
            clearcoatRoughnessMap: Ie,
            iridescence: de,
            iridescenceMap: ht,
            iridescenceThicknessMap: Pe,
            sheen: Me,
            sheenColorMap: nn,
            sheenRoughnessMap: wt,
            specularMap: rt,
            specularColorMap: tt,
            specularIntensityMap: Qe,
            transmission: xe,
            transmissionMap: Lt,
            thicknessMap: vt,
            gradientMap: Xt,
            opaque: b.transparent === !1 && b.blending === Ia && b.alphaToCoverage === !1,
            alphaMap: q,
            alphaTest: Fe,
            alphaHash: U,
            combine: b.combine,
            mapUv: De && x(b.map.channel),
            aoMapUv: ve && x(b.aoMap.channel),
            lightMapUv: Ee && x(b.lightMap.channel),
            bumpMapUv: ye && x(b.bumpMap.channel),
            normalMapUv: We && x(b.normalMap.channel),
            displacementMapUv: He && x(b.displacementMap.channel),
            emissiveMapUv: Ke && x(b.emissiveMap.channel),
            metalnessMapUv: yt && x(b.metalnessMap.channel),
            roughnessMapUv: F && x(b.roughnessMap.channel),
            anisotropyMapUv: ut && x(b.anisotropyMap.channel),
            clearcoatMapUv: at && x(b.clearcoatMap.channel),
            clearcoatNormalMapUv: Ae && x(b.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Ie && x(b.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ht && x(b.iridescenceMap.channel),
            iridescenceThicknessMapUv: Pe && x(b.iridescenceThicknessMap.channel),
            sheenColorMapUv: nn && x(b.sheenColorMap.channel),
            sheenRoughnessMapUv: wt && x(b.sheenRoughnessMap.channel),
            specularMapUv: rt && x(b.specularMap.channel),
            specularColorMapUv: tt && x(b.specularColorMap.channel),
            specularIntensityMapUv: Qe && x(b.specularIntensityMap.channel),
            transmissionMapUv: Lt && x(b.transmissionMap.channel),
            thicknessMapUv: vt && x(b.thicknessMap.channel),
            alphaMapUv: q && x(b.alphaMap.channel),
            vertexTangents: !!te.attributes.tangent && (We || I),
            vertexColors: b.vertexColors,
            vertexAlphas:
                b.vertexColors === !0 &&
                !!te.attributes.color &&
                te.attributes.color.itemSize === 4,
            pointsUvs: j.isPoints === !0 && !!te.attributes.uv && (De || q),
            fog: !!oe,
            useFog: b.fog === !0,
            fogExp2: !!oe && oe.isFogExp2,
            flatShading: b.flatShading === !0,
            sizeAttenuation: b.sizeAttenuation === !0,
            logarithmicDepthBuffer: p,
            skinning: j.isSkinnedMesh === !0,
            morphTargets: te.morphAttributes.position !== void 0,
            morphNormals: te.morphAttributes.normal !== void 0,
            morphColors: te.morphAttributes.color !== void 0,
            morphTargetsCount: le,
            morphTextureStride: be,
            numDirLights: L.directional.length,
            numPointLights: L.point.length,
            numSpotLights: L.spot.length,
            numSpotLightMaps: L.spotLightMap.length,
            numRectAreaLights: L.rectArea.length,
            numHemiLights: L.hemi.length,
            numDirLightShadows: L.directionalShadowMap.length,
            numPointLightShadows: L.pointShadowMap.length,
            numSpotLightShadows: L.spotShadowMap.length,
            numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
            numLightProbes: L.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: n.shadowMap.enabled && ee.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Y,
            useLegacyLights: n._useLegacyLights,
            decodeVideoTexture:
                De && b.map.isVideoTexture === !0 && Gt.getTransfer(b.map.colorSpace) === Jt,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === os,
            flipSided: b.side === Ai,
            useDepthPacking: b.depthPacking >= 0,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionDerivatives: W && b.extensions.derivatives === !0,
            extensionFragDepth: W && b.extensions.fragDepth === !0,
            extensionDrawBuffers: W && b.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: W && b.extensions.shaderTextureLOD === !0,
            extensionClipCullDistance:
                W && b.extensions.clipCullDistance === !0 && i.has('WEBGL_clip_cull_distance'),
            extensionMultiDraw: W && b.extensions.multiDraw === !0 && i.has('WEBGL_multi_draw'),
            rendererExtensionFragDepth: h || i.has('EXT_frag_depth'),
            rendererExtensionDrawBuffers: h || i.has('WEBGL_draw_buffers'),
            rendererExtensionShaderTextureLod: h || i.has('EXT_shader_texture_lod'),
            rendererExtensionParallelShaderCompile: i.has('KHR_parallel_shader_compile'),
            customProgramCacheKey: b.customProgramCacheKey(),
        };
        return (
            (ge.vertexUv1s = f.has(1)),
            (ge.vertexUv2s = f.has(2)),
            (ge.vertexUv3s = f.has(3)),
            f.clear(),
            ge
        );
    }
    function S(b) {
        const L = [];
        if (
            (b.shaderID
                ? L.push(b.shaderID)
                : (L.push(b.customVertexShaderID), L.push(b.customFragmentShaderID)),
            b.defines !== void 0)
        )
            for (const ee in b.defines) L.push(ee), L.push(b.defines[ee]);
        return (
            b.isRawShaderMaterial === !1 && (M(L, b), T(L, b), L.push(n.outputColorSpace)),
            L.push(b.customProgramCacheKey),
            L.join()
        );
    }
    function M(b, L) {
        b.push(L.precision),
            b.push(L.outputColorSpace),
            b.push(L.envMapMode),
            b.push(L.envMapCubeUVHeight),
            b.push(L.mapUv),
            b.push(L.alphaMapUv),
            b.push(L.lightMapUv),
            b.push(L.aoMapUv),
            b.push(L.bumpMapUv),
            b.push(L.normalMapUv),
            b.push(L.displacementMapUv),
            b.push(L.emissiveMapUv),
            b.push(L.metalnessMapUv),
            b.push(L.roughnessMapUv),
            b.push(L.anisotropyMapUv),
            b.push(L.clearcoatMapUv),
            b.push(L.clearcoatNormalMapUv),
            b.push(L.clearcoatRoughnessMapUv),
            b.push(L.iridescenceMapUv),
            b.push(L.iridescenceThicknessMapUv),
            b.push(L.sheenColorMapUv),
            b.push(L.sheenRoughnessMapUv),
            b.push(L.specularMapUv),
            b.push(L.specularColorMapUv),
            b.push(L.specularIntensityMapUv),
            b.push(L.transmissionMapUv),
            b.push(L.thicknessMapUv),
            b.push(L.combine),
            b.push(L.fogExp2),
            b.push(L.sizeAttenuation),
            b.push(L.morphTargetsCount),
            b.push(L.morphAttributeCount),
            b.push(L.numDirLights),
            b.push(L.numPointLights),
            b.push(L.numSpotLights),
            b.push(L.numSpotLightMaps),
            b.push(L.numHemiLights),
            b.push(L.numRectAreaLights),
            b.push(L.numDirLightShadows),
            b.push(L.numPointLightShadows),
            b.push(L.numSpotLightShadows),
            b.push(L.numSpotLightShadowsWithMaps),
            b.push(L.numLightProbes),
            b.push(L.shadowMapType),
            b.push(L.toneMapping),
            b.push(L.numClippingPlanes),
            b.push(L.numClipIntersection),
            b.push(L.depthPacking);
    }
    function T(b, L) {
        a.disableAll(),
            L.isWebGL2 && a.enable(0),
            L.supportsVertexTextures && a.enable(1),
            L.instancing && a.enable(2),
            L.instancingColor && a.enable(3),
            L.instancingMorph && a.enable(4),
            L.matcap && a.enable(5),
            L.envMap && a.enable(6),
            L.normalMapObjectSpace && a.enable(7),
            L.normalMapTangentSpace && a.enable(8),
            L.clearcoat && a.enable(9),
            L.iridescence && a.enable(10),
            L.alphaTest && a.enable(11),
            L.vertexColors && a.enable(12),
            L.vertexAlphas && a.enable(13),
            L.vertexUv1s && a.enable(14),
            L.vertexUv2s && a.enable(15),
            L.vertexUv3s && a.enable(16),
            L.vertexTangents && a.enable(17),
            L.anisotropy && a.enable(18),
            L.alphaHash && a.enable(19),
            L.batching && a.enable(20),
            b.push(a.mask),
            a.disableAll(),
            L.fog && a.enable(0),
            L.useFog && a.enable(1),
            L.flatShading && a.enable(2),
            L.logarithmicDepthBuffer && a.enable(3),
            L.skinning && a.enable(4),
            L.morphTargets && a.enable(5),
            L.morphNormals && a.enable(6),
            L.morphColors && a.enable(7),
            L.premultipliedAlpha && a.enable(8),
            L.shadowMapEnabled && a.enable(9),
            L.useLegacyLights && a.enable(10),
            L.doubleSided && a.enable(11),
            L.flipSided && a.enable(12),
            L.useDepthPacking && a.enable(13),
            L.dithering && a.enable(14),
            L.transmission && a.enable(15),
            L.sheen && a.enable(16),
            L.opaque && a.enable(17),
            L.pointsUvs && a.enable(18),
            L.decodeVideoTexture && a.enable(19),
            L.alphaToCoverage && a.enable(20),
            b.push(a.mask);
    }
    function P(b) {
        const L = w[b.type];
        let ee;
        if (L) {
            const ie = kr[L];
            ee = FC.clone(ie.uniforms);
        } else ee = b.uniforms;
        return ee;
    }
    function A(b, L) {
        let ee;
        for (let ie = 0, j = d.length; ie < j; ie++) {
            const oe = d[ie];
            if (oe.cacheKey === L) {
                (ee = oe), ++ee.usedTimes;
                break;
            }
        }
        return ee === void 0 && ((ee = new Ik(n, L, b, s)), d.push(ee)), ee;
    }
    function R(b) {
        if (--b.usedTimes === 0) {
            const L = d.indexOf(b);
            (d[L] = d[d.length - 1]), d.pop(), b.destroy();
        }
    }
    function D(b) {
        c.remove(b);
    }
    function G() {
        c.dispose();
    }
    return {
        getParameters: g,
        getProgramCacheKey: S,
        getUniforms: P,
        acquireProgram: A,
        releaseProgram: R,
        releaseShaderCache: D,
        programs: d,
        dispose: G,
    };
}
function Fk() {
    let n = new WeakMap();
    function e(s) {
        let o = n.get(s);
        return o === void 0 && ((o = {}), n.set(s, o)), o;
    }
    function t(s) {
        n.delete(s);
    }
    function i(s, o, a) {
        n.get(s)[o] = a;
    }
    function r() {
        n = new WeakMap();
    }
    return { get: e, remove: t, update: i, dispose: r };
}
function kk(n, e) {
    return n.groupOrder !== e.groupOrder
        ? n.groupOrder - e.groupOrder
        : n.renderOrder !== e.renderOrder
        ? n.renderOrder - e.renderOrder
        : n.material.id !== e.material.id
        ? n.material.id - e.material.id
        : n.z !== e.z
        ? n.z - e.z
        : n.id - e.id;
}
function Uw(n, e) {
    return n.groupOrder !== e.groupOrder
        ? n.groupOrder - e.groupOrder
        : n.renderOrder !== e.renderOrder
        ? n.renderOrder - e.renderOrder
        : n.z !== e.z
        ? e.z - n.z
        : n.id - e.id;
}
function Ow() {
    const n = [];
    let e = 0;
    const t = [],
        i = [],
        r = [];
    function s() {
        (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
    }
    function o(h, p, v, _, w, x) {
        let g = n[e];
        return (
            g === void 0
                ? ((g = {
                      id: h.id,
                      object: h,
                      geometry: p,
                      material: v,
                      groupOrder: _,
                      renderOrder: h.renderOrder,
                      z: w,
                      group: x,
                  }),
                  (n[e] = g))
                : ((g.id = h.id),
                  (g.object = h),
                  (g.geometry = p),
                  (g.material = v),
                  (g.groupOrder = _),
                  (g.renderOrder = h.renderOrder),
                  (g.z = w),
                  (g.group = x)),
            e++,
            g
        );
    }
    function a(h, p, v, _, w, x) {
        const g = o(h, p, v, _, w, x);
        v.transmission > 0 ? i.push(g) : v.transparent === !0 ? r.push(g) : t.push(g);
    }
    function c(h, p, v, _, w, x) {
        const g = o(h, p, v, _, w, x);
        v.transmission > 0 ? i.unshift(g) : v.transparent === !0 ? r.unshift(g) : t.unshift(g);
    }
    function f(h, p) {
        t.length > 1 && t.sort(h || kk),
            i.length > 1 && i.sort(p || Uw),
            r.length > 1 && r.sort(p || Uw);
    }
    function d() {
        for (let h = e, p = n.length; h < p; h++) {
            const v = n[h];
            if (v.id === null) break;
            (v.id = null),
                (v.object = null),
                (v.geometry = null),
                (v.material = null),
                (v.group = null);
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: c,
        finish: d,
        sort: f,
    };
}
function zk() {
    let n = new WeakMap();
    function e(i, r) {
        const s = n.get(i);
        let o;
        return (
            s === void 0
                ? ((o = new Ow()), n.set(i, [o]))
                : r >= s.length
                ? ((o = new Ow()), s.push(o))
                : (o = s[r]),
            o
        );
    }
    function t() {
        n = new WeakMap();
    }
    return { get: e, dispose: t };
}
function Bk() {
    const n = {};
    return {
        get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
                case 'DirectionalLight':
                    t = { direction: new k(), color: new je() };
                    break;
                case 'SpotLight':
                    t = {
                        position: new k(),
                        direction: new k(),
                        color: new je(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                    };
                    break;
                case 'PointLight':
                    t = { position: new k(), color: new je(), distance: 0, decay: 0 };
                    break;
                case 'HemisphereLight':
                    t = { direction: new k(), skyColor: new je(), groundColor: new je() };
                    break;
                case 'RectAreaLight':
                    t = {
                        color: new je(),
                        position: new k(),
                        halfWidth: new k(),
                        halfHeight: new k(),
                    };
                    break;
            }
            return (n[e.id] = t), t;
        },
    };
}
function Hk() {
    const n = {};
    return {
        get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
                case 'DirectionalLight':
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new _e(),
                    };
                    break;
                case 'SpotLight':
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new _e(),
                    };
                    break;
                case 'PointLight':
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new _e(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                    };
                    break;
            }
            return (n[e.id] = t), t;
        },
    };
}
let Vk = 0;
function Gk(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function Wk(n, e) {
    const t = new Bk(),
        i = Hk(),
        r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
        };
    for (let d = 0; d < 9; d++) r.probe.push(new k());
    const s = new k(),
        o = new ft(),
        a = new ft();
    function c(d, h) {
        let p = 0,
            v = 0,
            _ = 0;
        for (let ee = 0; ee < 9; ee++) r.probe[ee].set(0, 0, 0);
        let w = 0,
            x = 0,
            g = 0,
            S = 0,
            M = 0,
            T = 0,
            P = 0,
            A = 0,
            R = 0,
            D = 0,
            G = 0;
        d.sort(Gk);
        const b = h === !0 ? Math.PI : 1;
        for (let ee = 0, ie = d.length; ee < ie; ee++) {
            const j = d[ee],
                oe = j.color,
                te = j.intensity,
                ae = j.distance,
                N = j.shadow && j.shadow.map ? j.shadow.map.texture : null;
            if (j.isAmbientLight) (p += oe.r * te * b), (v += oe.g * te * b), (_ += oe.b * te * b);
            else if (j.isLightProbe) {
                for (let B = 0; B < 9; B++) r.probe[B].addScaledVector(j.sh.coefficients[B], te);
                G++;
            } else if (j.isDirectionalLight) {
                const B = t.get(j);
                if ((B.color.copy(j.color).multiplyScalar(j.intensity * b), j.castShadow)) {
                    const H = j.shadow,
                        K = i.get(j);
                    (K.shadowBias = H.bias),
                        (K.shadowNormalBias = H.normalBias),
                        (K.shadowRadius = H.radius),
                        (K.shadowMapSize = H.mapSize),
                        (r.directionalShadow[w] = K),
                        (r.directionalShadowMap[w] = N),
                        (r.directionalShadowMatrix[w] = j.shadow.matrix),
                        T++;
                }
                (r.directional[w] = B), w++;
            } else if (j.isSpotLight) {
                const B = t.get(j);
                B.position.setFromMatrixPosition(j.matrixWorld),
                    B.color.copy(oe).multiplyScalar(te * b),
                    (B.distance = ae),
                    (B.coneCos = Math.cos(j.angle)),
                    (B.penumbraCos = Math.cos(j.angle * (1 - j.penumbra))),
                    (B.decay = j.decay),
                    (r.spot[g] = B);
                const H = j.shadow;
                if (
                    (j.map &&
                        ((r.spotLightMap[R] = j.map),
                        R++,
                        H.updateMatrices(j),
                        j.castShadow && D++),
                    (r.spotLightMatrix[g] = H.matrix),
                    j.castShadow)
                ) {
                    const K = i.get(j);
                    (K.shadowBias = H.bias),
                        (K.shadowNormalBias = H.normalBias),
                        (K.shadowRadius = H.radius),
                        (K.shadowMapSize = H.mapSize),
                        (r.spotShadow[g] = K),
                        (r.spotShadowMap[g] = N),
                        A++;
                }
                g++;
            } else if (j.isRectAreaLight) {
                const B = t.get(j);
                B.color.copy(oe).multiplyScalar(te),
                    B.halfWidth.set(j.width * 0.5, 0, 0),
                    B.halfHeight.set(0, j.height * 0.5, 0),
                    (r.rectArea[S] = B),
                    S++;
            } else if (j.isPointLight) {
                const B = t.get(j);
                if (
                    (B.color.copy(j.color).multiplyScalar(j.intensity * b),
                    (B.distance = j.distance),
                    (B.decay = j.decay),
                    j.castShadow)
                ) {
                    const H = j.shadow,
                        K = i.get(j);
                    (K.shadowBias = H.bias),
                        (K.shadowNormalBias = H.normalBias),
                        (K.shadowRadius = H.radius),
                        (K.shadowMapSize = H.mapSize),
                        (K.shadowCameraNear = H.camera.near),
                        (K.shadowCameraFar = H.camera.far),
                        (r.pointShadow[x] = K),
                        (r.pointShadowMap[x] = N),
                        (r.pointShadowMatrix[x] = j.shadow.matrix),
                        P++;
                }
                (r.point[x] = B), x++;
            } else if (j.isHemisphereLight) {
                const B = t.get(j);
                B.skyColor.copy(j.color).multiplyScalar(te * b),
                    B.groundColor.copy(j.groundColor).multiplyScalar(te * b),
                    (r.hemi[M] = B),
                    M++;
            }
        }
        S > 0 &&
            (e.isWebGL2
                ? n.has('OES_texture_float_linear') === !0
                    ? ((r.rectAreaLTC1 = Ne.LTC_FLOAT_1), (r.rectAreaLTC2 = Ne.LTC_FLOAT_2))
                    : ((r.rectAreaLTC1 = Ne.LTC_HALF_1), (r.rectAreaLTC2 = Ne.LTC_HALF_2))
                : n.has('OES_texture_float_linear') === !0
                ? ((r.rectAreaLTC1 = Ne.LTC_FLOAT_1), (r.rectAreaLTC2 = Ne.LTC_FLOAT_2))
                : n.has('OES_texture_half_float_linear') === !0
                ? ((r.rectAreaLTC1 = Ne.LTC_HALF_1), (r.rectAreaLTC2 = Ne.LTC_HALF_2))
                : console.error(
                      'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
                  )),
            (r.ambient[0] = p),
            (r.ambient[1] = v),
            (r.ambient[2] = _);
        const L = r.hash;
        (L.directionalLength !== w ||
            L.pointLength !== x ||
            L.spotLength !== g ||
            L.rectAreaLength !== S ||
            L.hemiLength !== M ||
            L.numDirectionalShadows !== T ||
            L.numPointShadows !== P ||
            L.numSpotShadows !== A ||
            L.numSpotMaps !== R ||
            L.numLightProbes !== G) &&
            ((r.directional.length = w),
            (r.spot.length = g),
            (r.rectArea.length = S),
            (r.point.length = x),
            (r.hemi.length = M),
            (r.directionalShadow.length = T),
            (r.directionalShadowMap.length = T),
            (r.pointShadow.length = P),
            (r.pointShadowMap.length = P),
            (r.spotShadow.length = A),
            (r.spotShadowMap.length = A),
            (r.directionalShadowMatrix.length = T),
            (r.pointShadowMatrix.length = P),
            (r.spotLightMatrix.length = A + R - D),
            (r.spotLightMap.length = R),
            (r.numSpotLightShadowsWithMaps = D),
            (r.numLightProbes = G),
            (L.directionalLength = w),
            (L.pointLength = x),
            (L.spotLength = g),
            (L.rectAreaLength = S),
            (L.hemiLength = M),
            (L.numDirectionalShadows = T),
            (L.numPointShadows = P),
            (L.numSpotShadows = A),
            (L.numSpotMaps = R),
            (L.numLightProbes = G),
            (r.version = Vk++));
    }
    function f(d, h) {
        let p = 0,
            v = 0,
            _ = 0,
            w = 0,
            x = 0;
        const g = h.matrixWorldInverse;
        for (let S = 0, M = d.length; S < M; S++) {
            const T = d[S];
            if (T.isDirectionalLight) {
                const P = r.directional[p];
                P.direction.setFromMatrixPosition(T.matrixWorld),
                    s.setFromMatrixPosition(T.target.matrixWorld),
                    P.direction.sub(s),
                    P.direction.transformDirection(g),
                    p++;
            } else if (T.isSpotLight) {
                const P = r.spot[_];
                P.position.setFromMatrixPosition(T.matrixWorld),
                    P.position.applyMatrix4(g),
                    P.direction.setFromMatrixPosition(T.matrixWorld),
                    s.setFromMatrixPosition(T.target.matrixWorld),
                    P.direction.sub(s),
                    P.direction.transformDirection(g),
                    _++;
            } else if (T.isRectAreaLight) {
                const P = r.rectArea[w];
                P.position.setFromMatrixPosition(T.matrixWorld),
                    P.position.applyMatrix4(g),
                    a.identity(),
                    o.copy(T.matrixWorld),
                    o.premultiply(g),
                    a.extractRotation(o),
                    P.halfWidth.set(T.width * 0.5, 0, 0),
                    P.halfHeight.set(0, T.height * 0.5, 0),
                    P.halfWidth.applyMatrix4(a),
                    P.halfHeight.applyMatrix4(a),
                    w++;
            } else if (T.isPointLight) {
                const P = r.point[v];
                P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(g), v++;
            } else if (T.isHemisphereLight) {
                const P = r.hemi[x];
                P.direction.setFromMatrixPosition(T.matrixWorld),
                    P.direction.transformDirection(g),
                    x++;
            }
        }
    }
    return { setup: c, setupView: f, state: r };
}
function Fw(n, e) {
    const t = new Wk(n, e),
        i = [],
        r = [];
    function s() {
        (i.length = 0), (r.length = 0);
    }
    function o(h) {
        i.push(h);
    }
    function a(h) {
        r.push(h);
    }
    function c(h) {
        t.setup(i, h);
    }
    function f(h) {
        t.setupView(i, h);
    }
    return {
        init: s,
        state: { lightsArray: i, shadowsArray: r, lights: t },
        setupLights: c,
        setupLightsView: f,
        pushLight: o,
        pushShadow: a,
    };
}
function jk(n, e) {
    let t = new WeakMap();
    function i(s, o = 0) {
        const a = t.get(s);
        let c;
        return (
            a === void 0
                ? ((c = new Fw(n, e)), t.set(s, [c]))
                : o >= a.length
                ? ((c = new Fw(n, e)), a.push(c))
                : (c = a[o]),
            c
        );
    }
    function r() {
        t = new WeakMap();
    }
    return { get: i, dispose: r };
}
class Ox extends ii {
    constructor(e) {
        super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = 'MeshDepthMaterial'),
            (this.depthPacking = SC),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
        );
    }
}
class Fx extends ii {
    constructor(e) {
        super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = 'MeshDistanceMaterial'),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
        );
    }
}
const Xk = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    Yk = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function qk(n, e, t) {
    let i = new Gf();
    const r = new _e(),
        s = new _e(),
        o = new Wt(),
        a = new Ox({ depthPacking: MC }),
        c = new Fx(),
        f = {},
        d = t.maxTextureSize,
        h = { [Gs]: Ai, [Ai]: Gs, [os]: os },
        p = new Gr({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new _e() },
                radius: { value: 4 },
            },
            vertexShader: Xk,
            fragmentShader: Yk,
        }),
        v = p.clone();
    v.defines.HORIZONTAL_PASS = 1;
    const _ = new bt();
    _.setAttribute('position', new Yt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const w = new On(_, p),
        x = this;
    (this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = Am);
    let g = this.type;
    this.render = function (A, R, D) {
        if (x.enabled === !1 || (x.autoUpdate === !1 && x.needsUpdate === !1) || A.length === 0)
            return;
        const G = n.getRenderTarget(),
            b = n.getActiveCubeFace(),
            L = n.getActiveMipmapLevel(),
            ee = n.state;
        ee.setBlending(ks),
            ee.buffers.color.setClear(1, 1, 1, 1),
            ee.buffers.depth.setTest(!0),
            ee.setScissorTest(!1);
        const ie = g !== Dr && this.type === Dr,
            j = g === Dr && this.type !== Dr;
        for (let oe = 0, te = A.length; oe < te; oe++) {
            const ae = A[oe],
                N = ae.shadow;
            if (N === void 0) {
                console.warn('THREE.WebGLShadowMap:', ae, 'has no shadow.');
                continue;
            }
            if (N.autoUpdate === !1 && N.needsUpdate === !1) continue;
            r.copy(N.mapSize);
            const B = N.getFrameExtents();
            if (
                (r.multiply(B),
                s.copy(N.mapSize),
                (r.x > d || r.y > d) &&
                    (r.x > d &&
                        ((s.x = Math.floor(d / B.x)), (r.x = s.x * B.x), (N.mapSize.x = s.x)),
                    r.y > d &&
                        ((s.y = Math.floor(d / B.y)), (r.y = s.y * B.y), (N.mapSize.y = s.y))),
                N.map === null || ie === !0 || j === !0)
            ) {
                const K = this.type !== Dr ? { minFilter: bn, magFilter: bn } : {};
                N.map !== null && N.map.dispose(),
                    (N.map = new Vr(r.x, r.y, K)),
                    (N.map.texture.name = ae.name + '.shadowMap'),
                    N.camera.updateProjectionMatrix();
            }
            n.setRenderTarget(N.map), n.clear();
            const H = N.getViewportCount();
            for (let K = 0; K < H; K++) {
                const le = N.getViewport(K);
                o.set(s.x * le.x, s.y * le.y, s.x * le.z, s.y * le.w),
                    ee.viewport(o),
                    N.updateMatrices(ae, K),
                    (i = N.getFrustum()),
                    T(R, D, N.camera, ae, this.type);
            }
            N.isPointLightShadow !== !0 && this.type === Dr && S(N, D), (N.needsUpdate = !1);
        }
        (g = this.type), (x.needsUpdate = !1), n.setRenderTarget(G, b, L);
    };
    function S(A, R) {
        const D = e.update(w);
        p.defines.VSM_SAMPLES !== A.blurSamples &&
            ((p.defines.VSM_SAMPLES = A.blurSamples),
            (v.defines.VSM_SAMPLES = A.blurSamples),
            (p.needsUpdate = !0),
            (v.needsUpdate = !0)),
            A.mapPass === null && (A.mapPass = new Vr(r.x, r.y)),
            (p.uniforms.shadow_pass.value = A.map.texture),
            (p.uniforms.resolution.value = A.mapSize),
            (p.uniforms.radius.value = A.radius),
            n.setRenderTarget(A.mapPass),
            n.clear(),
            n.renderBufferDirect(R, null, D, p, w, null),
            (v.uniforms.shadow_pass.value = A.mapPass.texture),
            (v.uniforms.resolution.value = A.mapSize),
            (v.uniforms.radius.value = A.radius),
            n.setRenderTarget(A.map),
            n.clear(),
            n.renderBufferDirect(R, null, D, v, w, null);
    }
    function M(A, R, D, G) {
        let b = null;
        const L = D.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
        if (L !== void 0) b = L;
        else if (
            ((b = D.isPointLight === !0 ? c : a),
            (n.localClippingEnabled &&
                R.clipShadows === !0 &&
                Array.isArray(R.clippingPlanes) &&
                R.clippingPlanes.length !== 0) ||
                (R.displacementMap && R.displacementScale !== 0) ||
                (R.alphaMap && R.alphaTest > 0) ||
                (R.map && R.alphaTest > 0))
        ) {
            const ee = b.uuid,
                ie = R.uuid;
            let j = f[ee];
            j === void 0 && ((j = {}), (f[ee] = j));
            let oe = j[ie];
            oe === void 0 && ((oe = b.clone()), (j[ie] = oe), R.addEventListener('dispose', P)),
                (b = oe);
        }
        if (
            ((b.visible = R.visible),
            (b.wireframe = R.wireframe),
            G === Dr
                ? (b.side = R.shadowSide !== null ? R.shadowSide : R.side)
                : (b.side = R.shadowSide !== null ? R.shadowSide : h[R.side]),
            (b.alphaMap = R.alphaMap),
            (b.alphaTest = R.alphaTest),
            (b.map = R.map),
            (b.clipShadows = R.clipShadows),
            (b.clippingPlanes = R.clippingPlanes),
            (b.clipIntersection = R.clipIntersection),
            (b.displacementMap = R.displacementMap),
            (b.displacementScale = R.displacementScale),
            (b.displacementBias = R.displacementBias),
            (b.wireframeLinewidth = R.wireframeLinewidth),
            (b.linewidth = R.linewidth),
            D.isPointLight === !0 && b.isMeshDistanceMaterial === !0)
        ) {
            const ee = n.properties.get(b);
            ee.light = D;
        }
        return b;
    }
    function T(A, R, D, G, b) {
        if (A.visible === !1) return;
        if (
            A.layers.test(R.layers) &&
            (A.isMesh || A.isLine || A.isPoints) &&
            (A.castShadow || (A.receiveShadow && b === Dr)) &&
            (!A.frustumCulled || i.intersectsObject(A))
        ) {
            A.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, A.matrixWorld);
            const ie = e.update(A),
                j = A.material;
            if (Array.isArray(j)) {
                const oe = ie.groups;
                for (let te = 0, ae = oe.length; te < ae; te++) {
                    const N = oe[te],
                        B = j[N.materialIndex];
                    if (B && B.visible) {
                        const H = M(A, B, G, b);
                        A.onBeforeShadow(n, A, R, D, ie, H, N),
                            n.renderBufferDirect(D, null, ie, H, A, N),
                            A.onAfterShadow(n, A, R, D, ie, H, N);
                    }
                }
            } else if (j.visible) {
                const oe = M(A, j, G, b);
                A.onBeforeShadow(n, A, R, D, ie, oe, null),
                    n.renderBufferDirect(D, null, ie, oe, A, null),
                    A.onAfterShadow(n, A, R, D, ie, oe, null);
            }
        }
        const ee = A.children;
        for (let ie = 0, j = ee.length; ie < j; ie++) T(ee[ie], R, D, G, b);
    }
    function P(A) {
        A.target.removeEventListener('dispose', P);
        for (const D in f) {
            const G = f[D],
                b = A.target.uuid;
            b in G && (G[b].dispose(), delete G[b]);
        }
    }
}
function Zk(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let q = !1;
        const Fe = new Wt();
        let U = null;
        const W = new Wt(0, 0, 0, 0);
        return {
            setMask: function (Y) {
                U !== Y && !q && (n.colorMask(Y, Y, Y, Y), (U = Y));
            },
            setLocked: function (Y) {
                q = Y;
            },
            setClear: function (Y, ge, Ce, it, $e) {
                $e === !0 && ((Y *= it), (ge *= it), (Ce *= it)),
                    Fe.set(Y, ge, Ce, it),
                    W.equals(Fe) === !1 && (n.clearColor(Y, ge, Ce, it), W.copy(Fe));
            },
            reset: function () {
                (q = !1), (U = null), W.set(-1, 0, 0, 0);
            },
        };
    }
    function s() {
        let q = !1,
            Fe = null,
            U = null,
            W = null;
        return {
            setTest: function (Y) {
                Y ? Xe(n.DEPTH_TEST) : gt(n.DEPTH_TEST);
            },
            setMask: function (Y) {
                Fe !== Y && !q && (n.depthMask(Y), (Fe = Y));
            },
            setFunc: function (Y) {
                if (U !== Y) {
                    switch (Y) {
                        case Z2:
                            n.depthFunc(n.NEVER);
                            break;
                        case K2:
                            n.depthFunc(n.ALWAYS);
                            break;
                        case J2:
                            n.depthFunc(n.LESS);
                            break;
                        case cf:
                            n.depthFunc(n.LEQUAL);
                            break;
                        case Q2:
                            n.depthFunc(n.EQUAL);
                            break;
                        case $2:
                            n.depthFunc(n.GEQUAL);
                            break;
                        case eC:
                            n.depthFunc(n.GREATER);
                            break;
                        case tC:
                            n.depthFunc(n.NOTEQUAL);
                            break;
                        default:
                            n.depthFunc(n.LEQUAL);
                    }
                    U = Y;
                }
            },
            setLocked: function (Y) {
                q = Y;
            },
            setClear: function (Y) {
                W !== Y && (n.clearDepth(Y), (W = Y));
            },
            reset: function () {
                (q = !1), (Fe = null), (U = null), (W = null);
            },
        };
    }
    function o() {
        let q = !1,
            Fe = null,
            U = null,
            W = null,
            Y = null,
            ge = null,
            Ce = null,
            it = null,
            $e = null;
        return {
            setTest: function (Oe) {
                q || (Oe ? Xe(n.STENCIL_TEST) : gt(n.STENCIL_TEST));
            },
            setMask: function (Oe) {
                Fe !== Oe && !q && (n.stencilMask(Oe), (Fe = Oe));
            },
            setFunc: function (Oe, Ge, pt) {
                (U !== Oe || W !== Ge || Y !== pt) &&
                    (n.stencilFunc(Oe, Ge, pt), (U = Oe), (W = Ge), (Y = pt));
            },
            setOp: function (Oe, Ge, pt) {
                (ge !== Oe || Ce !== Ge || it !== pt) &&
                    (n.stencilOp(Oe, Ge, pt), (ge = Oe), (Ce = Ge), (it = pt));
            },
            setLocked: function (Oe) {
                q = Oe;
            },
            setClear: function (Oe) {
                $e !== Oe && (n.clearStencil(Oe), ($e = Oe));
            },
            reset: function () {
                (q = !1),
                    (Fe = null),
                    (U = null),
                    (W = null),
                    (Y = null),
                    (ge = null),
                    (Ce = null),
                    (it = null),
                    ($e = null);
            },
        };
    }
    const a = new r(),
        c = new s(),
        f = new o(),
        d = new WeakMap(),
        h = new WeakMap();
    let p = {},
        v = {},
        _ = new WeakMap(),
        w = [],
        x = null,
        g = !1,
        S = null,
        M = null,
        T = null,
        P = null,
        A = null,
        R = null,
        D = null,
        G = new je(0, 0, 0),
        b = 0,
        L = !1,
        ee = null,
        ie = null,
        j = null,
        oe = null,
        te = null;
    const ae = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let N = !1,
        B = 0;
    const H = n.getParameter(n.VERSION);
    H.indexOf('WebGL') !== -1
        ? ((B = parseFloat(/^WebGL (\d)/.exec(H)[1])), (N = B >= 1))
        : H.indexOf('OpenGL ES') !== -1 &&
          ((B = parseFloat(/^OpenGL ES (\d)/.exec(H)[1])), (N = B >= 2));
    let K = null,
        le = {};
    const be = n.getParameter(n.SCISSOR_BOX),
        Q = n.getParameter(n.VIEWPORT),
        me = new Wt().fromArray(be),
        Se = new Wt().fromArray(Q);
    function ke(q, Fe, U, W) {
        const Y = new Uint8Array(4),
            ge = n.createTexture();
        n.bindTexture(q, ge),
            n.texParameteri(q, n.TEXTURE_MIN_FILTER, n.NEAREST),
            n.texParameteri(q, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let Ce = 0; Ce < U; Ce++)
            i && (q === n.TEXTURE_3D || q === n.TEXTURE_2D_ARRAY)
                ? n.texImage3D(Fe, 0, n.RGBA, 1, 1, W, 0, n.RGBA, n.UNSIGNED_BYTE, Y)
                : n.texImage2D(Fe + Ce, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Y);
        return ge;
    }
    const et = {};
    (et[n.TEXTURE_2D] = ke(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
        (et[n.TEXTURE_CUBE_MAP] = ke(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
        i &&
            ((et[n.TEXTURE_2D_ARRAY] = ke(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
            (et[n.TEXTURE_3D] = ke(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
        a.setClear(0, 0, 0, 1),
        c.setClear(1),
        f.setClear(0),
        Xe(n.DEPTH_TEST),
        c.setFunc(cf),
        He(!1),
        Ke(T_),
        Xe(n.CULL_FACE),
        ye(ks);
    function Xe(q) {
        p[q] !== !0 && (n.enable(q), (p[q] = !0));
    }
    function gt(q) {
        p[q] !== !1 && (n.disable(q), (p[q] = !1));
    }
    function De(q, Fe) {
        return v[q] !== Fe
            ? (n.bindFramebuffer(q, Fe),
              (v[q] = Fe),
              i &&
                  (q === n.DRAW_FRAMEBUFFER && (v[n.FRAMEBUFFER] = Fe),
                  q === n.FRAMEBUFFER && (v[n.DRAW_FRAMEBUFFER] = Fe)),
              !0)
            : !1;
    }
    function V(q, Fe) {
        let U = w,
            W = !1;
        if (q) {
            (U = _.get(Fe)), U === void 0 && ((U = []), _.set(Fe, U));
            const Y = q.textures;
            if (U.length !== Y.length || U[0] !== n.COLOR_ATTACHMENT0) {
                for (let ge = 0, Ce = Y.length; ge < Ce; ge++) U[ge] = n.COLOR_ATTACHMENT0 + ge;
                (U.length = Y.length), (W = !0);
            }
        } else U[0] !== n.BACK && ((U[0] = n.BACK), (W = !0));
        if (W)
            if (t.isWebGL2) n.drawBuffers(U);
            else if (e.has('WEBGL_draw_buffers') === !0)
                e.get('WEBGL_draw_buffers').drawBuffersWEBGL(U);
            else
                throw new Error(
                    'THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension'
                );
    }
    function we(q) {
        return x !== q ? (n.useProgram(q), (x = q), !0) : !1;
    }
    const ve = { [So]: n.FUNC_ADD, [D2]: n.FUNC_SUBTRACT, [U2]: n.FUNC_REVERSE_SUBTRACT };
    if (i) (ve[R_] = n.MIN), (ve[P_] = n.MAX);
    else {
        const q = e.get('EXT_blend_minmax');
        q !== null && ((ve[R_] = q.MIN_EXT), (ve[P_] = q.MAX_EXT));
    }
    const Ee = {
        [O2]: n.ZERO,
        [F2]: n.ONE,
        [k2]: n.SRC_COLOR,
        [Jp]: n.SRC_ALPHA,
        [W2]: n.SRC_ALPHA_SATURATE,
        [V2]: n.DST_COLOR,
        [B2]: n.DST_ALPHA,
        [z2]: n.ONE_MINUS_SRC_COLOR,
        [Qp]: n.ONE_MINUS_SRC_ALPHA,
        [G2]: n.ONE_MINUS_DST_COLOR,
        [H2]: n.ONE_MINUS_DST_ALPHA,
        [j2]: n.CONSTANT_COLOR,
        [X2]: n.ONE_MINUS_CONSTANT_COLOR,
        [Y2]: n.CONSTANT_ALPHA,
        [q2]: n.ONE_MINUS_CONSTANT_ALPHA,
    };
    function ye(q, Fe, U, W, Y, ge, Ce, it, $e, Oe) {
        if (q === ks) {
            g === !0 && (gt(n.BLEND), (g = !1));
            return;
        }
        if ((g === !1 && (Xe(n.BLEND), (g = !0)), q !== N2)) {
            if (q !== S || Oe !== L) {
                if (
                    ((M !== So || A !== So) && (n.blendEquation(n.FUNC_ADD), (M = So), (A = So)),
                    Oe)
                )
                    switch (q) {
                        case Ia:
                            n.blendFuncSeparate(
                                n.ONE,
                                n.ONE_MINUS_SRC_ALPHA,
                                n.ONE,
                                n.ONE_MINUS_SRC_ALPHA
                            );
                            break;
                        case A_:
                            n.blendFunc(n.ONE, n.ONE);
                            break;
                        case C_:
                            n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                            break;
                        case b_:
                            n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                            break;
                        default:
                            console.error('THREE.WebGLState: Invalid blending: ', q);
                            break;
                    }
                else
                    switch (q) {
                        case Ia:
                            n.blendFuncSeparate(
                                n.SRC_ALPHA,
                                n.ONE_MINUS_SRC_ALPHA,
                                n.ONE,
                                n.ONE_MINUS_SRC_ALPHA
                            );
                            break;
                        case A_:
                            n.blendFunc(n.SRC_ALPHA, n.ONE);
                            break;
                        case C_:
                            n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                            break;
                        case b_:
                            n.blendFunc(n.ZERO, n.SRC_COLOR);
                            break;
                        default:
                            console.error('THREE.WebGLState: Invalid blending: ', q);
                            break;
                    }
                (T = null),
                    (P = null),
                    (R = null),
                    (D = null),
                    G.set(0, 0, 0),
                    (b = 0),
                    (S = q),
                    (L = Oe);
            }
            return;
        }
        (Y = Y || Fe),
            (ge = ge || U),
            (Ce = Ce || W),
            (Fe !== M || Y !== A) && (n.blendEquationSeparate(ve[Fe], ve[Y]), (M = Fe), (A = Y)),
            (U !== T || W !== P || ge !== R || Ce !== D) &&
                (n.blendFuncSeparate(Ee[U], Ee[W], Ee[ge], Ee[Ce]),
                (T = U),
                (P = W),
                (R = ge),
                (D = Ce)),
            (it.equals(G) === !1 || $e !== b) &&
                (n.blendColor(it.r, it.g, it.b, $e), G.copy(it), (b = $e)),
            (S = q),
            (L = !1);
    }
    function We(q, Fe) {
        q.side === os ? gt(n.CULL_FACE) : Xe(n.CULL_FACE);
        let U = q.side === Ai;
        Fe && (U = !U),
            He(U),
            q.blending === Ia && q.transparent === !1
                ? ye(ks)
                : ye(
                      q.blending,
                      q.blendEquation,
                      q.blendSrc,
                      q.blendDst,
                      q.blendEquationAlpha,
                      q.blendSrcAlpha,
                      q.blendDstAlpha,
                      q.blendColor,
                      q.blendAlpha,
                      q.premultipliedAlpha
                  ),
            c.setFunc(q.depthFunc),
            c.setTest(q.depthTest),
            c.setMask(q.depthWrite),
            a.setMask(q.colorWrite);
        const W = q.stencilWrite;
        f.setTest(W),
            W &&
                (f.setMask(q.stencilWriteMask),
                f.setFunc(q.stencilFunc, q.stencilRef, q.stencilFuncMask),
                f.setOp(q.stencilFail, q.stencilZFail, q.stencilZPass)),
            F(q.polygonOffset, q.polygonOffsetFactor, q.polygonOffsetUnits),
            q.alphaToCoverage === !0
                ? Xe(n.SAMPLE_ALPHA_TO_COVERAGE)
                : gt(n.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function He(q) {
        ee !== q && (q ? n.frontFace(n.CW) : n.frontFace(n.CCW), (ee = q));
    }
    function Ke(q) {
        q !== P2
            ? (Xe(n.CULL_FACE),
              q !== ie &&
                  (q === T_
                      ? n.cullFace(n.BACK)
                      : q === L2
                      ? n.cullFace(n.FRONT)
                      : n.cullFace(n.FRONT_AND_BACK)))
            : gt(n.CULL_FACE),
            (ie = q);
    }
    function yt(q) {
        q !== j && (N && n.lineWidth(q), (j = q));
    }
    function F(q, Fe, U) {
        q
            ? (Xe(n.POLYGON_OFFSET_FILL),
              (oe !== Fe || te !== U) && (n.polygonOffset(Fe, U), (oe = Fe), (te = U)))
            : gt(n.POLYGON_OFFSET_FILL);
    }
    function I(q) {
        q ? Xe(n.SCISSOR_TEST) : gt(n.SCISSOR_TEST);
    }
    function ce(q) {
        q === void 0 && (q = n.TEXTURE0 + ae - 1), K !== q && (n.activeTexture(q), (K = q));
    }
    function de(q, Fe, U) {
        U === void 0 && (K === null ? (U = n.TEXTURE0 + ae - 1) : (U = K));
        let W = le[U];
        W === void 0 && ((W = { type: void 0, texture: void 0 }), (le[U] = W)),
            (W.type !== q || W.texture !== Fe) &&
                (K !== U && (n.activeTexture(U), (K = U)),
                n.bindTexture(q, Fe || et[q]),
                (W.type = q),
                (W.texture = Fe));
    }
    function Me() {
        const q = le[K];
        q !== void 0 &&
            q.type !== void 0 &&
            (n.bindTexture(q.type, null), (q.type = void 0), (q.texture = void 0));
    }
    function xe() {
        try {
            n.compressedTexImage2D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function ut() {
        try {
            n.compressedTexImage3D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function at() {
        try {
            n.texSubImage2D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function Ae() {
        try {
            n.texSubImage3D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function Ie() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function ht() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function Pe() {
        try {
            n.texStorage2D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function nn() {
        try {
            n.texStorage3D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function wt() {
        try {
            n.texImage2D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function rt() {
        try {
            n.texImage3D.apply(n, arguments);
        } catch (q) {
            console.error('THREE.WebGLState:', q);
        }
    }
    function tt(q) {
        me.equals(q) === !1 && (n.scissor(q.x, q.y, q.z, q.w), me.copy(q));
    }
    function Qe(q) {
        Se.equals(q) === !1 && (n.viewport(q.x, q.y, q.z, q.w), Se.copy(q));
    }
    function Lt(q, Fe) {
        let U = h.get(Fe);
        U === void 0 && ((U = new WeakMap()), h.set(Fe, U));
        let W = U.get(q);
        W === void 0 && ((W = n.getUniformBlockIndex(Fe, q.name)), U.set(q, W));
    }
    function vt(q, Fe) {
        const W = h.get(Fe).get(q);
        d.get(Fe) !== W && (n.uniformBlockBinding(Fe, W, q.__bindingPointIndex), d.set(Fe, W));
    }
    function Xt() {
        n.disable(n.BLEND),
            n.disable(n.CULL_FACE),
            n.disable(n.DEPTH_TEST),
            n.disable(n.POLYGON_OFFSET_FILL),
            n.disable(n.SCISSOR_TEST),
            n.disable(n.STENCIL_TEST),
            n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
            n.blendEquation(n.FUNC_ADD),
            n.blendFunc(n.ONE, n.ZERO),
            n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
            n.blendColor(0, 0, 0, 0),
            n.colorMask(!0, !0, !0, !0),
            n.clearColor(0, 0, 0, 0),
            n.depthMask(!0),
            n.depthFunc(n.LESS),
            n.clearDepth(1),
            n.stencilMask(4294967295),
            n.stencilFunc(n.ALWAYS, 0, 4294967295),
            n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
            n.clearStencil(0),
            n.cullFace(n.BACK),
            n.frontFace(n.CCW),
            n.polygonOffset(0, 0),
            n.activeTexture(n.TEXTURE0),
            n.bindFramebuffer(n.FRAMEBUFFER, null),
            i === !0 &&
                (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
            n.useProgram(null),
            n.lineWidth(1),
            n.scissor(0, 0, n.canvas.width, n.canvas.height),
            n.viewport(0, 0, n.canvas.width, n.canvas.height),
            (p = {}),
            (K = null),
            (le = {}),
            (v = {}),
            (_ = new WeakMap()),
            (w = []),
            (x = null),
            (g = !1),
            (S = null),
            (M = null),
            (T = null),
            (P = null),
            (A = null),
            (R = null),
            (D = null),
            (G = new je(0, 0, 0)),
            (b = 0),
            (L = !1),
            (ee = null),
            (ie = null),
            (j = null),
            (oe = null),
            (te = null),
            me.set(0, 0, n.canvas.width, n.canvas.height),
            Se.set(0, 0, n.canvas.width, n.canvas.height),
            a.reset(),
            c.reset(),
            f.reset();
    }
    return {
        buffers: { color: a, depth: c, stencil: f },
        enable: Xe,
        disable: gt,
        bindFramebuffer: De,
        drawBuffers: V,
        useProgram: we,
        setBlending: ye,
        setMaterial: We,
        setFlipSided: He,
        setCullFace: Ke,
        setLineWidth: yt,
        setPolygonOffset: F,
        setScissorTest: I,
        activeTexture: ce,
        bindTexture: de,
        unbindTexture: Me,
        compressedTexImage2D: xe,
        compressedTexImage3D: ut,
        texImage2D: wt,
        texImage3D: rt,
        updateUBOMapping: Lt,
        uniformBlockBinding: vt,
        texStorage2D: Pe,
        texStorage3D: nn,
        texSubImage2D: at,
        texSubImage3D: Ae,
        compressedTexSubImage2D: Ie,
        compressedTexSubImage3D: ht,
        scissor: tt,
        viewport: Qe,
        reset: Xt,
    };
}
function Kk(n, e, t, i, r, s, o) {
    const a = r.isWebGL2,
        c = e.has('WEBGL_multisampled_render_to_texture')
            ? e.get('WEBGL_multisampled_render_to_texture')
            : null,
        f = typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        d = new _e(),
        h = new WeakMap();
    let p;
    const v = new WeakMap();
    let _ = !1;
    try {
        _ = typeof OffscreenCanvas < 'u' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
    } catch {}
    function w(F, I) {
        return _ ? new OffscreenCanvas(F, I) : wf('canvas');
    }
    function x(F, I, ce, de) {
        let Me = 1;
        const xe = yt(F);
        if (
            ((xe.width > de || xe.height > de) && (Me = de / Math.max(xe.width, xe.height)),
            Me < 1 || I === !0)
        )
            if (
                (typeof HTMLImageElement < 'u' && F instanceof HTMLImageElement) ||
                (typeof HTMLCanvasElement < 'u' && F instanceof HTMLCanvasElement) ||
                (typeof ImageBitmap < 'u' && F instanceof ImageBitmap) ||
                (typeof VideoFrame < 'u' && F instanceof VideoFrame)
            ) {
                const ut = I ? tm : Math.floor,
                    at = ut(Me * xe.width),
                    Ae = ut(Me * xe.height);
                p === void 0 && (p = w(at, Ae));
                const Ie = ce ? w(at, Ae) : p;
                return (
                    (Ie.width = at),
                    (Ie.height = Ae),
                    Ie.getContext('2d').drawImage(F, 0, 0, at, Ae),
                    console.warn(
                        'THREE.WebGLRenderer: Texture has been resized from (' +
                            xe.width +
                            'x' +
                            xe.height +
                            ') to (' +
                            at +
                            'x' +
                            Ae +
                            ').'
                    ),
                    Ie
                );
            } else
                return (
                    'data' in F &&
                        console.warn(
                            'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                                xe.width +
                                'x' +
                                xe.height +
                                ').'
                        ),
                    F
                );
        return F;
    }
    function g(F) {
        const I = yt(F);
        return sy(I.width) && sy(I.height);
    }
    function S(F) {
        return a
            ? !1
            : F.wrapS !== pi || F.wrapT !== pi || (F.minFilter !== bn && F.minFilter !== dn);
    }
    function M(F, I) {
        return F.generateMipmaps && I && F.minFilter !== bn && F.minFilter !== dn;
    }
    function T(F) {
        n.generateMipmap(F);
    }
    function P(F, I, ce, de, Me = !1) {
        if (a === !1) return I;
        if (F !== null) {
            if (n[F] !== void 0) return n[F];
            console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'"
            );
        }
        let xe = I;
        if (
            (I === n.RED &&
                (ce === n.FLOAT && (xe = n.R32F),
                ce === n.HALF_FLOAT && (xe = n.R16F),
                ce === n.UNSIGNED_BYTE && (xe = n.R8)),
            I === n.RED_INTEGER &&
                (ce === n.UNSIGNED_BYTE && (xe = n.R8UI),
                ce === n.UNSIGNED_SHORT && (xe = n.R16UI),
                ce === n.UNSIGNED_INT && (xe = n.R32UI),
                ce === n.BYTE && (xe = n.R8I),
                ce === n.SHORT && (xe = n.R16I),
                ce === n.INT && (xe = n.R32I)),
            I === n.RG &&
                (ce === n.FLOAT && (xe = n.RG32F),
                ce === n.HALF_FLOAT && (xe = n.RG16F),
                ce === n.UNSIGNED_BYTE && (xe = n.RG8)),
            I === n.RG_INTEGER &&
                (ce === n.UNSIGNED_BYTE && (xe = n.RG8UI),
                ce === n.UNSIGNED_SHORT && (xe = n.RG16UI),
                ce === n.UNSIGNED_INT && (xe = n.RG32UI),
                ce === n.BYTE && (xe = n.RG8I),
                ce === n.SHORT && (xe = n.RG16I),
                ce === n.INT && (xe = n.RG32I)),
            I === n.RGBA)
        ) {
            const ut = Me ? _f : Gt.getTransfer(de);
            ce === n.FLOAT && (xe = n.RGBA32F),
                ce === n.HALF_FLOAT && (xe = n.RGBA16F),
                ce === n.UNSIGNED_BYTE && (xe = ut === Jt ? n.SRGB8_ALPHA8 : n.RGBA8),
                ce === n.UNSIGNED_SHORT_4_4_4_4 && (xe = n.RGBA4),
                ce === n.UNSIGNED_SHORT_5_5_5_1 && (xe = n.RGB5_A1);
        }
        return (
            (xe === n.R16F ||
                xe === n.R32F ||
                xe === n.RG16F ||
                xe === n.RG32F ||
                xe === n.RGBA16F ||
                xe === n.RGBA32F) &&
                e.get('EXT_color_buffer_float'),
            xe
        );
    }
    function A(F, I, ce) {
        return M(F, ce) === !0 ||
            (F.isFramebufferTexture && F.minFilter !== bn && F.minFilter !== dn)
            ? Math.log2(Math.max(I.width, I.height)) + 1
            : F.mipmaps !== void 0 && F.mipmaps.length > 0
            ? F.mipmaps.length
            : F.isCompressedTexture && Array.isArray(F.image)
            ? I.mipmaps.length
            : 1;
    }
    function R(F) {
        return F === bn || F === $p || F === ya ? n.NEAREST : n.LINEAR;
    }
    function D(F) {
        const I = F.target;
        I.removeEventListener('dispose', D), b(I), I.isVideoTexture && h.delete(I);
    }
    function G(F) {
        const I = F.target;
        I.removeEventListener('dispose', G), ee(I);
    }
    function b(F) {
        const I = i.get(F);
        if (I.__webglInit === void 0) return;
        const ce = F.source,
            de = v.get(ce);
        if (de) {
            const Me = de[I.__cacheKey];
            Me.usedTimes--,
                Me.usedTimes === 0 && L(F),
                Object.keys(de).length === 0 && v.delete(ce);
        }
        i.remove(F);
    }
    function L(F) {
        const I = i.get(F);
        n.deleteTexture(I.__webglTexture);
        const ce = F.source,
            de = v.get(ce);
        delete de[I.__cacheKey], o.memory.textures--;
    }
    function ee(F) {
        const I = i.get(F);
        if ((F.depthTexture && F.depthTexture.dispose(), F.isWebGLCubeRenderTarget))
            for (let de = 0; de < 6; de++) {
                if (Array.isArray(I.__webglFramebuffer[de]))
                    for (let Me = 0; Me < I.__webglFramebuffer[de].length; Me++)
                        n.deleteFramebuffer(I.__webglFramebuffer[de][Me]);
                else n.deleteFramebuffer(I.__webglFramebuffer[de]);
                I.__webglDepthbuffer && n.deleteRenderbuffer(I.__webglDepthbuffer[de]);
            }
        else {
            if (Array.isArray(I.__webglFramebuffer))
                for (let de = 0; de < I.__webglFramebuffer.length; de++)
                    n.deleteFramebuffer(I.__webglFramebuffer[de]);
            else n.deleteFramebuffer(I.__webglFramebuffer);
            if (
                (I.__webglDepthbuffer && n.deleteRenderbuffer(I.__webglDepthbuffer),
                I.__webglMultisampledFramebuffer &&
                    n.deleteFramebuffer(I.__webglMultisampledFramebuffer),
                I.__webglColorRenderbuffer)
            )
                for (let de = 0; de < I.__webglColorRenderbuffer.length; de++)
                    I.__webglColorRenderbuffer[de] &&
                        n.deleteRenderbuffer(I.__webglColorRenderbuffer[de]);
            I.__webglDepthRenderbuffer && n.deleteRenderbuffer(I.__webglDepthRenderbuffer);
        }
        const ce = F.textures;
        for (let de = 0, Me = ce.length; de < Me; de++) {
            const xe = i.get(ce[de]);
            xe.__webglTexture && (n.deleteTexture(xe.__webglTexture), o.memory.textures--),
                i.remove(ce[de]);
        }
        i.remove(F);
    }
    let ie = 0;
    function j() {
        ie = 0;
    }
    function oe() {
        const F = ie;
        return (
            F >= r.maxTextures &&
                console.warn(
                    'THREE.WebGLTextures: Trying to use ' +
                        F +
                        ' texture units while this GPU supports only ' +
                        r.maxTextures
                ),
            (ie += 1),
            F
        );
    }
    function te(F) {
        const I = [];
        return (
            I.push(F.wrapS),
            I.push(F.wrapT),
            I.push(F.wrapR || 0),
            I.push(F.magFilter),
            I.push(F.minFilter),
            I.push(F.anisotropy),
            I.push(F.internalFormat),
            I.push(F.format),
            I.push(F.type),
            I.push(F.generateMipmaps),
            I.push(F.premultiplyAlpha),
            I.push(F.flipY),
            I.push(F.unpackAlignment),
            I.push(F.colorSpace),
            I.join()
        );
    }
    function ae(F, I) {
        const ce = i.get(F);
        if (
            (F.isVideoTexture && He(F),
            F.isRenderTargetTexture === !1 && F.version > 0 && ce.__version !== F.version)
        ) {
            const de = F.image;
            if (de === null)
                console.warn(
                    'THREE.WebGLRenderer: Texture marked for update but no image data found.'
                );
            else if (de.complete === !1)
                console.warn(
                    'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
                );
            else {
                Se(ce, F, I);
                return;
            }
        }
        t.bindTexture(n.TEXTURE_2D, ce.__webglTexture, n.TEXTURE0 + I);
    }
    function N(F, I) {
        const ce = i.get(F);
        if (F.version > 0 && ce.__version !== F.version) {
            Se(ce, F, I);
            return;
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, ce.__webglTexture, n.TEXTURE0 + I);
    }
    function B(F, I) {
        const ce = i.get(F);
        if (F.version > 0 && ce.__version !== F.version) {
            Se(ce, F, I);
            return;
        }
        t.bindTexture(n.TEXTURE_3D, ce.__webglTexture, n.TEXTURE0 + I);
    }
    function H(F, I) {
        const ce = i.get(F);
        if (F.version > 0 && ce.__version !== F.version) {
            ke(ce, F, I);
            return;
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, ce.__webglTexture, n.TEXTURE0 + I);
    }
    const K = { [hf]: n.REPEAT, [pi]: n.CLAMP_TO_EDGE, [pf]: n.MIRRORED_REPEAT },
        le = {
            [bn]: n.NEAREST,
            [$p]: n.NEAREST_MIPMAP_NEAREST,
            [ya]: n.NEAREST_MIPMAP_LINEAR,
            [dn]: n.LINEAR,
            [Hc]: n.LINEAR_MIPMAP_NEAREST,
            [as]: n.LINEAR_MIPMAP_LINEAR,
        },
        be = {
            [EC]: n.NEVER,
            [PC]: n.ALWAYS,
            [TC]: n.LESS,
            [bx]: n.LEQUAL,
            [AC]: n.EQUAL,
            [RC]: n.GEQUAL,
            [CC]: n.GREATER,
            [bC]: n.NOTEQUAL,
        };
    function Q(F, I, ce) {
        if (
            (I.type === Ki &&
                e.has('OES_texture_float_linear') === !1 &&
                (I.magFilter === dn ||
                    I.magFilter === Hc ||
                    I.magFilter === ya ||
                    I.magFilter === as ||
                    I.minFilter === dn ||
                    I.minFilter === Hc ||
                    I.minFilter === ya ||
                    I.minFilter === as) &&
                console.warn(
                    'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'
                ),
            ce
                ? (n.texParameteri(F, n.TEXTURE_WRAP_S, K[I.wrapS]),
                  n.texParameteri(F, n.TEXTURE_WRAP_T, K[I.wrapT]),
                  (F === n.TEXTURE_3D || F === n.TEXTURE_2D_ARRAY) &&
                      n.texParameteri(F, n.TEXTURE_WRAP_R, K[I.wrapR]),
                  n.texParameteri(F, n.TEXTURE_MAG_FILTER, le[I.magFilter]),
                  n.texParameteri(F, n.TEXTURE_MIN_FILTER, le[I.minFilter]))
                : (n.texParameteri(F, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
                  n.texParameteri(F, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
                  (F === n.TEXTURE_3D || F === n.TEXTURE_2D_ARRAY) &&
                      n.texParameteri(F, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
                  (I.wrapS !== pi || I.wrapT !== pi) &&
                      console.warn(
                          'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
                      ),
                  n.texParameteri(F, n.TEXTURE_MAG_FILTER, R(I.magFilter)),
                  n.texParameteri(F, n.TEXTURE_MIN_FILTER, R(I.minFilter)),
                  I.minFilter !== bn &&
                      I.minFilter !== dn &&
                      console.warn(
                          'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
                      )),
            I.compareFunction &&
                (n.texParameteri(F, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
                n.texParameteri(F, n.TEXTURE_COMPARE_FUNC, be[I.compareFunction])),
            e.has('EXT_texture_filter_anisotropic') === !0)
        ) {
            if (
                I.magFilter === bn ||
                (I.minFilter !== ya && I.minFilter !== as) ||
                (I.type === Ki && e.has('OES_texture_float_linear') === !1) ||
                (a === !1 && I.type === _u && e.has('OES_texture_half_float_linear') === !1)
            )
                return;
            if (I.anisotropy > 1 || i.get(I).__currentAnisotropy) {
                const de = e.get('EXT_texture_filter_anisotropic');
                n.texParameterf(
                    F,
                    de.TEXTURE_MAX_ANISOTROPY_EXT,
                    Math.min(I.anisotropy, r.getMaxAnisotropy())
                ),
                    (i.get(I).__currentAnisotropy = I.anisotropy);
            }
        }
    }
    function me(F, I) {
        let ce = !1;
        F.__webglInit === void 0 && ((F.__webglInit = !0), I.addEventListener('dispose', D));
        const de = I.source;
        let Me = v.get(de);
        Me === void 0 && ((Me = {}), v.set(de, Me));
        const xe = te(I);
        if (xe !== F.__cacheKey) {
            Me[xe] === void 0 &&
                ((Me[xe] = { texture: n.createTexture(), usedTimes: 0 }),
                o.memory.textures++,
                (ce = !0)),
                Me[xe].usedTimes++;
            const ut = Me[F.__cacheKey];
            ut !== void 0 && (Me[F.__cacheKey].usedTimes--, ut.usedTimes === 0 && L(I)),
                (F.__cacheKey = xe),
                (F.__webglTexture = Me[xe].texture);
        }
        return ce;
    }
    function Se(F, I, ce) {
        let de = n.TEXTURE_2D;
        (I.isDataArrayTexture || I.isCompressedArrayTexture) && (de = n.TEXTURE_2D_ARRAY),
            I.isData3DTexture && (de = n.TEXTURE_3D);
        const Me = me(F, I),
            xe = I.source;
        t.bindTexture(de, F.__webglTexture, n.TEXTURE0 + ce);
        const ut = i.get(xe);
        if (xe.version !== ut.__version || Me === !0) {
            t.activeTexture(n.TEXTURE0 + ce);
            const at = Gt.getPrimaries(Gt.workingColorSpace),
                Ae = I.colorSpace === Ps ? null : Gt.getPrimaries(I.colorSpace),
                Ie = I.colorSpace === Ps || at === Ae ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY),
                n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
                n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment),
                n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ie);
            const ht = S(I) && g(I.image) === !1;
            let Pe = x(I.image, ht, !1, r.maxTextureSize);
            Pe = Ke(I, Pe);
            const nn = g(Pe) || a,
                wt = s.convert(I.format, I.colorSpace);
            let rt = s.convert(I.type),
                tt = P(I.internalFormat, wt, rt, I.colorSpace, I.isVideoTexture);
            Q(de, I, nn);
            let Qe;
            const Lt = I.mipmaps,
                vt = a && I.isVideoTexture !== !0 && tt !== Ax,
                Xt = ut.__version === void 0 || Me === !0,
                q = xe.dataReady,
                Fe = A(I, Pe, nn);
            if (I.isDepthTexture)
                (tt = n.DEPTH_COMPONENT),
                    a
                        ? I.type === Ki
                            ? (tt = n.DEPTH_COMPONENT32F)
                            : I.type === Ds
                            ? (tt = n.DEPTH_COMPONENT24)
                            : I.type === Io
                            ? (tt = n.DEPTH24_STENCIL8)
                            : (tt = n.DEPTH_COMPONENT16)
                        : I.type === Ki &&
                          console.error(
                              'WebGLRenderer: Floating point depth texture requires WebGL2.'
                          ),
                    I.format === No &&
                        tt === n.DEPTH_COMPONENT &&
                        I.type !== bm &&
                        I.type !== Ds &&
                        (console.warn(
                            'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
                        ),
                        (I.type = Ds),
                        (rt = s.convert(I.type))),
                    I.format === Va &&
                        tt === n.DEPTH_COMPONENT &&
                        ((tt = n.DEPTH_STENCIL),
                        I.type !== Io &&
                            (console.warn(
                                'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
                            ),
                            (I.type = Io),
                            (rt = s.convert(I.type)))),
                    Xt &&
                        (vt
                            ? t.texStorage2D(n.TEXTURE_2D, 1, tt, Pe.width, Pe.height)
                            : t.texImage2D(
                                  n.TEXTURE_2D,
                                  0,
                                  tt,
                                  Pe.width,
                                  Pe.height,
                                  0,
                                  wt,
                                  rt,
                                  null
                              ));
            else if (I.isDataTexture)
                if (Lt.length > 0 && nn) {
                    vt && Xt && t.texStorage2D(n.TEXTURE_2D, Fe, tt, Lt[0].width, Lt[0].height);
                    for (let U = 0, W = Lt.length; U < W; U++)
                        (Qe = Lt[U]),
                            vt
                                ? q &&
                                  t.texSubImage2D(
                                      n.TEXTURE_2D,
                                      U,
                                      0,
                                      0,
                                      Qe.width,
                                      Qe.height,
                                      wt,
                                      rt,
                                      Qe.data
                                  )
                                : t.texImage2D(
                                      n.TEXTURE_2D,
                                      U,
                                      tt,
                                      Qe.width,
                                      Qe.height,
                                      0,
                                      wt,
                                      rt,
                                      Qe.data
                                  );
                    I.generateMipmaps = !1;
                } else
                    vt
                        ? (Xt && t.texStorage2D(n.TEXTURE_2D, Fe, tt, Pe.width, Pe.height),
                          q &&
                              t.texSubImage2D(
                                  n.TEXTURE_2D,
                                  0,
                                  0,
                                  0,
                                  Pe.width,
                                  Pe.height,
                                  wt,
                                  rt,
                                  Pe.data
                              ))
                        : t.texImage2D(
                              n.TEXTURE_2D,
                              0,
                              tt,
                              Pe.width,
                              Pe.height,
                              0,
                              wt,
                              rt,
                              Pe.data
                          );
            else if (I.isCompressedTexture)
                if (I.isCompressedArrayTexture) {
                    vt &&
                        Xt &&
                        t.texStorage3D(
                            n.TEXTURE_2D_ARRAY,
                            Fe,
                            tt,
                            Lt[0].width,
                            Lt[0].height,
                            Pe.depth
                        );
                    for (let U = 0, W = Lt.length; U < W; U++)
                        (Qe = Lt[U]),
                            I.format !== wi
                                ? wt !== null
                                    ? vt
                                        ? q &&
                                          t.compressedTexSubImage3D(
                                              n.TEXTURE_2D_ARRAY,
                                              U,
                                              0,
                                              0,
                                              0,
                                              Qe.width,
                                              Qe.height,
                                              Pe.depth,
                                              wt,
                                              Qe.data,
                                              0,
                                              0
                                          )
                                        : t.compressedTexImage3D(
                                              n.TEXTURE_2D_ARRAY,
                                              U,
                                              tt,
                                              Qe.width,
                                              Qe.height,
                                              Pe.depth,
                                              0,
                                              Qe.data,
                                              0,
                                              0
                                          )
                                    : console.warn(
                                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                      )
                                : vt
                                ? q &&
                                  t.texSubImage3D(
                                      n.TEXTURE_2D_ARRAY,
                                      U,
                                      0,
                                      0,
                                      0,
                                      Qe.width,
                                      Qe.height,
                                      Pe.depth,
                                      wt,
                                      rt,
                                      Qe.data
                                  )
                                : t.texImage3D(
                                      n.TEXTURE_2D_ARRAY,
                                      U,
                                      tt,
                                      Qe.width,
                                      Qe.height,
                                      Pe.depth,
                                      0,
                                      wt,
                                      rt,
                                      Qe.data
                                  );
                } else {
                    vt && Xt && t.texStorage2D(n.TEXTURE_2D, Fe, tt, Lt[0].width, Lt[0].height);
                    for (let U = 0, W = Lt.length; U < W; U++)
                        (Qe = Lt[U]),
                            I.format !== wi
                                ? wt !== null
                                    ? vt
                                        ? q &&
                                          t.compressedTexSubImage2D(
                                              n.TEXTURE_2D,
                                              U,
                                              0,
                                              0,
                                              Qe.width,
                                              Qe.height,
                                              wt,
                                              Qe.data
                                          )
                                        : t.compressedTexImage2D(
                                              n.TEXTURE_2D,
                                              U,
                                              tt,
                                              Qe.width,
                                              Qe.height,
                                              0,
                                              Qe.data
                                          )
                                    : console.warn(
                                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                      )
                                : vt
                                ? q &&
                                  t.texSubImage2D(
                                      n.TEXTURE_2D,
                                      U,
                                      0,
                                      0,
                                      Qe.width,
                                      Qe.height,
                                      wt,
                                      rt,
                                      Qe.data
                                  )
                                : t.texImage2D(
                                      n.TEXTURE_2D,
                                      U,
                                      tt,
                                      Qe.width,
                                      Qe.height,
                                      0,
                                      wt,
                                      rt,
                                      Qe.data
                                  );
                }
            else if (I.isDataArrayTexture)
                vt
                    ? (Xt &&
                          t.texStorage3D(n.TEXTURE_2D_ARRAY, Fe, tt, Pe.width, Pe.height, Pe.depth),
                      q &&
                          t.texSubImage3D(
                              n.TEXTURE_2D_ARRAY,
                              0,
                              0,
                              0,
                              0,
                              Pe.width,
                              Pe.height,
                              Pe.depth,
                              wt,
                              rt,
                              Pe.data
                          ))
                    : t.texImage3D(
                          n.TEXTURE_2D_ARRAY,
                          0,
                          tt,
                          Pe.width,
                          Pe.height,
                          Pe.depth,
                          0,
                          wt,
                          rt,
                          Pe.data
                      );
            else if (I.isData3DTexture)
                vt
                    ? (Xt && t.texStorage3D(n.TEXTURE_3D, Fe, tt, Pe.width, Pe.height, Pe.depth),
                      q &&
                          t.texSubImage3D(
                              n.TEXTURE_3D,
                              0,
                              0,
                              0,
                              0,
                              Pe.width,
                              Pe.height,
                              Pe.depth,
                              wt,
                              rt,
                              Pe.data
                          ))
                    : t.texImage3D(
                          n.TEXTURE_3D,
                          0,
                          tt,
                          Pe.width,
                          Pe.height,
                          Pe.depth,
                          0,
                          wt,
                          rt,
                          Pe.data
                      );
            else if (I.isFramebufferTexture) {
                if (Xt)
                    if (vt) t.texStorage2D(n.TEXTURE_2D, Fe, tt, Pe.width, Pe.height);
                    else {
                        let U = Pe.width,
                            W = Pe.height;
                        for (let Y = 0; Y < Fe; Y++)
                            t.texImage2D(n.TEXTURE_2D, Y, tt, U, W, 0, wt, rt, null),
                                (U >>= 1),
                                (W >>= 1);
                    }
            } else if (Lt.length > 0 && nn) {
                if (vt && Xt) {
                    const U = yt(Lt[0]);
                    t.texStorage2D(n.TEXTURE_2D, Fe, tt, U.width, U.height);
                }
                for (let U = 0, W = Lt.length; U < W; U++)
                    (Qe = Lt[U]),
                        vt
                            ? q && t.texSubImage2D(n.TEXTURE_2D, U, 0, 0, wt, rt, Qe)
                            : t.texImage2D(n.TEXTURE_2D, U, tt, wt, rt, Qe);
                I.generateMipmaps = !1;
            } else if (vt) {
                if (Xt) {
                    const U = yt(Pe);
                    t.texStorage2D(n.TEXTURE_2D, Fe, tt, U.width, U.height);
                }
                q && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, wt, rt, Pe);
            } else t.texImage2D(n.TEXTURE_2D, 0, tt, wt, rt, Pe);
            M(I, nn) && T(de), (ut.__version = xe.version), I.onUpdate && I.onUpdate(I);
        }
        F.__version = I.version;
    }
    function ke(F, I, ce) {
        if (I.image.length !== 6) return;
        const de = me(F, I),
            Me = I.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, F.__webglTexture, n.TEXTURE0 + ce);
        const xe = i.get(Me);
        if (Me.version !== xe.__version || de === !0) {
            t.activeTexture(n.TEXTURE0 + ce);
            const ut = Gt.getPrimaries(Gt.workingColorSpace),
                at = I.colorSpace === Ps ? null : Gt.getPrimaries(I.colorSpace),
                Ae = I.colorSpace === Ps || ut === at ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY),
                n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
                n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment),
                n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
            const Ie = I.isCompressedTexture || I.image[0].isCompressedTexture,
                ht = I.image[0] && I.image[0].isDataTexture,
                Pe = [];
            for (let U = 0; U < 6; U++)
                !Ie && !ht
                    ? (Pe[U] = x(I.image[U], !1, !0, r.maxCubemapSize))
                    : (Pe[U] = ht ? I.image[U].image : I.image[U]),
                    (Pe[U] = Ke(I, Pe[U]));
            const nn = Pe[0],
                wt = g(nn) || a,
                rt = s.convert(I.format, I.colorSpace),
                tt = s.convert(I.type),
                Qe = P(I.internalFormat, rt, tt, I.colorSpace),
                Lt = a && I.isVideoTexture !== !0,
                vt = xe.__version === void 0 || de === !0,
                Xt = Me.dataReady;
            let q = A(I, nn, wt);
            Q(n.TEXTURE_CUBE_MAP, I, wt);
            let Fe;
            if (Ie) {
                Lt && vt && t.texStorage2D(n.TEXTURE_CUBE_MAP, q, Qe, nn.width, nn.height);
                for (let U = 0; U < 6; U++) {
                    Fe = Pe[U].mipmaps;
                    for (let W = 0; W < Fe.length; W++) {
                        const Y = Fe[W];
                        I.format !== wi
                            ? rt !== null
                                ? Lt
                                    ? Xt &&
                                      t.compressedTexSubImage2D(
                                          n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                          W,
                                          0,
                                          0,
                                          Y.width,
                                          Y.height,
                                          rt,
                                          Y.data
                                      )
                                    : t.compressedTexImage2D(
                                          n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                          W,
                                          Qe,
                                          Y.width,
                                          Y.height,
                                          0,
                                          Y.data
                                      )
                                : console.warn(
                                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                                  )
                            : Lt
                            ? Xt &&
                              t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                  W,
                                  0,
                                  0,
                                  Y.width,
                                  Y.height,
                                  rt,
                                  tt,
                                  Y.data
                              )
                            : t.texImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                  W,
                                  Qe,
                                  Y.width,
                                  Y.height,
                                  0,
                                  rt,
                                  tt,
                                  Y.data
                              );
                    }
                }
            } else {
                if (((Fe = I.mipmaps), Lt && vt)) {
                    Fe.length > 0 && q++;
                    const U = yt(Pe[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, q, Qe, U.width, U.height);
                }
                for (let U = 0; U < 6; U++)
                    if (ht) {
                        Lt
                            ? Xt &&
                              t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                  0,
                                  0,
                                  0,
                                  Pe[U].width,
                                  Pe[U].height,
                                  rt,
                                  tt,
                                  Pe[U].data
                              )
                            : t.texImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                  0,
                                  Qe,
                                  Pe[U].width,
                                  Pe[U].height,
                                  0,
                                  rt,
                                  tt,
                                  Pe[U].data
                              );
                        for (let W = 0; W < Fe.length; W++) {
                            const ge = Fe[W].image[U].image;
                            Lt
                                ? Xt &&
                                  t.texSubImage2D(
                                      n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                      W + 1,
                                      0,
                                      0,
                                      ge.width,
                                      ge.height,
                                      rt,
                                      tt,
                                      ge.data
                                  )
                                : t.texImage2D(
                                      n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                      W + 1,
                                      Qe,
                                      ge.width,
                                      ge.height,
                                      0,
                                      rt,
                                      tt,
                                      ge.data
                                  );
                        }
                    } else {
                        Lt
                            ? Xt &&
                              t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                  0,
                                  0,
                                  0,
                                  rt,
                                  tt,
                                  Pe[U]
                              )
                            : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + U, 0, Qe, rt, tt, Pe[U]);
                        for (let W = 0; W < Fe.length; W++) {
                            const Y = Fe[W];
                            Lt
                                ? Xt &&
                                  t.texSubImage2D(
                                      n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                      W + 1,
                                      0,
                                      0,
                                      rt,
                                      tt,
                                      Y.image[U]
                                  )
                                : t.texImage2D(
                                      n.TEXTURE_CUBE_MAP_POSITIVE_X + U,
                                      W + 1,
                                      Qe,
                                      rt,
                                      tt,
                                      Y.image[U]
                                  );
                        }
                    }
            }
            M(I, wt) && T(n.TEXTURE_CUBE_MAP),
                (xe.__version = Me.version),
                I.onUpdate && I.onUpdate(I);
        }
        F.__version = I.version;
    }
    function et(F, I, ce, de, Me, xe) {
        const ut = s.convert(ce.format, ce.colorSpace),
            at = s.convert(ce.type),
            Ae = P(ce.internalFormat, ut, at, ce.colorSpace);
        if (!i.get(I).__hasExternalTextures) {
            const ht = Math.max(1, I.width >> xe),
                Pe = Math.max(1, I.height >> xe);
            Me === n.TEXTURE_3D || Me === n.TEXTURE_2D_ARRAY
                ? t.texImage3D(Me, xe, Ae, ht, Pe, I.depth, 0, ut, at, null)
                : t.texImage2D(Me, xe, Ae, ht, Pe, 0, ut, at, null);
        }
        t.bindFramebuffer(n.FRAMEBUFFER, F),
            We(I)
                ? c.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      de,
                      Me,
                      i.get(ce).__webglTexture,
                      0,
                      ye(I)
                  )
                : (Me === n.TEXTURE_2D ||
                      (Me >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
                          Me <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                  n.framebufferTexture2D(n.FRAMEBUFFER, de, Me, i.get(ce).__webglTexture, xe),
            t.bindFramebuffer(n.FRAMEBUFFER, null);
    }
    function Xe(F, I, ce) {
        if ((n.bindRenderbuffer(n.RENDERBUFFER, F), I.depthBuffer && !I.stencilBuffer)) {
            let de = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
            if (ce || We(I)) {
                const Me = I.depthTexture;
                Me &&
                    Me.isDepthTexture &&
                    (Me.type === Ki
                        ? (de = n.DEPTH_COMPONENT32F)
                        : Me.type === Ds && (de = n.DEPTH_COMPONENT24));
                const xe = ye(I);
                We(I)
                    ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, xe, de, I.width, I.height)
                    : n.renderbufferStorageMultisample(n.RENDERBUFFER, xe, de, I.width, I.height);
            } else n.renderbufferStorage(n.RENDERBUFFER, de, I.width, I.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, F);
        } else if (I.depthBuffer && I.stencilBuffer) {
            const de = ye(I);
            ce && We(I) === !1
                ? n.renderbufferStorageMultisample(
                      n.RENDERBUFFER,
                      de,
                      n.DEPTH24_STENCIL8,
                      I.width,
                      I.height
                  )
                : We(I)
                ? c.renderbufferStorageMultisampleEXT(
                      n.RENDERBUFFER,
                      de,
                      n.DEPTH24_STENCIL8,
                      I.width,
                      I.height
                  )
                : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, I.width, I.height),
                n.framebufferRenderbuffer(
                    n.FRAMEBUFFER,
                    n.DEPTH_STENCIL_ATTACHMENT,
                    n.RENDERBUFFER,
                    F
                );
        } else {
            const de = I.textures;
            for (let Me = 0; Me < de.length; Me++) {
                const xe = de[Me],
                    ut = s.convert(xe.format, xe.colorSpace),
                    at = s.convert(xe.type),
                    Ae = P(xe.internalFormat, ut, at, xe.colorSpace),
                    Ie = ye(I);
                ce && We(I) === !1
                    ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Ie, Ae, I.width, I.height)
                    : We(I)
                    ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Ie, Ae, I.width, I.height)
                    : n.renderbufferStorage(n.RENDERBUFFER, Ae, I.width, I.height);
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null);
    }
    function gt(F, I) {
        if (I && I.isWebGLCubeRenderTarget)
            throw new Error('Depth Texture with cube render targets is not supported');
        if (
            (t.bindFramebuffer(n.FRAMEBUFFER, F),
            !(I.depthTexture && I.depthTexture.isDepthTexture))
        )
            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        (!i.get(I.depthTexture).__webglTexture ||
            I.depthTexture.image.width !== I.width ||
            I.depthTexture.image.height !== I.height) &&
            ((I.depthTexture.image.width = I.width),
            (I.depthTexture.image.height = I.height),
            (I.depthTexture.needsUpdate = !0)),
            ae(I.depthTexture, 0);
        const de = i.get(I.depthTexture).__webglTexture,
            Me = ye(I);
        if (I.depthTexture.format === No)
            We(I)
                ? c.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      n.DEPTH_ATTACHMENT,
                      n.TEXTURE_2D,
                      de,
                      0,
                      Me
                  )
                : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, de, 0);
        else if (I.depthTexture.format === Va)
            We(I)
                ? c.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      n.DEPTH_STENCIL_ATTACHMENT,
                      n.TEXTURE_2D,
                      de,
                      0,
                      Me
                  )
                : n.framebufferTexture2D(
                      n.FRAMEBUFFER,
                      n.DEPTH_STENCIL_ATTACHMENT,
                      n.TEXTURE_2D,
                      de,
                      0
                  );
        else throw new Error('Unknown depthTexture format');
    }
    function De(F) {
        const I = i.get(F),
            ce = F.isWebGLCubeRenderTarget === !0;
        if (F.depthTexture && !I.__autoAllocateDepthBuffer) {
            if (ce) throw new Error('target.depthTexture not supported in Cube render targets');
            gt(I.__webglFramebuffer, F);
        } else if (ce) {
            I.__webglDepthbuffer = [];
            for (let de = 0; de < 6; de++)
                t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer[de]),
                    (I.__webglDepthbuffer[de] = n.createRenderbuffer()),
                    Xe(I.__webglDepthbuffer[de], F, !1);
        } else
            t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer),
                (I.__webglDepthbuffer = n.createRenderbuffer()),
                Xe(I.__webglDepthbuffer, F, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null);
    }
    function V(F, I, ce) {
        const de = i.get(F);
        I !== void 0 &&
            et(de.__webglFramebuffer, F, F.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
            ce !== void 0 && De(F);
    }
    function we(F) {
        const I = F.texture,
            ce = i.get(F),
            de = i.get(I);
        F.addEventListener('dispose', G);
        const Me = F.textures,
            xe = F.isWebGLCubeRenderTarget === !0,
            ut = Me.length > 1,
            at = g(F) || a;
        if (
            (ut ||
                (de.__webglTexture === void 0 && (de.__webglTexture = n.createTexture()),
                (de.__version = I.version),
                o.memory.textures++),
            xe)
        ) {
            ce.__webglFramebuffer = [];
            for (let Ae = 0; Ae < 6; Ae++)
                if (a && I.mipmaps && I.mipmaps.length > 0) {
                    ce.__webglFramebuffer[Ae] = [];
                    for (let Ie = 0; Ie < I.mipmaps.length; Ie++)
                        ce.__webglFramebuffer[Ae][Ie] = n.createFramebuffer();
                } else ce.__webglFramebuffer[Ae] = n.createFramebuffer();
        } else {
            if (a && I.mipmaps && I.mipmaps.length > 0) {
                ce.__webglFramebuffer = [];
                for (let Ae = 0; Ae < I.mipmaps.length; Ae++)
                    ce.__webglFramebuffer[Ae] = n.createFramebuffer();
            } else ce.__webglFramebuffer = n.createFramebuffer();
            if (ut)
                if (r.drawBuffers)
                    for (let Ae = 0, Ie = Me.length; Ae < Ie; Ae++) {
                        const ht = i.get(Me[Ae]);
                        ht.__webglTexture === void 0 &&
                            ((ht.__webglTexture = n.createTexture()), o.memory.textures++);
                    }
                else
                    console.warn(
                        'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
                    );
            if (a && F.samples > 0 && We(F) === !1) {
                (ce.__webglMultisampledFramebuffer = n.createFramebuffer()),
                    (ce.__webglColorRenderbuffer = []),
                    t.bindFramebuffer(n.FRAMEBUFFER, ce.__webglMultisampledFramebuffer);
                for (let Ae = 0; Ae < Me.length; Ae++) {
                    const Ie = Me[Ae];
                    (ce.__webglColorRenderbuffer[Ae] = n.createRenderbuffer()),
                        n.bindRenderbuffer(n.RENDERBUFFER, ce.__webglColorRenderbuffer[Ae]);
                    const ht = s.convert(Ie.format, Ie.colorSpace),
                        Pe = s.convert(Ie.type),
                        nn = P(Ie.internalFormat, ht, Pe, Ie.colorSpace, F.isXRRenderTarget === !0),
                        wt = ye(F);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, wt, nn, F.width, F.height),
                        n.framebufferRenderbuffer(
                            n.FRAMEBUFFER,
                            n.COLOR_ATTACHMENT0 + Ae,
                            n.RENDERBUFFER,
                            ce.__webglColorRenderbuffer[Ae]
                        );
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                    F.depthBuffer &&
                        ((ce.__webglDepthRenderbuffer = n.createRenderbuffer()),
                        Xe(ce.__webglDepthRenderbuffer, F, !0)),
                    t.bindFramebuffer(n.FRAMEBUFFER, null);
            }
        }
        if (xe) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, de.__webglTexture), Q(n.TEXTURE_CUBE_MAP, I, at);
            for (let Ae = 0; Ae < 6; Ae++)
                if (a && I.mipmaps && I.mipmaps.length > 0)
                    for (let Ie = 0; Ie < I.mipmaps.length; Ie++)
                        et(
                            ce.__webglFramebuffer[Ae][Ie],
                            F,
                            I,
                            n.COLOR_ATTACHMENT0,
                            n.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                            Ie
                        );
                else
                    et(
                        ce.__webglFramebuffer[Ae],
                        F,
                        I,
                        n.COLOR_ATTACHMENT0,
                        n.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                        0
                    );
            M(I, at) && T(n.TEXTURE_CUBE_MAP), t.unbindTexture();
        } else if (ut) {
            for (let Ae = 0, Ie = Me.length; Ae < Ie; Ae++) {
                const ht = Me[Ae],
                    Pe = i.get(ht);
                t.bindTexture(n.TEXTURE_2D, Pe.__webglTexture),
                    Q(n.TEXTURE_2D, ht, at),
                    et(ce.__webglFramebuffer, F, ht, n.COLOR_ATTACHMENT0 + Ae, n.TEXTURE_2D, 0),
                    M(ht, at) && T(n.TEXTURE_2D);
            }
            t.unbindTexture();
        } else {
            let Ae = n.TEXTURE_2D;
            if (
                ((F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) &&
                    (a
                        ? (Ae = F.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
                        : console.error(
                              'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.'
                          )),
                t.bindTexture(Ae, de.__webglTexture),
                Q(Ae, I, at),
                a && I.mipmaps && I.mipmaps.length > 0)
            )
                for (let Ie = 0; Ie < I.mipmaps.length; Ie++)
                    et(ce.__webglFramebuffer[Ie], F, I, n.COLOR_ATTACHMENT0, Ae, Ie);
            else et(ce.__webglFramebuffer, F, I, n.COLOR_ATTACHMENT0, Ae, 0);
            M(I, at) && T(Ae), t.unbindTexture();
        }
        F.depthBuffer && De(F);
    }
    function ve(F) {
        const I = g(F) || a,
            ce = F.textures;
        for (let de = 0, Me = ce.length; de < Me; de++) {
            const xe = ce[de];
            if (M(xe, I)) {
                const ut = F.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D,
                    at = i.get(xe).__webglTexture;
                t.bindTexture(ut, at), T(ut), t.unbindTexture();
            }
        }
    }
    function Ee(F) {
        if (a && F.samples > 0 && We(F) === !1) {
            const I = F.textures,
                ce = F.width,
                de = F.height;
            let Me = n.COLOR_BUFFER_BIT;
            const xe = [],
                ut = F.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                at = i.get(F),
                Ae = I.length > 1;
            if (Ae)
                for (let Ie = 0; Ie < I.length; Ie++)
                    t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(
                            n.FRAMEBUFFER,
                            n.COLOR_ATTACHMENT0 + Ie,
                            n.RENDERBUFFER,
                            null
                        ),
                        t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
                        n.framebufferTexture2D(
                            n.DRAW_FRAMEBUFFER,
                            n.COLOR_ATTACHMENT0 + Ie,
                            n.TEXTURE_2D,
                            null,
                            0
                        );
            t.bindFramebuffer(n.READ_FRAMEBUFFER, at.__webglMultisampledFramebuffer),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, at.__webglFramebuffer);
            for (let Ie = 0; Ie < I.length; Ie++) {
                xe.push(n.COLOR_ATTACHMENT0 + Ie), F.depthBuffer && xe.push(ut);
                const ht = at.__ignoreDepthValues !== void 0 ? at.__ignoreDepthValues : !1;
                if (
                    (ht === !1 &&
                        (F.depthBuffer && (Me |= n.DEPTH_BUFFER_BIT),
                        F.stencilBuffer && (Me |= n.STENCIL_BUFFER_BIT)),
                    Ae &&
                        n.framebufferRenderbuffer(
                            n.READ_FRAMEBUFFER,
                            n.COLOR_ATTACHMENT0,
                            n.RENDERBUFFER,
                            at.__webglColorRenderbuffer[Ie]
                        ),
                    ht === !0 &&
                        (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [ut]),
                        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [ut])),
                    Ae)
                ) {
                    const Pe = i.get(I[Ie]).__webglTexture;
                    n.framebufferTexture2D(
                        n.DRAW_FRAMEBUFFER,
                        n.COLOR_ATTACHMENT0,
                        n.TEXTURE_2D,
                        Pe,
                        0
                    );
                }
                n.blitFramebuffer(0, 0, ce, de, 0, 0, ce, de, Me, n.NEAREST),
                    f && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, xe);
            }
            if (
                (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                Ae)
            )
                for (let Ie = 0; Ie < I.length; Ie++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(
                            n.FRAMEBUFFER,
                            n.COLOR_ATTACHMENT0 + Ie,
                            n.RENDERBUFFER,
                            at.__webglColorRenderbuffer[Ie]
                        );
                    const ht = i.get(I[Ie]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
                        n.framebufferTexture2D(
                            n.DRAW_FRAMEBUFFER,
                            n.COLOR_ATTACHMENT0 + Ie,
                            n.TEXTURE_2D,
                            ht,
                            0
                        );
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, at.__webglMultisampledFramebuffer);
        }
    }
    function ye(F) {
        return Math.min(r.maxSamples, F.samples);
    }
    function We(F) {
        const I = i.get(F);
        return (
            a &&
            F.samples > 0 &&
            e.has('WEBGL_multisampled_render_to_texture') === !0 &&
            I.__useRenderToTexture !== !1
        );
    }
    function He(F) {
        const I = o.render.frame;
        h.get(F) !== I && (h.set(F, I), F.update());
    }
    function Ke(F, I) {
        const ce = F.colorSpace,
            de = F.format,
            Me = F.type;
        return (
            F.isCompressedTexture === !0 ||
                F.isVideoTexture === !0 ||
                F.format === em ||
                (ce !== Ys &&
                    ce !== Ps &&
                    (Gt.getTransfer(ce) === Jt
                        ? a === !1
                            ? e.has('EXT_sRGB') === !0 && de === wi
                                ? ((F.format = em), (F.minFilter = dn), (F.generateMipmaps = !1))
                                : (I = Px.sRGBToLinear(I))
                            : (de !== wi || Me !== ds) &&
                              console.warn(
                                  'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                              )
                        : console.error(
                              'THREE.WebGLTextures: Unsupported texture color space:',
                              ce
                          ))),
            I
        );
    }
    function yt(F) {
        return (
            typeof HTMLImageElement < 'u' && F instanceof HTMLImageElement
                ? ((d.width = F.naturalWidth || F.width), (d.height = F.naturalHeight || F.height))
                : typeof VideoFrame < 'u' && F instanceof VideoFrame
                ? ((d.width = F.displayWidth), (d.height = F.displayHeight))
                : ((d.width = F.width), (d.height = F.height)),
            d
        );
    }
    (this.allocateTextureUnit = oe),
        (this.resetTextureUnits = j),
        (this.setTexture2D = ae),
        (this.setTexture2DArray = N),
        (this.setTexture3D = B),
        (this.setTextureCube = H),
        (this.rebindTextures = V),
        (this.setupRenderTarget = we),
        (this.updateRenderTargetMipmap = ve),
        (this.updateMultisampleRenderTarget = Ee),
        (this.setupDepthRenderbuffer = De),
        (this.setupFrameBufferTexture = et),
        (this.useMultisampledRTT = We);
}
function XC(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o = Ps) {
        let a;
        const c = Gt.getTransfer(o);
        if (s === ds) return n.UNSIGNED_BYTE;
        if (s === xx) return n.UNSIGNED_SHORT_4_4_4_4;
        if (s === Sx) return n.UNSIGNED_SHORT_5_5_5_1;
        if (s === fC) return n.BYTE;
        if (s === dC) return n.SHORT;
        if (s === bm) return n.UNSIGNED_SHORT;
        if (s === yx) return n.INT;
        if (s === Ds) return n.UNSIGNED_INT;
        if (s === Ki) return n.FLOAT;
        if (s === _u)
            return i
                ? n.HALF_FLOAT
                : ((a = e.get('OES_texture_half_float')), a !== null ? a.HALF_FLOAT_OES : null);
        if (s === hC) return n.ALPHA;
        if (s === wi) return n.RGBA;
        if (s === pC) return n.LUMINANCE;
        if (s === mC) return n.LUMINANCE_ALPHA;
        if (s === No) return n.DEPTH_COMPONENT;
        if (s === Va) return n.DEPTH_STENCIL;
        if (s === em) return (a = e.get('EXT_sRGB')), a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === Mx) return n.RED;
        if (s === wx) return n.RED_INTEGER;
        if (s === gC) return n.RG;
        if (s === Ex) return n.RG_INTEGER;
        if (s === Tx) return n.RGBA_INTEGER;
        if (s === vp || s === _p || s === yp || s === xp)
            if (c === Jt)
                if (((a = e.get('WEBGL_compressed_texture_s3tc_srgb')), a !== null)) {
                    if (s === vp) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === _p) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === yp) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === xp) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else return null;
            else if (((a = e.get('WEBGL_compressed_texture_s3tc')), a !== null)) {
                if (s === vp) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === _p) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === yp) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === xp) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        if (s === I_ || s === N_ || s === D_ || s === U_)
            if (((a = e.get('WEBGL_compressed_texture_pvrtc')), a !== null)) {
                if (s === I_) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === N_) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === D_) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === U_) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        if (s === Ax)
            return (
                (a = e.get('WEBGL_compressed_texture_etc1')),
                a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
            );
        if (s === O_ || s === F_)
            if (((a = e.get('WEBGL_compressed_texture_etc')), a !== null)) {
                if (s === O_) return c === Jt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === F_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                        : a.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
        if (
            s === k_ ||
            s === z_ ||
            s === B_ ||
            s === H_ ||
            s === V_ ||
            s === G_ ||
            s === W_ ||
            s === j_ ||
            s === X_ ||
            s === Y_ ||
            s === q_ ||
            s === Z_ ||
            s === K_ ||
            s === J_
        )
            if (((a = e.get('WEBGL_compressed_texture_astc')), a !== null)) {
                if (s === k_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                        : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === z_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                        : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === B_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                        : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === H_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                        : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === V_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                        : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === G_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                        : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === W_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                        : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === j_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                        : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === X_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                        : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === Y_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                        : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === q_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                        : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === Z_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                        : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === K_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                        : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === J_)
                    return c === Jt
                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                        : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
        if (s === Sp || s === Q_ || s === $_)
            if (((a = e.get('EXT_texture_compression_bptc')), a !== null)) {
                if (s === Sp)
                    return c === Jt
                        ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                        : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (s === Q_) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (s === $_) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
        if (s === vC || s === ey || s === ty || s === ny)
            if (((a = e.get('EXT_texture_compression_rgtc')), a !== null)) {
                if (s === Sp) return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === ey) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === ty) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === ny) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
        return s === Io
            ? i
                ? n.UNSIGNED_INT_24_8
                : ((a = e.get('WEBGL_depth_texture')),
                  a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
            : n[s] !== void 0
            ? n[s]
            : null;
    }
    return { convert: r };
}
class YC extends Zn {
    constructor(e = []) {
        super(), (this.isArrayCamera = !0), (this.cameras = e);
    }
}
class $l extends Ht {
    constructor() {
        super(), (this.isGroup = !0), (this.type = 'Group');
    }
}
const Jk = { type: 'move' };
class r0 {
    constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
        return (
            this._hand === null &&
                ((this._hand = new $l()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
            this._hand
        );
    }
    getTargetRaySpace() {
        return (
            this._targetRay === null &&
                ((this._targetRay = new $l()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new k()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new k())),
            this._targetRay
        );
    }
    getGripSpace() {
        return (
            this._grip === null &&
                ((this._grip = new $l()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new k()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new k())),
            this._grip
        );
    }
    dispatchEvent(e) {
        return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
        );
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
        }
        return this.dispatchEvent({ type: 'connected', data: e }), this;
    }
    disconnect(e) {
        return (
            this.dispatchEvent({ type: 'disconnected', data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
        );
    }
    update(e, t, i) {
        let r = null,
            s = null,
            o = null;
        const a = this._targetRay,
            c = this._grip,
            f = this._hand;
        if (e && t.session.visibilityState !== 'visible-blurred') {
            if (f && e.hand) {
                o = !0;
                for (const w of e.hand.values()) {
                    const x = t.getJointPose(w, i),
                        g = this._getHandJoint(f, w);
                    x !== null &&
                        (g.matrix.fromArray(x.transform.matrix),
                        g.matrix.decompose(g.position, g.rotation, g.scale),
                        (g.matrixWorldNeedsUpdate = !0),
                        (g.jointRadius = x.radius)),
                        (g.visible = x !== null);
                }
                const d = f.joints['index-finger-tip'],
                    h = f.joints['thumb-tip'],
                    p = d.position.distanceTo(h.position),
                    v = 0.02,
                    _ = 0.005;
                f.inputState.pinching && p > v + _
                    ? ((f.inputState.pinching = !1),
                      this.dispatchEvent({
                          type: 'pinchend',
                          handedness: e.handedness,
                          target: this,
                      }))
                    : !f.inputState.pinching &&
                      p <= v - _ &&
                      ((f.inputState.pinching = !0),
                      this.dispatchEvent({
                          type: 'pinchstart',
                          handedness: e.handedness,
                          target: this,
                      }));
            } else
                c !== null &&
                    e.gripSpace &&
                    ((s = t.getPose(e.gripSpace, i)),
                    s !== null &&
                        (c.matrix.fromArray(s.transform.matrix),
                        c.matrix.decompose(c.position, c.rotation, c.scale),
                        (c.matrixWorldNeedsUpdate = !0),
                        s.linearVelocity
                            ? ((c.hasLinearVelocity = !0), c.linearVelocity.copy(s.linearVelocity))
                            : (c.hasLinearVelocity = !1),
                        s.angularVelocity
                            ? ((c.hasAngularVelocity = !0),
                              c.angularVelocity.copy(s.angularVelocity))
                            : (c.hasAngularVelocity = !1)));
            a !== null &&
                ((r = t.getPose(e.targetRaySpace, i)),
                r === null && s !== null && (r = s),
                r !== null &&
                    (a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    (a.matrixWorldNeedsUpdate = !0),
                    r.linearVelocity
                        ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(r.linearVelocity))
                        : (a.hasLinearVelocity = !1),
                    r.angularVelocity
                        ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(r.angularVelocity))
                        : (a.hasAngularVelocity = !1),
                    this.dispatchEvent(Jk)));
        }
        return (
            a !== null && (a.visible = r !== null),
            c !== null && (c.visible = s !== null),
            f !== null && (f.visible = o !== null),
            this
        );
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new $l();
            (i.matrixAutoUpdate = !1), (i.visible = !1), (e.joints[t.jointName] = i), e.add(i);
        }
        return e.joints[t.jointName];
    }
}
const Qk = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
    $k = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class e4 {
    constructor() {
        (this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0);
    }
    init(e, t, i) {
        if (this.texture === null) {
            const r = new mn(),
                s = e.properties.get(r);
            (s.__webglTexture = t.texture),
                (t.depthNear != i.depthNear || t.depthFar != i.depthFar) &&
                    ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
                (this.texture = r);
        }
    }
    render(e, t) {
        if (this.texture !== null) {
            if (this.mesh === null) {
                const i = t.cameras[0].viewport,
                    r = new Gr({
                        extensions: { fragDepth: !0 },
                        vertexShader: Qk,
                        fragmentShader: $k,
                        uniforms: {
                            depthColor: { value: this.texture },
                            depthWidth: { value: i.z },
                            depthHeight: { value: i.w },
                        },
                    });
                this.mesh = new On(new Ru(20, 20), r);
            }
            e.render(this.mesh, t);
        }
    }
    reset() {
        (this.texture = null), (this.mesh = null);
    }
}
class t4 extends qs {
    constructor(e, t) {
        super();
        const i = this;
        let r = null,
            s = 1,
            o = null,
            a = 'local-floor',
            c = 1,
            f = null,
            d = null,
            h = null,
            p = null,
            v = null,
            _ = null;
        const w = new e4(),
            x = t.getContextAttributes();
        let g = null,
            S = null;
        const M = [],
            T = [],
            P = new _e();
        let A = null;
        const R = new Zn();
        R.layers.enable(1), (R.viewport = new Wt());
        const D = new Zn();
        D.layers.enable(2), (D.viewport = new Wt());
        const G = [R, D],
            b = new YC();
        b.layers.enable(1), b.layers.enable(2);
        let L = null,
            ee = null;
        (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (Q) {
                let me = M[Q];
                return me === void 0 && ((me = new r0()), (M[Q] = me)), me.getTargetRaySpace();
            }),
            (this.getControllerGrip = function (Q) {
                let me = M[Q];
                return me === void 0 && ((me = new r0()), (M[Q] = me)), me.getGripSpace();
            }),
            (this.getHand = function (Q) {
                let me = M[Q];
                return me === void 0 && ((me = new r0()), (M[Q] = me)), me.getHandSpace();
            });
        function ie(Q) {
            const me = T.indexOf(Q.inputSource);
            if (me === -1) return;
            const Se = M[me];
            Se !== void 0 &&
                (Se.update(Q.inputSource, Q.frame, f || o),
                Se.dispatchEvent({ type: Q.type, data: Q.inputSource }));
        }
        function j() {
            r.removeEventListener('select', ie),
                r.removeEventListener('selectstart', ie),
                r.removeEventListener('selectend', ie),
                r.removeEventListener('squeeze', ie),
                r.removeEventListener('squeezestart', ie),
                r.removeEventListener('squeezeend', ie),
                r.removeEventListener('end', j),
                r.removeEventListener('inputsourceschange', oe);
            for (let Q = 0; Q < M.length; Q++) {
                const me = T[Q];
                me !== null && ((T[Q] = null), M[Q].disconnect(me));
            }
            (L = null),
                (ee = null),
                w.reset(),
                e.setRenderTarget(g),
                (v = null),
                (p = null),
                (h = null),
                (r = null),
                (S = null),
                be.stop(),
                (i.isPresenting = !1),
                e.setPixelRatio(A),
                e.setSize(P.width, P.height, !1),
                i.dispatchEvent({ type: 'sessionend' });
        }
        (this.setFramebufferScaleFactor = function (Q) {
            (s = Q),
                i.isPresenting === !0 &&
                    console.warn(
                        'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
                    );
        }),
            (this.setReferenceSpaceType = function (Q) {
                (a = Q),
                    i.isPresenting === !0 &&
                        console.warn(
                            'THREE.WebXRManager: Cannot change reference space type while presenting.'
                        );
            }),
            (this.getReferenceSpace = function () {
                return f || o;
            }),
            (this.setReferenceSpace = function (Q) {
                f = Q;
            }),
            (this.getBaseLayer = function () {
                return p !== null ? p : v;
            }),
            (this.getBinding = function () {
                return h;
            }),
            (this.getFrame = function () {
                return _;
            }),
            (this.getSession = function () {
                return r;
            }),
            (this.setSession = async function (Q) {
                if (((r = Q), r !== null)) {
                    if (
                        ((g = e.getRenderTarget()),
                        r.addEventListener('select', ie),
                        r.addEventListener('selectstart', ie),
                        r.addEventListener('selectend', ie),
                        r.addEventListener('squeeze', ie),
                        r.addEventListener('squeezestart', ie),
                        r.addEventListener('squeezeend', ie),
                        r.addEventListener('end', j),
                        r.addEventListener('inputsourceschange', oe),
                        x.xrCompatible !== !0 && (await t.makeXRCompatible()),
                        (A = e.getPixelRatio()),
                        e.getSize(P),
                        r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
                    ) {
                        const me = {
                            antialias: r.renderState.layers === void 0 ? x.antialias : !0,
                            alpha: !0,
                            depth: x.depth,
                            stencil: x.stencil,
                            framebufferScaleFactor: s,
                        };
                        (v = new XRWebGLLayer(r, t, me)),
                            r.updateRenderState({ baseLayer: v }),
                            e.setPixelRatio(1),
                            e.setSize(v.framebufferWidth, v.framebufferHeight, !1),
                            (S = new Vr(v.framebufferWidth, v.framebufferHeight, {
                                format: wi,
                                type: ds,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: x.stencil,
                            }));
                    } else {
                        let me = null,
                            Se = null,
                            ke = null;
                        x.depth &&
                            ((ke = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
                            (me = x.stencil ? Va : No),
                            (Se = x.stencil ? Io : Ds));
                        const et = { colorFormat: t.RGBA8, depthFormat: ke, scaleFactor: s };
                        (h = new XRWebGLBinding(r, t)),
                            (p = h.createProjectionLayer(et)),
                            r.updateRenderState({ layers: [p] }),
                            e.setPixelRatio(1),
                            e.setSize(p.textureWidth, p.textureHeight, !1),
                            (S = new Vr(p.textureWidth, p.textureHeight, {
                                format: wi,
                                type: ds,
                                depthTexture: new Ux(
                                    p.textureWidth,
                                    p.textureHeight,
                                    Se,
                                    void 0,
                                    void 0,
                                    void 0,
                                    void 0,
                                    void 0,
                                    void 0,
                                    me
                                ),
                                stencilBuffer: x.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: x.antialias ? 4 : 0,
                            }));
                        const Xe = e.properties.get(S);
                        Xe.__ignoreDepthValues = p.ignoreDepthValues;
                    }
                    (S.isXRRenderTarget = !0),
                        this.setFoveation(c),
                        (f = null),
                        (o = await r.requestReferenceSpace(a)),
                        be.setContext(r),
                        be.start(),
                        (i.isPresenting = !0),
                        i.dispatchEvent({ type: 'sessionstart' });
                }
            }),
            (this.getEnvironmentBlendMode = function () {
                if (r !== null) return r.environmentBlendMode;
            });
        function oe(Q) {
            for (let me = 0; me < Q.removed.length; me++) {
                const Se = Q.removed[me],
                    ke = T.indexOf(Se);
                ke >= 0 && ((T[ke] = null), M[ke].disconnect(Se));
            }
            for (let me = 0; me < Q.added.length; me++) {
                const Se = Q.added[me];
                let ke = T.indexOf(Se);
                if (ke === -1) {
                    for (let Xe = 0; Xe < M.length; Xe++)
                        if (Xe >= T.length) {
                            T.push(Se), (ke = Xe);
                            break;
                        } else if (T[Xe] === null) {
                            (T[Xe] = Se), (ke = Xe);
                            break;
                        }
                    if (ke === -1) break;
                }
                const et = M[ke];
                et && et.connect(Se);
            }
        }
        const te = new k(),
            ae = new k();
        function N(Q, me, Se) {
            te.setFromMatrixPosition(me.matrixWorld), ae.setFromMatrixPosition(Se.matrixWorld);
            const ke = te.distanceTo(ae),
                et = me.projectionMatrix.elements,
                Xe = Se.projectionMatrix.elements,
                gt = et[14] / (et[10] - 1),
                De = et[14] / (et[10] + 1),
                V = (et[9] + 1) / et[5],
                we = (et[9] - 1) / et[5],
                ve = (et[8] - 1) / et[0],
                Ee = (Xe[8] + 1) / Xe[0],
                ye = gt * ve,
                We = gt * Ee,
                He = ke / (-ve + Ee),
                Ke = He * -ve;
            me.matrixWorld.decompose(Q.position, Q.quaternion, Q.scale),
                Q.translateX(Ke),
                Q.translateZ(He),
                Q.matrixWorld.compose(Q.position, Q.quaternion, Q.scale),
                Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
            const yt = gt + He,
                F = De + He,
                I = ye - Ke,
                ce = We + (ke - Ke),
                de = ((V * De) / F) * yt,
                Me = ((we * De) / F) * yt;
            Q.projectionMatrix.makePerspective(I, ce, de, Me, yt, F),
                Q.projectionMatrixInverse.copy(Q.projectionMatrix).invert();
        }
        function B(Q, me) {
            me === null
                ? Q.matrixWorld.copy(Q.matrix)
                : Q.matrixWorld.multiplyMatrices(me.matrixWorld, Q.matrix),
                Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
        }
        this.updateCamera = function (Q) {
            if (r === null) return;
            w.texture !== null && ((Q.near = w.depthNear), (Q.far = w.depthFar)),
                (b.near = D.near = R.near = Q.near),
                (b.far = D.far = R.far = Q.far),
                (L !== b.near || ee !== b.far) &&
                    (r.updateRenderState({ depthNear: b.near, depthFar: b.far }),
                    (L = b.near),
                    (ee = b.far),
                    (R.near = L),
                    (R.far = ee),
                    (D.near = L),
                    (D.far = ee),
                    R.updateProjectionMatrix(),
                    D.updateProjectionMatrix(),
                    Q.updateProjectionMatrix());
            const me = Q.parent,
                Se = b.cameras;
            B(b, me);
            for (let ke = 0; ke < Se.length; ke++) B(Se[ke], me);
            Se.length === 2 ? N(b, R, D) : b.projectionMatrix.copy(R.projectionMatrix), H(Q, b, me);
        };
        function H(Q, me, Se) {
            Se === null
                ? Q.matrix.copy(me.matrixWorld)
                : (Q.matrix.copy(Se.matrixWorld),
                  Q.matrix.invert(),
                  Q.matrix.multiply(me.matrixWorld)),
                Q.matrix.decompose(Q.position, Q.quaternion, Q.scale),
                Q.updateMatrixWorld(!0),
                Q.projectionMatrix.copy(me.projectionMatrix),
                Q.projectionMatrixInverse.copy(me.projectionMatrixInverse),
                Q.isPerspectiveCamera &&
                    ((Q.fov = yu * 2 * Math.atan(1 / Q.projectionMatrix.elements[5])),
                    (Q.zoom = 1));
        }
        (this.getCamera = function () {
            return b;
        }),
            (this.getFoveation = function () {
                if (!(p === null && v === null)) return c;
            }),
            (this.setFoveation = function (Q) {
                (c = Q),
                    p !== null && (p.fixedFoveation = Q),
                    v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = Q);
            }),
            (this.hasDepthSensing = function () {
                return w.texture !== null;
            });
        let K = null;
        function le(Q, me) {
            if (((d = me.getViewerPose(f || o)), (_ = me), d !== null)) {
                const Se = d.views;
                v !== null &&
                    (e.setRenderTargetFramebuffer(S, v.framebuffer), e.setRenderTarget(S));
                let ke = !1;
                Se.length !== b.cameras.length && ((b.cameras.length = 0), (ke = !0));
                for (let Xe = 0; Xe < Se.length; Xe++) {
                    const gt = Se[Xe];
                    let De = null;
                    if (v !== null) De = v.getViewport(gt);
                    else {
                        const we = h.getViewSubImage(p, gt);
                        (De = we.viewport),
                            Xe === 0 &&
                                (e.setRenderTargetTextures(
                                    S,
                                    we.colorTexture,
                                    p.ignoreDepthValues ? void 0 : we.depthStencilTexture
                                ),
                                e.setRenderTarget(S));
                    }
                    let V = G[Xe];
                    V === void 0 &&
                        ((V = new Zn()), V.layers.enable(Xe), (V.viewport = new Wt()), (G[Xe] = V)),
                        V.matrix.fromArray(gt.transform.matrix),
                        V.matrix.decompose(V.position, V.quaternion, V.scale),
                        V.projectionMatrix.fromArray(gt.projectionMatrix),
                        V.projectionMatrixInverse.copy(V.projectionMatrix).invert(),
                        V.viewport.set(De.x, De.y, De.width, De.height),
                        Xe === 0 &&
                            (b.matrix.copy(V.matrix),
                            b.matrix.decompose(b.position, b.quaternion, b.scale)),
                        ke === !0 && b.cameras.push(V);
                }
                const et = r.enabledFeatures;
                if (et && et.includes('depth-sensing')) {
                    const Xe = h.getDepthInformation(Se[0]);
                    Xe && Xe.isValid && Xe.texture && w.init(e, Xe, r.renderState);
                }
            }
            for (let Se = 0; Se < M.length; Se++) {
                const ke = T[Se],
                    et = M[Se];
                ke !== null && et !== void 0 && et.update(ke, me, f || o);
            }
            w.render(e, b),
                K && K(Q, me),
                me.detectedPlanes && i.dispatchEvent({ type: 'planesdetected', data: me }),
                (_ = null);
        }
        const be = new BC();
        be.setAnimationLoop(le),
            (this.setAnimationLoop = function (Q) {
                K = Q;
            }),
            (this.dispose = function () {});
    }
}
const la = new nr(),
    n4 = new ft();
function i4(n, e) {
    function t(x, g) {
        x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix);
    }
    function i(x, g) {
        g.color.getRGB(x.fogColor.value, OC(n)),
            g.isFog
                ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
                : g.isFogExp2 && (x.fogDensity.value = g.density);
    }
    function r(x, g, S, M, T) {
        g.isMeshBasicMaterial || g.isMeshLambertMaterial
            ? s(x, g)
            : g.isMeshToonMaterial
            ? (s(x, g), h(x, g))
            : g.isMeshPhongMaterial
            ? (s(x, g), d(x, g))
            : g.isMeshStandardMaterial
            ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && v(x, g, T))
            : g.isMeshMatcapMaterial
            ? (s(x, g), _(x, g))
            : g.isMeshDepthMaterial
            ? s(x, g)
            : g.isMeshDistanceMaterial
            ? (s(x, g), w(x, g))
            : g.isMeshNormalMaterial
            ? s(x, g)
            : g.isLineBasicMaterial
            ? (o(x, g), g.isLineDashedMaterial && a(x, g))
            : g.isPointsMaterial
            ? c(x, g, S, M)
            : g.isSpriteMaterial
            ? f(x, g)
            : g.isShadowMaterial
            ? (x.color.value.copy(g.color), (x.opacity.value = g.opacity))
            : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
    }
    function s(x, g) {
        (x.opacity.value = g.opacity),
            g.color && x.diffuse.value.copy(g.color),
            g.emissive && x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
            g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
            g.alphaMap && ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
            g.bumpMap &&
                ((x.bumpMap.value = g.bumpMap),
                t(g.bumpMap, x.bumpMapTransform),
                (x.bumpScale.value = g.bumpScale),
                g.side === Ai && (x.bumpScale.value *= -1)),
            g.normalMap &&
                ((x.normalMap.value = g.normalMap),
                t(g.normalMap, x.normalMapTransform),
                x.normalScale.value.copy(g.normalScale),
                g.side === Ai && x.normalScale.value.negate()),
            g.displacementMap &&
                ((x.displacementMap.value = g.displacementMap),
                t(g.displacementMap, x.displacementMapTransform),
                (x.displacementScale.value = g.displacementScale),
                (x.displacementBias.value = g.displacementBias)),
            g.emissiveMap &&
                ((x.emissiveMap.value = g.emissiveMap), t(g.emissiveMap, x.emissiveMapTransform)),
            g.specularMap &&
                ((x.specularMap.value = g.specularMap), t(g.specularMap, x.specularMapTransform)),
            g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
        const S = e.get(g),
            M = S.envMap,
            T = S.envMapRotation;
        if (
            (M &&
                ((x.envMap.value = M),
                la.copy(T),
                (la.x *= -1),
                (la.y *= -1),
                (la.z *= -1),
                M.isCubeTexture && M.isRenderTargetTexture === !1 && ((la.y *= -1), (la.z *= -1)),
                x.envMapRotation.value.setFromMatrix4(n4.makeRotationFromEuler(la)),
                (x.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1),
                (x.reflectivity.value = g.reflectivity),
                (x.ior.value = g.ior),
                (x.refractionRatio.value = g.refractionRatio)),
            g.lightMap)
        ) {
            x.lightMap.value = g.lightMap;
            const P = n._useLegacyLights === !0 ? Math.PI : 1;
            (x.lightMapIntensity.value = g.lightMapIntensity * P),
                t(g.lightMap, x.lightMapTransform);
        }
        g.aoMap &&
            ((x.aoMap.value = g.aoMap),
            (x.aoMapIntensity.value = g.aoMapIntensity),
            t(g.aoMap, x.aoMapTransform));
    }
    function o(x, g) {
        x.diffuse.value.copy(g.color),
            (x.opacity.value = g.opacity),
            g.map && ((x.map.value = g.map), t(g.map, x.mapTransform));
    }
    function a(x, g) {
        (x.dashSize.value = g.dashSize),
            (x.totalSize.value = g.dashSize + g.gapSize),
            (x.scale.value = g.scale);
    }
    function c(x, g, S, M) {
        x.diffuse.value.copy(g.color),
            (x.opacity.value = g.opacity),
            (x.size.value = g.size * S),
            (x.scale.value = M * 0.5),
            g.map && ((x.map.value = g.map), t(g.map, x.uvTransform)),
            g.alphaMap && ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
            g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    }
    function f(x, g) {
        x.diffuse.value.copy(g.color),
            (x.opacity.value = g.opacity),
            (x.rotation.value = g.rotation),
            g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
            g.alphaMap && ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
            g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    }
    function d(x, g) {
        x.specular.value.copy(g.specular), (x.shininess.value = Math.max(g.shininess, 1e-4));
    }
    function h(x, g) {
        g.gradientMap && (x.gradientMap.value = g.gradientMap);
    }
    function p(x, g) {
        (x.metalness.value = g.metalness),
            g.metalnessMap &&
                ((x.metalnessMap.value = g.metalnessMap),
                t(g.metalnessMap, x.metalnessMapTransform)),
            (x.roughness.value = g.roughness),
            g.roughnessMap &&
                ((x.roughnessMap.value = g.roughnessMap),
                t(g.roughnessMap, x.roughnessMapTransform)),
            e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity);
    }
    function v(x, g, S) {
        (x.ior.value = g.ior),
            g.sheen > 0 &&
                (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
                (x.sheenRoughness.value = g.sheenRoughness),
                g.sheenColorMap &&
                    ((x.sheenColorMap.value = g.sheenColorMap),
                    t(g.sheenColorMap, x.sheenColorMapTransform)),
                g.sheenRoughnessMap &&
                    ((x.sheenRoughnessMap.value = g.sheenRoughnessMap),
                    t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
            g.clearcoat > 0 &&
                ((x.clearcoat.value = g.clearcoat),
                (x.clearcoatRoughness.value = g.clearcoatRoughness),
                g.clearcoatMap &&
                    ((x.clearcoatMap.value = g.clearcoatMap),
                    t(g.clearcoatMap, x.clearcoatMapTransform)),
                g.clearcoatRoughnessMap &&
                    ((x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
                    t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
                g.clearcoatNormalMap &&
                    ((x.clearcoatNormalMap.value = g.clearcoatNormalMap),
                    t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
                    x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
                    g.side === Ai && x.clearcoatNormalScale.value.negate())),
            g.iridescence > 0 &&
                ((x.iridescence.value = g.iridescence),
                (x.iridescenceIOR.value = g.iridescenceIOR),
                (x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
                (x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
                g.iridescenceMap &&
                    ((x.iridescenceMap.value = g.iridescenceMap),
                    t(g.iridescenceMap, x.iridescenceMapTransform)),
                g.iridescenceThicknessMap &&
                    ((x.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
                    t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
            g.transmission > 0 &&
                ((x.transmission.value = g.transmission),
                (x.transmissionSamplerMap.value = S.texture),
                x.transmissionSamplerSize.value.set(S.width, S.height),
                g.transmissionMap &&
                    ((x.transmissionMap.value = g.transmissionMap),
                    t(g.transmissionMap, x.transmissionMapTransform)),
                (x.thickness.value = g.thickness),
                g.thicknessMap &&
                    ((x.thicknessMap.value = g.thicknessMap),
                    t(g.thicknessMap, x.thicknessMapTransform)),
                (x.attenuationDistance.value = g.attenuationDistance),
                x.attenuationColor.value.copy(g.attenuationColor)),
            g.anisotropy > 0 &&
                (x.anisotropyVector.value.set(
                    g.anisotropy * Math.cos(g.anisotropyRotation),
                    g.anisotropy * Math.sin(g.anisotropyRotation)
                ),
                g.anisotropyMap &&
                    ((x.anisotropyMap.value = g.anisotropyMap),
                    t(g.anisotropyMap, x.anisotropyMapTransform))),
            (x.specularIntensity.value = g.specularIntensity),
            x.specularColor.value.copy(g.specularColor),
            g.specularColorMap &&
                ((x.specularColorMap.value = g.specularColorMap),
                t(g.specularColorMap, x.specularColorMapTransform)),
            g.specularIntensityMap &&
                ((x.specularIntensityMap.value = g.specularIntensityMap),
                t(g.specularIntensityMap, x.specularIntensityMapTransform));
    }
    function _(x, g) {
        g.matcap && (x.matcap.value = g.matcap);
    }
    function w(x, g) {
        const S = e.get(g).light;
        x.referencePosition.value.setFromMatrixPosition(S.matrixWorld),
            (x.nearDistance.value = S.shadow.camera.near),
            (x.farDistance.value = S.shadow.camera.far);
    }
    return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function r4(n, e, t, i) {
    let r = {},
        s = {},
        o = [];
    const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function c(S, M) {
        const T = M.program;
        i.uniformBlockBinding(S, T);
    }
    function f(S, M) {
        let T = r[S.id];
        T === void 0 && (_(S), (T = d(S)), (r[S.id] = T), S.addEventListener('dispose', x));
        const P = M.program;
        i.updateUBOMapping(S, P);
        const A = e.render.frame;
        s[S.id] !== A && (p(S), (s[S.id] = A));
    }
    function d(S) {
        const M = h();
        S.__bindingPointIndex = M;
        const T = n.createBuffer(),
            P = S.__size,
            A = S.usage;
        return (
            n.bindBuffer(n.UNIFORM_BUFFER, T),
            n.bufferData(n.UNIFORM_BUFFER, P, A),
            n.bindBuffer(n.UNIFORM_BUFFER, null),
            n.bindBufferBase(n.UNIFORM_BUFFER, M, T),
            T
        );
    }
    function h() {
        for (let S = 0; S < a; S++) if (o.indexOf(S) === -1) return o.push(S), S;
        return (
            console.error(
                'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
            ),
            0
        );
    }
    function p(S) {
        const M = r[S.id],
            T = S.uniforms,
            P = S.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, M);
        for (let A = 0, R = T.length; A < R; A++) {
            const D = Array.isArray(T[A]) ? T[A] : [T[A]];
            for (let G = 0, b = D.length; G < b; G++) {
                const L = D[G];
                if (v(L, A, G, P) === !0) {
                    const ee = L.__offset,
                        ie = Array.isArray(L.value) ? L.value : [L.value];
                    let j = 0;
                    for (let oe = 0; oe < ie.length; oe++) {
                        const te = ie[oe],
                            ae = w(te);
                        typeof te == 'number' || typeof te == 'boolean'
                            ? ((L.__data[0] = te),
                              n.bufferSubData(n.UNIFORM_BUFFER, ee + j, L.__data))
                            : te.isMatrix3
                            ? ((L.__data[0] = te.elements[0]),
                              (L.__data[1] = te.elements[1]),
                              (L.__data[2] = te.elements[2]),
                              (L.__data[3] = 0),
                              (L.__data[4] = te.elements[3]),
                              (L.__data[5] = te.elements[4]),
                              (L.__data[6] = te.elements[5]),
                              (L.__data[7] = 0),
                              (L.__data[8] = te.elements[6]),
                              (L.__data[9] = te.elements[7]),
                              (L.__data[10] = te.elements[8]),
                              (L.__data[11] = 0))
                            : (te.toArray(L.__data, j),
                              (j += ae.storage / Float32Array.BYTES_PER_ELEMENT));
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, ee, L.__data);
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null);
    }
    function v(S, M, T, P) {
        const A = S.value,
            R = M + '_' + T;
        if (P[R] === void 0)
            return (
                typeof A == 'number' || typeof A == 'boolean' ? (P[R] = A) : (P[R] = A.clone()), !0
            );
        {
            const D = P[R];
            if (typeof A == 'number' || typeof A == 'boolean') {
                if (D !== A) return (P[R] = A), !0;
            } else if (D.equals(A) === !1) return D.copy(A), !0;
        }
        return !1;
    }
    function _(S) {
        const M = S.uniforms;
        let T = 0;
        const P = 16;
        for (let R = 0, D = M.length; R < D; R++) {
            const G = Array.isArray(M[R]) ? M[R] : [M[R]];
            for (let b = 0, L = G.length; b < L; b++) {
                const ee = G[b],
                    ie = Array.isArray(ee.value) ? ee.value : [ee.value];
                for (let j = 0, oe = ie.length; j < oe; j++) {
                    const te = ie[j],
                        ae = w(te),
                        N = T % P;
                    N !== 0 && P - N < ae.boundary && (T += P - N),
                        (ee.__data = new Float32Array(ae.storage / Float32Array.BYTES_PER_ELEMENT)),
                        (ee.__offset = T),
                        (T += ae.storage);
                }
            }
        }
        const A = T % P;
        return A > 0 && (T += P - A), (S.__size = T), (S.__cache = {}), this;
    }
    function w(S) {
        const M = { boundary: 0, storage: 0 };
        return (
            typeof S == 'number' || typeof S == 'boolean'
                ? ((M.boundary = 4), (M.storage = 4))
                : S.isVector2
                ? ((M.boundary = 8), (M.storage = 8))
                : S.isVector3 || S.isColor
                ? ((M.boundary = 16), (M.storage = 12))
                : S.isVector4
                ? ((M.boundary = 16), (M.storage = 16))
                : S.isMatrix3
                ? ((M.boundary = 48), (M.storage = 48))
                : S.isMatrix4
                ? ((M.boundary = 64), (M.storage = 64))
                : S.isTexture
                ? console.warn(
                      'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
                  )
                : console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', S),
            M
        );
    }
    function x(S) {
        const M = S.target;
        M.removeEventListener('dispose', x);
        const T = o.indexOf(M.__bindingPointIndex);
        o.splice(T, 1), n.deleteBuffer(r[M.id]), delete r[M.id], delete s[M.id];
    }
    function g() {
        for (const S in r) n.deleteBuffer(r[S]);
        (o = []), (r = {}), (s = {});
    }
    return { bind: c, update: f, dispose: g };
}
class kx {
    constructor(e = {}) {
        const {
            canvas: t = IC(),
            context: i = null,
            depth: r = !0,
            stencil: s = !0,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: c = !0,
            preserveDrawingBuffer: f = !1,
            powerPreference: d = 'default',
            failIfMajorPerformanceCaveat: h = !1,
        } = e;
        this.isWebGLRenderer = !0;
        let p;
        i !== null ? (p = i.getContextAttributes().alpha) : (p = o);
        const v = new Uint32Array(4),
            _ = new Int32Array(4);
        let w = null,
            x = null;
        const g = [],
            S = [];
        (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this._outputColorSpace = _r),
            (this._useLegacyLights = !1),
            (this.toneMapping = fs),
            (this.toneMappingExposure = 1);
        const M = this;
        let T = !1,
            P = 0,
            A = 0,
            R = null,
            D = -1,
            G = null;
        const b = new Wt(),
            L = new Wt();
        let ee = null;
        const ie = new je(0);
        let j = 0,
            oe = t.width,
            te = t.height,
            ae = 1,
            N = null,
            B = null;
        const H = new Wt(0, 0, oe, te),
            K = new Wt(0, 0, oe, te);
        let le = !1;
        const be = new Gf();
        let Q = !1,
            me = !1,
            Se = null;
        const ke = new ft(),
            et = new _e(),
            Xe = new k(),
            gt = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0,
            };
        function De() {
            return R === null ? ae : 1;
        }
        let V = i;
        function we(O, $) {
            for (let se = 0; se < O.length; se++) {
                const ue = O[se],
                    ne = t.getContext(ue, $);
                if (ne !== null) return ne;
            }
            return null;
        }
        try {
            const O = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: c,
                preserveDrawingBuffer: f,
                powerPreference: d,
                failIfMajorPerformanceCaveat: h,
            };
            if (
                ('setAttribute' in t && t.setAttribute('data-engine', `three.js r${Tm}`),
                t.addEventListener('webglcontextlost', Xt, !1),
                t.addEventListener('webglcontextrestored', q, !1),
                t.addEventListener('webglcontextcreationerror', Fe, !1),
                V === null)
            ) {
                const $ = ['webgl2', 'webgl', 'experimental-webgl'];
                if ((M.isWebGL1Renderer === !0 && $.shift(), (V = we($, O)), V === null))
                    throw we($)
                        ? new Error('Error creating WebGL context with your selected attributes.')
                        : new Error('Error creating WebGL context.');
            }
            typeof WebGLRenderingContext < 'u' &&
                V instanceof WebGLRenderingContext &&
                console.warn(
                    'THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.'
                ),
                V.getShaderPrecisionFormat === void 0 &&
                    (V.getShaderPrecisionFormat = function () {
                        return { rangeMin: 1, rangeMax: 1, precision: 1 };
                    });
        } catch (O) {
            throw (console.error('THREE.WebGLRenderer: ' + O.message), O);
        }
        let ve,
            Ee,
            ye,
            We,
            He,
            Ke,
            yt,
            F,
            I,
            ce,
            de,
            Me,
            xe,
            ut,
            at,
            Ae,
            Ie,
            ht,
            Pe,
            nn,
            wt,
            rt,
            tt,
            Qe;
        function Lt() {
            (ve = new pF(V)),
                (Ee = new lF(V, ve, e)),
                ve.init(Ee),
                (rt = new XC(V, ve, Ee)),
                (ye = new Zk(V, ve, Ee)),
                (We = new vF(V)),
                (He = new Fk()),
                (Ke = new Kk(V, ve, ye, He, Ee, rt, We)),
                (yt = new cF(M)),
                (F = new hF(M)),
                (I = new wD(V, Ee)),
                (tt = new oF(V, ve, I, Ee)),
                (ce = new mF(V, I, We, tt)),
                (de = new SF(V, ce, I, We)),
                (Pe = new xF(V, Ee, Ke)),
                (Ae = new uF(He)),
                (Me = new Ok(M, yt, F, ve, Ee, tt, Ae)),
                (xe = new i4(M, He)),
                (ut = new zk()),
                (at = new jk(ve, Ee)),
                (ht = new sF(M, yt, F, ye, de, p, c)),
                (Ie = new qk(M, de, Ee)),
                (Qe = new r4(V, We, Ee, ye)),
                (nn = new aF(V, ve, We, Ee)),
                (wt = new gF(V, ve, We, Ee)),
                (We.programs = Me.programs),
                (M.capabilities = Ee),
                (M.extensions = ve),
                (M.properties = He),
                (M.renderLists = ut),
                (M.shadowMap = Ie),
                (M.state = ye),
                (M.info = We);
        }
        Lt();
        const vt = new t4(M, V);
        (this.xr = vt),
            (this.getContext = function () {
                return V;
            }),
            (this.getContextAttributes = function () {
                return V.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
                const O = ve.get('WEBGL_lose_context');
                O && O.loseContext();
            }),
            (this.forceContextRestore = function () {
                const O = ve.get('WEBGL_lose_context');
                O && O.restoreContext();
            }),
            (this.getPixelRatio = function () {
                return ae;
            }),
            (this.setPixelRatio = function (O) {
                O !== void 0 && ((ae = O), this.setSize(oe, te, !1));
            }),
            (this.getSize = function (O) {
                return O.set(oe, te);
            }),
            (this.setSize = function (O, $, se = !0) {
                if (vt.isPresenting) {
                    console.warn(
                        "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                    );
                    return;
                }
                (oe = O),
                    (te = $),
                    (t.width = Math.floor(O * ae)),
                    (t.height = Math.floor($ * ae)),
                    se === !0 && ((t.style.width = O + 'px'), (t.style.height = $ + 'px')),
                    this.setViewport(0, 0, O, $);
            }),
            (this.getDrawingBufferSize = function (O) {
                return O.set(oe * ae, te * ae).floor();
            }),
            (this.setDrawingBufferSize = function (O, $, se) {
                (oe = O),
                    (te = $),
                    (ae = se),
                    (t.width = Math.floor(O * se)),
                    (t.height = Math.floor($ * se)),
                    this.setViewport(0, 0, O, $);
            }),
            (this.getCurrentViewport = function (O) {
                return O.copy(b);
            }),
            (this.getViewport = function (O) {
                return O.copy(H);
            }),
            (this.setViewport = function (O, $, se, ue) {
                O.isVector4 ? H.set(O.x, O.y, O.z, O.w) : H.set(O, $, se, ue),
                    ye.viewport(b.copy(H).multiplyScalar(ae).round());
            }),
            (this.getScissor = function (O) {
                return O.copy(K);
            }),
            (this.setScissor = function (O, $, se, ue) {
                O.isVector4 ? K.set(O.x, O.y, O.z, O.w) : K.set(O, $, se, ue),
                    ye.scissor(L.copy(K).multiplyScalar(ae).round());
            }),
            (this.getScissorTest = function () {
                return le;
            }),
            (this.setScissorTest = function (O) {
                ye.setScissorTest((le = O));
            }),
            (this.setOpaqueSort = function (O) {
                N = O;
            }),
            (this.setTransparentSort = function (O) {
                B = O;
            }),
            (this.getClearColor = function (O) {
                return O.copy(ht.getClearColor());
            }),
            (this.setClearColor = function () {
                ht.setClearColor.apply(ht, arguments);
            }),
            (this.getClearAlpha = function () {
                return ht.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
                ht.setClearAlpha.apply(ht, arguments);
            }),
            (this.clear = function (O = !0, $ = !0, se = !0) {
                let ue = 0;
                if (O) {
                    let ne = !1;
                    if (R !== null) {
                        const ze = R.texture.format;
                        ne = ze === Tx || ze === Ex || ze === wx;
                    }
                    if (ne) {
                        const ze = R.texture.type,
                            Re =
                                ze === ds ||
                                ze === Ds ||
                                ze === bm ||
                                ze === Io ||
                                ze === xx ||
                                ze === Sx,
                            Ue = ht.getClearColor(),
                            Je = ht.getClearAlpha(),
                            ct = Ue.r,
                            mt = Ue.g,
                            xt = Ue.b;
                        Re
                            ? ((v[0] = ct),
                              (v[1] = mt),
                              (v[2] = xt),
                              (v[3] = Je),
                              V.clearBufferuiv(V.COLOR, 0, v))
                            : ((_[0] = ct),
                              (_[1] = mt),
                              (_[2] = xt),
                              (_[3] = Je),
                              V.clearBufferiv(V.COLOR, 0, _));
                    } else ue |= V.COLOR_BUFFER_BIT;
                }
                $ && (ue |= V.DEPTH_BUFFER_BIT),
                    se &&
                        ((ue |= V.STENCIL_BUFFER_BIT),
                        this.state.buffers.stencil.setMask(4294967295)),
                    V.clear(ue);
            }),
            (this.clearColor = function () {
                this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
                this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
                this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
                t.removeEventListener('webglcontextlost', Xt, !1),
                    t.removeEventListener('webglcontextrestored', q, !1),
                    t.removeEventListener('webglcontextcreationerror', Fe, !1),
                    ut.dispose(),
                    at.dispose(),
                    He.dispose(),
                    yt.dispose(),
                    F.dispose(),
                    de.dispose(),
                    tt.dispose(),
                    Qe.dispose(),
                    Me.dispose(),
                    vt.dispose(),
                    vt.removeEventListener('sessionstart', $e),
                    vt.removeEventListener('sessionend', Oe),
                    Se && (Se.dispose(), (Se = null)),
                    Ge.stop();
            });
        function Xt(O) {
            O.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (T = !0);
        }
        function q() {
            console.log('THREE.WebGLRenderer: Context Restored.'), (T = !1);
            const O = We.autoReset,
                $ = Ie.enabled,
                se = Ie.autoUpdate,
                ue = Ie.needsUpdate,
                ne = Ie.type;
            Lt(),
                (We.autoReset = O),
                (Ie.enabled = $),
                (Ie.autoUpdate = se),
                (Ie.needsUpdate = ue),
                (Ie.type = ne);
        }
        function Fe(O) {
            console.error(
                'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
                O.statusMessage
            );
        }
        function U(O) {
            const $ = O.target;
            $.removeEventListener('dispose', U), W($);
        }
        function W(O) {
            Y(O), He.remove(O);
        }
        function Y(O) {
            const $ = He.get(O).programs;
            $ !== void 0 &&
                ($.forEach(function (se) {
                    Me.releaseProgram(se);
                }),
                O.isShaderMaterial && Me.releaseShaderCache(O));
        }
        this.renderBufferDirect = function (O, $, se, ue, ne, ze) {
            $ === null && ($ = gt);
            const Re = ne.isMesh && ne.matrixWorld.determinant() < 0,
                Ue = Xo(O, $, se, ue, ne);
            ye.setMaterial(ue, Re);
            let Je = se.index,
                ct = 1;
            if (ue.wireframe === !0) {
                if (((Je = ce.getWireframeAttribute(se)), Je === void 0)) return;
                ct = 2;
            }
            const mt = se.drawRange,
                xt = se.attributes.position;
            let un = mt.start * ct,
                Jn = (mt.start + mt.count) * ct;
            ze !== null &&
                ((un = Math.max(un, ze.start * ct)),
                (Jn = Math.min(Jn, (ze.start + ze.count) * ct))),
                Je !== null
                    ? ((un = Math.max(un, 0)), (Jn = Math.min(Jn, Je.count)))
                    : xt != null && ((un = Math.max(un, 0)), (Jn = Math.min(Jn, xt.count)));
            const $t = Jn - un;
            if ($t < 0 || $t === 1 / 0) return;
            tt.setup(ne, ue, Ue, se, Je);
            let Vn,
                dt = nn;
            if ((Je !== null && ((Vn = I.get(Je)), (dt = wt), dt.setIndex(Vn)), ne.isMesh))
                ue.wireframe === !0
                    ? (ye.setLineWidth(ue.wireframeLinewidth * De()), dt.setMode(V.LINES))
                    : dt.setMode(V.TRIANGLES);
            else if (ne.isLine) {
                let Ye = ue.linewidth;
                Ye === void 0 && (Ye = 1),
                    ye.setLineWidth(Ye * De()),
                    ne.isLineSegments
                        ? dt.setMode(V.LINES)
                        : ne.isLineLoop
                        ? dt.setMode(V.LINE_LOOP)
                        : dt.setMode(V.LINE_STRIP);
            } else ne.isPoints ? dt.setMode(V.POINTS) : ne.isSprite && dt.setMode(V.TRIANGLES);
            if (ne.isBatchedMesh)
                dt.renderMultiDraw(ne._multiDrawStarts, ne._multiDrawCounts, ne._multiDrawCount);
            else if (ne.isInstancedMesh) dt.renderInstances(un, $t, ne.count);
            else if (se.isInstancedBufferGeometry) {
                const Ye = se._maxInstanceCount !== void 0 ? se._maxInstanceCount : 1 / 0,
                    or = Math.min(se.instanceCount, Ye);
                dt.renderInstances(un, $t, or);
            } else dt.render(un, $t);
        };
        function ge(O, $, se) {
            O.transparent === !0 && O.side === os && O.forceSinglePass === !1
                ? ((O.side = Ai),
                  (O.needsUpdate = !0),
                  Pn(O, $, se),
                  (O.side = Gs),
                  (O.needsUpdate = !0),
                  Pn(O, $, se),
                  (O.side = os))
                : Pn(O, $, se);
        }
        (this.compile = function (O, $, se = null) {
            se === null && (se = O),
                (x = at.get(se)),
                x.init(),
                S.push(x),
                se.traverseVisible(function (ne) {
                    ne.isLight &&
                        ne.layers.test($.layers) &&
                        (x.pushLight(ne), ne.castShadow && x.pushShadow(ne));
                }),
                O !== se &&
                    O.traverseVisible(function (ne) {
                        ne.isLight &&
                            ne.layers.test($.layers) &&
                            (x.pushLight(ne), ne.castShadow && x.pushShadow(ne));
                    }),
                x.setupLights(M._useLegacyLights);
            const ue = new Set();
            return (
                O.traverse(function (ne) {
                    const ze = ne.material;
                    if (ze)
                        if (Array.isArray(ze))
                            for (let Re = 0; Re < ze.length; Re++) {
                                const Ue = ze[Re];
                                ge(Ue, se, ne), ue.add(Ue);
                            }
                        else ge(ze, se, ne), ue.add(ze);
                }),
                S.pop(),
                (x = null),
                ue
            );
        }),
            (this.compileAsync = function (O, $, se = null) {
                const ue = this.compile(O, $, se);
                return new Promise((ne) => {
                    function ze() {
                        if (
                            (ue.forEach(function (Re) {
                                He.get(Re).currentProgram.isReady() && ue.delete(Re);
                            }),
                            ue.size === 0)
                        ) {
                            ne(O);
                            return;
                        }
                        setTimeout(ze, 10);
                    }
                    ve.get('KHR_parallel_shader_compile') !== null ? ze() : setTimeout(ze, 10);
                });
            });
        let Ce = null;
        function it(O) {
            Ce && Ce(O);
        }
        function $e() {
            Ge.stop();
        }
        function Oe() {
            Ge.start();
        }
        const Ge = new BC();
        Ge.setAnimationLoop(it),
            typeof self < 'u' && Ge.setContext(self),
            (this.setAnimationLoop = function (O) {
                (Ce = O), vt.setAnimationLoop(O), O === null ? Ge.stop() : Ge.start();
            }),
            vt.addEventListener('sessionstart', $e),
            vt.addEventListener('sessionend', Oe),
            (this.render = function (O, $) {
                if ($ !== void 0 && $.isCamera !== !0) {
                    console.error(
                        'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
                    );
                    return;
                }
                if (T === !0) return;
                O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(),
                    $.parent === null && $.matrixWorldAutoUpdate === !0 && $.updateMatrixWorld(),
                    vt.enabled === !0 &&
                        vt.isPresenting === !0 &&
                        (vt.cameraAutoUpdate === !0 && vt.updateCamera($), ($ = vt.getCamera())),
                    O.isScene === !0 && O.onBeforeRender(M, O, $, R),
                    (x = at.get(O, S.length)),
                    x.init(),
                    S.push(x),
                    ke.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
                    be.setFromProjectionMatrix(ke),
                    (me = this.localClippingEnabled),
                    (Q = Ae.init(this.clippingPlanes, me)),
                    (w = ut.get(O, g.length)),
                    w.init(),
                    g.push(w),
                    pt(O, $, 0, M.sortObjects),
                    w.finish(),
                    M.sortObjects === !0 && w.sort(N, B),
                    this.info.render.frame++,
                    Q === !0 && Ae.beginShadows();
                const se = x.state.shadowsArray;
                if (
                    (Ie.render(se, O, $),
                    Q === !0 && Ae.endShadows(),
                    this.info.autoReset === !0 && this.info.reset(),
                    (vt.enabled === !1 || vt.isPresenting === !1 || vt.hasDepthSensing() === !1) &&
                        ht.render(w, O),
                    x.setupLights(M._useLegacyLights),
                    $.isArrayCamera)
                ) {
                    const ue = $.cameras;
                    for (let ne = 0, ze = ue.length; ne < ze; ne++) {
                        const Re = ue[ne];
                        rn(w, O, Re, Re.viewport);
                    }
                } else rn(w, O, $);
                R !== null && (Ke.updateMultisampleRenderTarget(R), Ke.updateRenderTargetMipmap(R)),
                    O.isScene === !0 && O.onAfterRender(M, O, $),
                    tt.resetDefaultState(),
                    (D = -1),
                    (G = null),
                    S.pop(),
                    S.length > 0 ? (x = S[S.length - 1]) : (x = null),
                    g.pop(),
                    g.length > 0 ? (w = g[g.length - 1]) : (w = null);
            });
        function pt(O, $, se, ue) {
            if (O.visible === !1) return;
            if (O.layers.test($.layers)) {
                if (O.isGroup) se = O.renderOrder;
                else if (O.isLOD) O.autoUpdate === !0 && O.update($);
                else if (O.isLight) x.pushLight(O), O.castShadow && x.pushShadow(O);
                else if (O.isSprite) {
                    if (!O.frustumCulled || be.intersectsSprite(O)) {
                        ue && Xe.setFromMatrixPosition(O.matrixWorld).applyMatrix4(ke);
                        const Re = de.update(O),
                            Ue = O.material;
                        Ue.visible && w.push(O, Re, Ue, se, Xe.z, null);
                    }
                } else if (
                    (O.isMesh || O.isLine || O.isPoints) &&
                    (!O.frustumCulled || be.intersectsObject(O))
                ) {
                    const Re = de.update(O),
                        Ue = O.material;
                    if (
                        (ue &&
                            (O.boundingSphere !== void 0
                                ? (O.boundingSphere === null && O.computeBoundingSphere(),
                                  Xe.copy(O.boundingSphere.center))
                                : (Re.boundingSphere === null && Re.computeBoundingSphere(),
                                  Xe.copy(Re.boundingSphere.center)),
                            Xe.applyMatrix4(O.matrixWorld).applyMatrix4(ke)),
                        Array.isArray(Ue))
                    ) {
                        const Je = Re.groups;
                        for (let ct = 0, mt = Je.length; ct < mt; ct++) {
                            const xt = Je[ct],
                                un = Ue[xt.materialIndex];
                            un && un.visible && w.push(O, Re, un, se, Xe.z, xt);
                        }
                    } else Ue.visible && w.push(O, Re, Ue, se, Xe.z, null);
                }
            }
            const ze = O.children;
            for (let Re = 0, Ue = ze.length; Re < Ue; Re++) pt(ze[Re], $, se, ue);
        }
        function rn(O, $, se, ue) {
            const ne = O.opaque,
                ze = O.transmissive,
                Re = O.transparent;
            x.setupLightsView(se),
                Q === !0 && Ae.setGlobalState(M.clippingPlanes, se),
                ze.length > 0 && _t(ne, ze, $, se),
                ue && ye.viewport(b.copy(ue)),
                ne.length > 0 && Dt(ne, $, se),
                ze.length > 0 && Dt(ze, $, se),
                Re.length > 0 && Dt(Re, $, se),
                ye.buffers.depth.setTest(!0),
                ye.buffers.depth.setMask(!0),
                ye.buffers.color.setMask(!0),
                ye.setPolygonOffset(!1);
        }
        function _t(O, $, se, ue) {
            if ((se.isScene === !0 ? se.overrideMaterial : null) !== null) return;
            const ze = Ee.isWebGL2;
            Se === null &&
                (Se = new Vr(1, 1, {
                    generateMipmaps: !0,
                    type: ve.has('EXT_color_buffer_half_float') ? _u : ds,
                    minFilter: as,
                    samples: ze ? 4 : 0,
                })),
                M.getDrawingBufferSize(et),
                ze ? Se.setSize(et.x, et.y) : Se.setSize(tm(et.x), tm(et.y));
            const Re = M.getRenderTarget();
            M.setRenderTarget(Se),
                M.getClearColor(ie),
                (j = M.getClearAlpha()),
                j < 1 && M.setClearColor(16777215, 0.5),
                M.clear();
            const Ue = M.toneMapping;
            (M.toneMapping = fs),
                Dt(O, se, ue),
                Ke.updateMultisampleRenderTarget(Se),
                Ke.updateRenderTargetMipmap(Se);
            let Je = !1;
            for (let ct = 0, mt = $.length; ct < mt; ct++) {
                const xt = $[ct],
                    un = xt.object,
                    Jn = xt.geometry,
                    $t = xt.material,
                    Vn = xt.group;
                if ($t.side === os && un.layers.test(ue.layers)) {
                    const dt = $t.side;
                    ($t.side = Ai),
                        ($t.needsUpdate = !0),
                        Kt(un, se, ue, Jn, $t, Vn),
                        ($t.side = dt),
                        ($t.needsUpdate = !0),
                        (Je = !0);
                }
            }
            Je === !0 && (Ke.updateMultisampleRenderTarget(Se), Ke.updateRenderTargetMipmap(Se)),
                M.setRenderTarget(Re),
                M.setClearColor(ie, j),
                (M.toneMapping = Ue);
        }
        function Dt(O, $, se) {
            const ue = $.isScene === !0 ? $.overrideMaterial : null;
            for (let ne = 0, ze = O.length; ne < ze; ne++) {
                const Re = O[ne],
                    Ue = Re.object,
                    Je = Re.geometry,
                    ct = ue === null ? Re.material : ue,
                    mt = Re.group;
                Ue.layers.test(se.layers) && Kt(Ue, $, se, Je, ct, mt);
            }
        }
        function Kt(O, $, se, ue, ne, ze) {
            O.onBeforeRender(M, $, se, ue, ne, ze),
                O.modelViewMatrix.multiplyMatrices(se.matrixWorldInverse, O.matrixWorld),
                O.normalMatrix.getNormalMatrix(O.modelViewMatrix),
                ne.onBeforeRender(M, $, se, ue, O, ze),
                ne.transparent === !0 && ne.side === os && ne.forceSinglePass === !1
                    ? ((ne.side = Ai),
                      (ne.needsUpdate = !0),
                      M.renderBufferDirect(se, $, ue, ne, O, ze),
                      (ne.side = Gs),
                      (ne.needsUpdate = !0),
                      M.renderBufferDirect(se, $, ue, ne, O, ze),
                      (ne.side = os))
                    : M.renderBufferDirect(se, $, ue, ne, O, ze),
                O.onAfterRender(M, $, se, ue, ne, ze);
        }
        function Pn(O, $, se) {
            $.isScene !== !0 && ($ = gt);
            const ue = He.get(O),
                ne = x.state.lights,
                ze = x.state.shadowsArray,
                Re = ne.state.version,
                Ue = Me.getParameters(O, ne.state, ze, $, se),
                Je = Me.getProgramCacheKey(Ue);
            let ct = ue.programs;
            (ue.environment = O.isMeshStandardMaterial ? $.environment : null),
                (ue.fog = $.fog),
                (ue.envMap = (O.isMeshStandardMaterial ? F : yt).get(O.envMap || ue.environment)),
                (ue.envMapRotation =
                    ue.environment !== null && O.envMap === null
                        ? $.environmentRotation
                        : O.envMapRotation),
                ct === void 0 &&
                    (O.addEventListener('dispose', U), (ct = new Map()), (ue.programs = ct));
            let mt = ct.get(Je);
            if (mt !== void 0) {
                if (ue.currentProgram === mt && ue.lightsStateVersion === Re) return Ar(O, Ue), mt;
            } else
                (Ue.uniforms = Me.getUniforms(O)),
                    O.onBuild(se, Ue, M),
                    O.onBeforeCompile(Ue, M),
                    (mt = Me.acquireProgram(Ue, Je)),
                    ct.set(Je, mt),
                    (ue.uniforms = Ue.uniforms);
            const xt = ue.uniforms;
            return (
                ((!O.isShaderMaterial && !O.isRawShaderMaterial) || O.clipping === !0) &&
                    (xt.clippingPlanes = Ae.uniform),
                Ar(O, Ue),
                (ue.needsLights = sr(O)),
                (ue.lightsStateVersion = Re),
                ue.needsLights &&
                    ((xt.ambientLightColor.value = ne.state.ambient),
                    (xt.lightProbe.value = ne.state.probe),
                    (xt.directionalLights.value = ne.state.directional),
                    (xt.directionalLightShadows.value = ne.state.directionalShadow),
                    (xt.spotLights.value = ne.state.spot),
                    (xt.spotLightShadows.value = ne.state.spotShadow),
                    (xt.rectAreaLights.value = ne.state.rectArea),
                    (xt.ltc_1.value = ne.state.rectAreaLTC1),
                    (xt.ltc_2.value = ne.state.rectAreaLTC2),
                    (xt.pointLights.value = ne.state.point),
                    (xt.pointLightShadows.value = ne.state.pointShadow),
                    (xt.hemisphereLights.value = ne.state.hemi),
                    (xt.directionalShadowMap.value = ne.state.directionalShadowMap),
                    (xt.directionalShadowMatrix.value = ne.state.directionalShadowMatrix),
                    (xt.spotShadowMap.value = ne.state.spotShadowMap),
                    (xt.spotLightMatrix.value = ne.state.spotLightMatrix),
                    (xt.spotLightMap.value = ne.state.spotLightMap),
                    (xt.pointShadowMap.value = ne.state.pointShadowMap),
                    (xt.pointShadowMatrix.value = ne.state.pointShadowMatrix)),
                (ue.currentProgram = mt),
                (ue.uniformsList = null),
                mt
            );
        }
        function ln(O) {
            if (O.uniformsList === null) {
                const $ = O.currentProgram.getUniforms();
                O.uniformsList = wp.seqWithValue($.seq, O.uniforms);
            }
            return O.uniformsList;
        }
        function Ar(O, $) {
            const se = He.get(O);
            (se.outputColorSpace = $.outputColorSpace),
                (se.batching = $.batching),
                (se.instancing = $.instancing),
                (se.instancingColor = $.instancingColor),
                (se.instancingMorph = $.instancingMorph),
                (se.skinning = $.skinning),
                (se.morphTargets = $.morphTargets),
                (se.morphNormals = $.morphNormals),
                (se.morphColors = $.morphColors),
                (se.morphTargetsCount = $.morphTargetsCount),
                (se.numClippingPlanes = $.numClippingPlanes),
                (se.numIntersection = $.numClipIntersection),
                (se.vertexAlphas = $.vertexAlphas),
                (se.vertexTangents = $.vertexTangents),
                (se.toneMapping = $.toneMapping);
        }
        function Xo(O, $, se, ue, ne) {
            $.isScene !== !0 && ($ = gt), Ke.resetTextureUnits();
            const ze = $.fog,
                Re = ue.isMeshStandardMaterial ? $.environment : null,
                Ue =
                    R === null
                        ? M.outputColorSpace
                        : R.isXRRenderTarget === !0
                        ? R.texture.colorSpace
                        : Ys,
                Je = (ue.isMeshStandardMaterial ? F : yt).get(ue.envMap || Re),
                ct =
                    ue.vertexColors === !0 &&
                    !!se.attributes.color &&
                    se.attributes.color.itemSize === 4,
                mt = !!se.attributes.tangent && (!!ue.normalMap || ue.anisotropy > 0),
                xt = !!se.morphAttributes.position,
                un = !!se.morphAttributes.normal,
                Jn = !!se.morphAttributes.color;
            let $t = fs;
            ue.toneMapped && (R === null || R.isXRRenderTarget === !0) && ($t = M.toneMapping);
            const Vn =
                    se.morphAttributes.position ||
                    se.morphAttributes.normal ||
                    se.morphAttributes.color,
                dt = Vn !== void 0 ? Vn.length : 0,
                Ye = He.get(ue),
                or = x.state.lights;
            if (Q === !0 && (me === !0 || O !== G)) {
                const Qn = O === G && ue.id === D;
                Ae.setState(ue, O, Qn);
            }
            let At = !1;
            ue.version === Ye.__version
                ? ((Ye.needsLights && Ye.lightsStateVersion !== or.state.version) ||
                      Ye.outputColorSpace !== Ue ||
                      (ne.isBatchedMesh && Ye.batching === !1) ||
                      (!ne.isBatchedMesh && Ye.batching === !0) ||
                      (ne.isInstancedMesh && Ye.instancing === !1) ||
                      (!ne.isInstancedMesh && Ye.instancing === !0) ||
                      (ne.isSkinnedMesh && Ye.skinning === !1) ||
                      (!ne.isSkinnedMesh && Ye.skinning === !0) ||
                      (ne.isInstancedMesh &&
                          Ye.instancingColor === !0 &&
                          ne.instanceColor === null) ||
                      (ne.isInstancedMesh &&
                          Ye.instancingColor === !1 &&
                          ne.instanceColor !== null) ||
                      (ne.isInstancedMesh &&
                          Ye.instancingMorph === !0 &&
                          ne.morphTexture === null) ||
                      (ne.isInstancedMesh &&
                          Ye.instancingMorph === !1 &&
                          ne.morphTexture !== null) ||
                      Ye.envMap !== Je ||
                      (ue.fog === !0 && Ye.fog !== ze) ||
                      (Ye.numClippingPlanes !== void 0 &&
                          (Ye.numClippingPlanes !== Ae.numPlanes ||
                              Ye.numIntersection !== Ae.numIntersection)) ||
                      Ye.vertexAlphas !== ct ||
                      Ye.vertexTangents !== mt ||
                      Ye.morphTargets !== xt ||
                      Ye.morphNormals !== un ||
                      Ye.morphColors !== Jn ||
                      Ye.toneMapping !== $t ||
                      (Ee.isWebGL2 === !0 && Ye.morphTargetsCount !== dt)) &&
                  (At = !0)
                : ((At = !0), (Ye.__version = ue.version));
            let vn = Ye.currentProgram;
            At === !0 && (vn = Pn(ue, $, ne));
            let qr = !1,
                ar = !1,
                Gn = !1;
            const En = vn.getUniforms(),
                Zr = Ye.uniforms;
            if (
                (ye.useProgram(vn.program) && ((qr = !0), (ar = !0), (Gn = !0)),
                ue.id !== D && ((D = ue.id), (ar = !0)),
                qr || G !== O)
            ) {
                En.setValue(V, 'projectionMatrix', O.projectionMatrix),
                    En.setValue(V, 'viewMatrix', O.matrixWorldInverse);
                const Qn = En.map.cameraPosition;
                Qn !== void 0 && Qn.setValue(V, Xe.setFromMatrixPosition(O.matrixWorld)),
                    Ee.logarithmicDepthBuffer &&
                        En.setValue(V, 'logDepthBufFC', 2 / (Math.log(O.far + 1) / Math.LN2)),
                    (ue.isMeshPhongMaterial ||
                        ue.isMeshToonMaterial ||
                        ue.isMeshLambertMaterial ||
                        ue.isMeshBasicMaterial ||
                        ue.isMeshStandardMaterial ||
                        ue.isShaderMaterial) &&
                        En.setValue(V, 'isOrthographic', O.isOrthographicCamera === !0),
                    G !== O && ((G = O), (ar = !0), (Gn = !0));
            }
            if (ne.isSkinnedMesh) {
                En.setOptional(V, ne, 'bindMatrix'), En.setOptional(V, ne, 'bindMatrixInverse');
                const Qn = ne.skeleton;
                Qn &&
                    (Ee.floatVertexTextures
                        ? (Qn.boneTexture === null && Qn.computeBoneTexture(),
                          En.setValue(V, 'boneTexture', Qn.boneTexture, Ke))
                        : console.warn(
                              'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.'
                          ));
            }
            ne.isBatchedMesh &&
                (En.setOptional(V, ne, 'batchingTexture'),
                En.setValue(V, 'batchingTexture', ne._matricesTexture, Ke));
            const Ja = se.morphAttributes;
            if (
                ((Ja.position !== void 0 ||
                    Ja.normal !== void 0 ||
                    (Ja.color !== void 0 && Ee.isWebGL2 === !0)) &&
                    Pe.update(ne, se, vn),
                (ar || Ye.receiveShadow !== ne.receiveShadow) &&
                    ((Ye.receiveShadow = ne.receiveShadow),
                    En.setValue(V, 'receiveShadow', ne.receiveShadow)),
                ue.isMeshGouraudMaterial &&
                    ue.envMap !== null &&
                    ((Zr.envMap.value = Je),
                    (Zr.flipEnvMap.value =
                        Je.isCubeTexture && Je.isRenderTargetTexture === !1 ? -1 : 1)),
                ar &&
                    (En.setValue(V, 'toneMappingExposure', M.toneMappingExposure),
                    Ye.needsLights && Yr(Zr, Gn),
                    ze && ue.fog === !0 && xe.refreshFogUniforms(Zr, ze),
                    xe.refreshMaterialUniforms(Zr, ue, ae, te, Se),
                    wp.upload(V, ln(Ye), Zr, Ke)),
                ue.isShaderMaterial &&
                    ue.uniformsNeedUpdate === !0 &&
                    (wp.upload(V, ln(Ye), Zr, Ke), (ue.uniformsNeedUpdate = !1)),
                ue.isSpriteMaterial && En.setValue(V, 'center', ne.center),
                En.setValue(V, 'modelViewMatrix', ne.modelViewMatrix),
                En.setValue(V, 'normalMatrix', ne.normalMatrix),
                En.setValue(V, 'modelMatrix', ne.matrixWorld),
                ue.isShaderMaterial || ue.isRawShaderMaterial)
            ) {
                const Qn = ue.uniformsGroups;
                for (let Qa = 0, Vi = Qn.length; Qa < Vi; Qa++)
                    if (Ee.isWebGL2) {
                        const Jf = Qn[Qa];
                        Qe.update(Jf, vn), Qe.bind(Jf, vn);
                    } else
                        console.warn(
                            'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.'
                        );
            }
            return vn;
        }
        function Yr(O, $) {
            (O.ambientLightColor.needsUpdate = $),
                (O.lightProbe.needsUpdate = $),
                (O.directionalLights.needsUpdate = $),
                (O.directionalLightShadows.needsUpdate = $),
                (O.pointLights.needsUpdate = $),
                (O.pointLightShadows.needsUpdate = $),
                (O.spotLights.needsUpdate = $),
                (O.spotLightShadows.needsUpdate = $),
                (O.rectAreaLights.needsUpdate = $),
                (O.hemisphereLights.needsUpdate = $);
        }
        function sr(O) {
            return (
                O.isMeshLambertMaterial ||
                O.isMeshToonMaterial ||
                O.isMeshPhongMaterial ||
                O.isMeshStandardMaterial ||
                O.isShadowMaterial ||
                (O.isShaderMaterial && O.lights === !0)
            );
        }
        (this.getActiveCubeFace = function () {
            return P;
        }),
            (this.getActiveMipmapLevel = function () {
                return A;
            }),
            (this.getRenderTarget = function () {
                return R;
            }),
            (this.setRenderTargetTextures = function (O, $, se) {
                (He.get(O.texture).__webglTexture = $),
                    (He.get(O.depthTexture).__webglTexture = se);
                const ue = He.get(O);
                (ue.__hasExternalTextures = !0),
                    (ue.__autoAllocateDepthBuffer = se === void 0),
                    ue.__autoAllocateDepthBuffer ||
                        (ve.has('WEBGL_multisampled_render_to_texture') === !0 &&
                            (console.warn(
                                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
                            ),
                            (ue.__useRenderToTexture = !1)));
            }),
            (this.setRenderTargetFramebuffer = function (O, $) {
                const se = He.get(O);
                (se.__webglFramebuffer = $), (se.__useDefaultFramebuffer = $ === void 0);
            }),
            (this.setRenderTarget = function (O, $ = 0, se = 0) {
                (R = O), (P = $), (A = se);
                let ue = !0,
                    ne = null,
                    ze = !1,
                    Re = !1;
                if (O) {
                    const Je = He.get(O);
                    Je.__useDefaultFramebuffer !== void 0
                        ? (ye.bindFramebuffer(V.FRAMEBUFFER, null), (ue = !1))
                        : Je.__webglFramebuffer === void 0
                        ? Ke.setupRenderTarget(O)
                        : Je.__hasExternalTextures &&
                          Ke.rebindTextures(
                              O,
                              He.get(O.texture).__webglTexture,
                              He.get(O.depthTexture).__webglTexture
                          );
                    const ct = O.texture;
                    (ct.isData3DTexture || ct.isDataArrayTexture || ct.isCompressedArrayTexture) &&
                        (Re = !0);
                    const mt = He.get(O).__webglFramebuffer;
                    O.isWebGLCubeRenderTarget
                        ? (Array.isArray(mt[$]) ? (ne = mt[$][se]) : (ne = mt[$]), (ze = !0))
                        : Ee.isWebGL2 && O.samples > 0 && Ke.useMultisampledRTT(O) === !1
                        ? (ne = He.get(O).__webglMultisampledFramebuffer)
                        : Array.isArray(mt)
                        ? (ne = mt[se])
                        : (ne = mt),
                        b.copy(O.viewport),
                        L.copy(O.scissor),
                        (ee = O.scissorTest);
                } else
                    b.copy(H).multiplyScalar(ae).floor(),
                        L.copy(K).multiplyScalar(ae).floor(),
                        (ee = le);
                if (
                    (ye.bindFramebuffer(V.FRAMEBUFFER, ne) &&
                        Ee.drawBuffers &&
                        ue &&
                        ye.drawBuffers(O, ne),
                    ye.viewport(b),
                    ye.scissor(L),
                    ye.setScissorTest(ee),
                    ze)
                ) {
                    const Je = He.get(O.texture);
                    V.framebufferTexture2D(
                        V.FRAMEBUFFER,
                        V.COLOR_ATTACHMENT0,
                        V.TEXTURE_CUBE_MAP_POSITIVE_X + $,
                        Je.__webglTexture,
                        se
                    );
                } else if (Re) {
                    const Je = He.get(O.texture),
                        ct = $ || 0;
                    V.framebufferTextureLayer(
                        V.FRAMEBUFFER,
                        V.COLOR_ATTACHMENT0,
                        Je.__webglTexture,
                        se || 0,
                        ct
                    );
                }
                D = -1;
            }),
            (this.readRenderTargetPixels = function (O, $, se, ue, ne, ze, Re) {
                if (!(O && O.isWebGLRenderTarget)) {
                    console.error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
                    );
                    return;
                }
                let Ue = He.get(O).__webglFramebuffer;
                if ((O.isWebGLCubeRenderTarget && Re !== void 0 && (Ue = Ue[Re]), Ue)) {
                    ye.bindFramebuffer(V.FRAMEBUFFER, Ue);
                    try {
                        const Je = O.texture,
                            ct = Je.format,
                            mt = Je.type;
                        if (
                            ct !== wi &&
                            rt.convert(ct) !== V.getParameter(V.IMPLEMENTATION_COLOR_READ_FORMAT)
                        ) {
                            console.error(
                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                            );
                            return;
                        }
                        const xt =
                            mt === _u &&
                            (ve.has('EXT_color_buffer_half_float') ||
                                (Ee.isWebGL2 && ve.has('EXT_color_buffer_float')));
                        if (
                            mt !== ds &&
                            rt.convert(mt) !== V.getParameter(V.IMPLEMENTATION_COLOR_READ_TYPE) &&
                            !(
                                mt === Ki &&
                                (Ee.isWebGL2 ||
                                    ve.has('OES_texture_float') ||
                                    ve.has('WEBGL_color_buffer_float'))
                            ) &&
                            !xt
                        ) {
                            console.error(
                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                            );
                            return;
                        }
                        $ >= 0 &&
                            $ <= O.width - ue &&
                            se >= 0 &&
                            se <= O.height - ne &&
                            V.readPixels($, se, ue, ne, rt.convert(ct), rt.convert(mt), ze);
                    } finally {
                        const Je = R !== null ? He.get(R).__webglFramebuffer : null;
                        ye.bindFramebuffer(V.FRAMEBUFFER, Je);
                    }
                }
            }),
            (this.copyFramebufferToTexture = function (O, $, se = 0) {
                const ue = Math.pow(2, -se),
                    ne = Math.floor($.image.width * ue),
                    ze = Math.floor($.image.height * ue);
                Ke.setTexture2D($, 0),
                    V.copyTexSubImage2D(V.TEXTURE_2D, se, 0, 0, O.x, O.y, ne, ze),
                    ye.unbindTexture();
            }),
            (this.copyTextureToTexture = function (O, $, se, ue = 0) {
                const ne = $.image.width,
                    ze = $.image.height,
                    Re = rt.convert(se.format),
                    Ue = rt.convert(se.type);
                Ke.setTexture2D(se, 0),
                    V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, se.flipY),
                    V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, se.premultiplyAlpha),
                    V.pixelStorei(V.UNPACK_ALIGNMENT, se.unpackAlignment),
                    $.isDataTexture
                        ? V.texSubImage2D(V.TEXTURE_2D, ue, O.x, O.y, ne, ze, Re, Ue, $.image.data)
                        : $.isCompressedTexture
                        ? V.compressedTexSubImage2D(
                              V.TEXTURE_2D,
                              ue,
                              O.x,
                              O.y,
                              $.mipmaps[0].width,
                              $.mipmaps[0].height,
                              Re,
                              $.mipmaps[0].data
                          )
                        : V.texSubImage2D(V.TEXTURE_2D, ue, O.x, O.y, Re, Ue, $.image),
                    ue === 0 && se.generateMipmaps && V.generateMipmap(V.TEXTURE_2D),
                    ye.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (O, $, se, ue, ne = 0) {
                if (M.isWebGL1Renderer) {
                    console.warn(
                        'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
                    );
                    return;
                }
                const ze = Math.round(O.max.x - O.min.x),
                    Re = Math.round(O.max.y - O.min.y),
                    Ue = O.max.z - O.min.z + 1,
                    Je = rt.convert(ue.format),
                    ct = rt.convert(ue.type);
                let mt;
                if (ue.isData3DTexture) Ke.setTexture3D(ue, 0), (mt = V.TEXTURE_3D);
                else if (ue.isDataArrayTexture || ue.isCompressedArrayTexture)
                    Ke.setTexture2DArray(ue, 0), (mt = V.TEXTURE_2D_ARRAY);
                else {
                    console.warn(
                        'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
                    );
                    return;
                }
                V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, ue.flipY),
                    V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ue.premultiplyAlpha),
                    V.pixelStorei(V.UNPACK_ALIGNMENT, ue.unpackAlignment);
                const xt = V.getParameter(V.UNPACK_ROW_LENGTH),
                    un = V.getParameter(V.UNPACK_IMAGE_HEIGHT),
                    Jn = V.getParameter(V.UNPACK_SKIP_PIXELS),
                    $t = V.getParameter(V.UNPACK_SKIP_ROWS),
                    Vn = V.getParameter(V.UNPACK_SKIP_IMAGES),
                    dt = se.isCompressedTexture ? se.mipmaps[ne] : se.image;
                V.pixelStorei(V.UNPACK_ROW_LENGTH, dt.width),
                    V.pixelStorei(V.UNPACK_IMAGE_HEIGHT, dt.height),
                    V.pixelStorei(V.UNPACK_SKIP_PIXELS, O.min.x),
                    V.pixelStorei(V.UNPACK_SKIP_ROWS, O.min.y),
                    V.pixelStorei(V.UNPACK_SKIP_IMAGES, O.min.z),
                    se.isDataTexture || se.isData3DTexture
                        ? V.texSubImage3D(mt, ne, $.x, $.y, $.z, ze, Re, Ue, Je, ct, dt.data)
                        : ue.isCompressedArrayTexture
                        ? V.compressedTexSubImage3D(mt, ne, $.x, $.y, $.z, ze, Re, Ue, Je, dt.data)
                        : V.texSubImage3D(mt, ne, $.x, $.y, $.z, ze, Re, Ue, Je, ct, dt),
                    V.pixelStorei(V.UNPACK_ROW_LENGTH, xt),
                    V.pixelStorei(V.UNPACK_IMAGE_HEIGHT, un),
                    V.pixelStorei(V.UNPACK_SKIP_PIXELS, Jn),
                    V.pixelStorei(V.UNPACK_SKIP_ROWS, $t),
                    V.pixelStorei(V.UNPACK_SKIP_IMAGES, Vn),
                    ne === 0 && ue.generateMipmaps && V.generateMipmap(mt),
                    ye.unbindTexture();
            }),
            (this.initTexture = function (O) {
                O.isCubeTexture
                    ? Ke.setTextureCube(O, 0)
                    : O.isData3DTexture
                    ? Ke.setTexture3D(O, 0)
                    : O.isDataArrayTexture || O.isCompressedArrayTexture
                    ? Ke.setTexture2DArray(O, 0)
                    : Ke.setTexture2D(O, 0),
                    ye.unbindTexture();
            }),
            (this.resetState = function () {
                (P = 0), (A = 0), (R = null), ye.reset(), tt.reset();
            }),
            typeof __THREE_DEVTOOLS__ < 'u' &&
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
    }
    get coordinateSystem() {
        return ls;
    }
    get outputColorSpace() {
        return this._outputColorSpace;
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        (t.drawingBufferColorSpace = e === Pm ? 'display-p3' : 'srgb'),
            (t.unpackColorSpace = Gt.workingColorSpace === Bf ? 'display-p3' : 'srgb');
    }
    get useLegacyLights() {
        return (
            console.warn(
                'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.'
            ),
            this._useLegacyLights
        );
    }
    set useLegacyLights(e) {
        console.warn(
            'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.'
        ),
            (this._useLegacyLights = e);
    }
}
class qC extends kx {}
qC.prototype.isWebGL1Renderer = !0;
class Nm {
    constructor(e, t = 25e-5) {
        (this.isFogExp2 = !0), (this.name = ''), (this.color = new je(e)), (this.density = t);
    }
    clone() {
        return new Nm(this.color, this.density);
    }
    toJSON() {
        return {
            type: 'FogExp2',
            name: this.name,
            color: this.color.getHex(),
            density: this.density,
        };
    }
}
class Dm {
    constructor(e, t = 1, i = 1e3) {
        (this.isFog = !0),
            (this.name = ''),
            (this.color = new je(e)),
            (this.near = t),
            (this.far = i);
    }
    clone() {
        return new Dm(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: 'Fog',
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
        };
    }
}
class nm extends Ht {
    constructor() {
        super(),
            (this.isScene = !0),
            (this.type = 'Scene'),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new nr()),
            (this.environmentRotation = new nr()),
            (this.overrideMaterial = null),
            typeof __THREE_DEVTOOLS__ < 'u' &&
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null && (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            this.backgroundRotation.copy(e.backgroundRotation),
            this.environmentRotation.copy(e.environmentRotation),
            e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
        );
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            this.fog !== null && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
                (t.object.backgroundBlurriness = this.backgroundBlurriness),
            this.backgroundIntensity !== 1 &&
                (t.object.backgroundIntensity = this.backgroundIntensity),
            (t.object.backgroundRotation = this.backgroundRotation.toArray()),
            (t.object.environmentRotation = this.environmentRotation.toArray()),
            t
        );
    }
}
class Um {
    constructor(e, t) {
        (this.isInterleavedBuffer = !0),
            (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = Sf),
            (this._updateRange = { offset: 0, count: -1 }),
            (this.updateRanges = []),
            (this.version = 0),
            (this.uuid = er());
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    get updateRange() {
        return (
            NC(
                'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'
            ),
            this._updateRange
        );
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({ start: e, count: t });
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0;
    }
    copy(e) {
        return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
        );
    }
    copyAt(e, t, i) {
        (e *= this.stride), (i *= t.stride);
        for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = er()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i;
    }
    onUpload(e) {
        return (this.onUploadCallback = e), this;
    }
    toJSON(e) {
        return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = er()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
                    new Uint32Array(this.array.buffer)
                )),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
            }
        );
    }
}
const xi = new k();
class Ga {
    constructor(e, t, i, r = !1) {
        (this.isInterleavedBufferAttribute = !0),
            (this.name = ''),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = i),
            (this.normalized = r);
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            xi.fromBufferAttribute(this, t), xi.applyMatrix4(e), this.setXYZ(t, xi.x, xi.y, xi.z);
        return this;
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            xi.fromBufferAttribute(this, t),
                xi.applyNormalMatrix(e),
                this.setXYZ(t, xi.x, xi.y, xi.z);
        return this;
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            xi.fromBufferAttribute(this, t),
                xi.transformDirection(e),
                this.setXYZ(t, xi.x, xi.y, xi.z);
        return this;
    }
    getComponent(e, t) {
        let i = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (i = Ei(i, this.array)), i;
    }
    setComponent(e, t, i) {
        return (
            this.normalized && (i = Tt(i, this.array)),
            (this.data.array[e * this.data.stride + this.offset + t] = i),
            this
        );
    }
    setX(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset] = t),
            this
        );
    }
    setY(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 1] = t),
            this
        );
    }
    setZ(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 2] = t),
            this
        );
    }
    setW(e, t) {
        return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 3] = t),
            this
        );
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Ei(t, this.array)), t;
    }
    setXY(e, t, i) {
        return (
            (e = e * this.data.stride + this.offset),
            this.normalized && ((t = Tt(t, this.array)), (i = Tt(i, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            this
        );
    }
    setXYZ(e, t, i, r) {
        return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
                ((t = Tt(t, this.array)), (i = Tt(i, this.array)), (r = Tt(r, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            (this.data.array[e + 2] = r),
            this
        );
    }
    setXYZW(e, t, i, r, s) {
        return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
                ((t = Tt(t, this.array)),
                (i = Tt(i, this.array)),
                (r = Tt(r, this.array)),
                (s = Tt(s, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            (this.data.array[e + 2] = r),
            (this.data.array[e + 3] = s),
            this
        );
    }
    clone(e) {
        if (e === void 0) {
            console.log(
                'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
            );
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
            }
            return new Yt(new this.array.constructor(t), this.itemSize, this.normalized);
        } else
            return (
                e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                e.interleavedBuffers[this.data.uuid] === void 0 &&
                    (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                new Ga(
                    e.interleavedBuffers[this.data.uuid],
                    this.itemSize,
                    this.offset,
                    this.normalized
                )
            );
    }
    toJSON(e) {
        if (e === void 0) {
            console.log(
                'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
            );
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
            };
        } else
            return (
                e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                e.interleavedBuffers[this.data.uuid] === void 0 &&
                    (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized,
                }
            );
    }
}
class zx extends ii {
    constructor(e) {
        super(),
            (this.isSpriteMaterial = !0),
            (this.type = 'SpriteMaterial'),
            (this.color = new je(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
        );
    }
}
let bl;
const dc = new k(),
    Rl = new k(),
    Pl = new k(),
    Ll = new _e(),
    hc = new _e(),
    ZC = new ft(),
    Nh = new k(),
    pc = new k(),
    Dh = new k(),
    kw = new _e(),
    s0 = new _e(),
    zw = new _e();
class KC extends Ht {
    constructor(e = new zx()) {
        if ((super(), (this.isSprite = !0), (this.type = 'Sprite'), bl === void 0)) {
            bl = new bt();
            const t = new Float32Array([
                    -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
                ]),
                i = new Um(t, 5);
            bl.setIndex([0, 1, 2, 0, 2, 3]),
                bl.setAttribute('position', new Ga(i, 3, 0, !1)),
                bl.setAttribute('uv', new Ga(i, 2, 3, !1));
        }
        (this.geometry = bl), (this.material = e), (this.center = new _e(0.5, 0.5));
    }
    raycast(e, t) {
        e.camera === null &&
            console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Rl.setFromMatrixScale(this.matrixWorld),
            ZC.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
            Pl.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
                this.material.sizeAttenuation === !1 &&
                Rl.multiplyScalar(-Pl.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
        const o = this.center;
        Uh(Nh.set(-0.5, -0.5, 0), Pl, o, Rl, r, s),
            Uh(pc.set(0.5, -0.5, 0), Pl, o, Rl, r, s),
            Uh(Dh.set(0.5, 0.5, 0), Pl, o, Rl, r, s),
            kw.set(0, 0),
            s0.set(1, 0),
            zw.set(1, 1);
        let a = e.ray.intersectTriangle(Nh, pc, Dh, !1, dc);
        if (
            a === null &&
            (Uh(pc.set(-0.5, 0.5, 0), Pl, o, Rl, r, s),
            s0.set(0, 1),
            (a = e.ray.intersectTriangle(Nh, Dh, pc, !1, dc)),
            a === null)
        )
            return;
        const c = e.ray.origin.distanceTo(dc);
        c < e.near ||
            c > e.far ||
            t.push({
                distance: c,
                point: dc.clone(),
                uv: Ji.getInterpolation(dc, Nh, pc, Dh, kw, s0, zw, new _e()),
                face: null,
                object: this,
            });
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
        );
    }
}
function Uh(n, e, t, i, r, s) {
    Ll.subVectors(n, t).addScalar(0.5).multiply(i),
        r !== void 0 ? ((hc.x = s * Ll.x - r * Ll.y), (hc.y = r * Ll.x + s * Ll.y)) : hc.copy(Ll),
        n.copy(e),
        (n.x += hc.x),
        (n.y += hc.y),
        n.applyMatrix4(ZC);
}
const Oh = new k(),
    Bw = new k();
class JC extends Ht {
    constructor() {
        super(),
            (this._currentLevel = 0),
            (this.type = 'LOD'),
            Object.defineProperties(this, {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis);
        }
        return (this.autoUpdate = e.autoUpdate), this;
    }
    addLevel(e, t = 0, i = 0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++);
        return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
    }
    getCurrentLevel() {
        return this._currentLevel;
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1, r = t.length; i < r; i++) {
                let s = t[i].distance;
                if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
            }
            return t[i - 1].object;
        }
        return null;
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Oh.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(Oh);
            this.getObjectForDistance(r).raycast(e, t);
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Oh.setFromMatrixPosition(e.matrixWorld), Bw.setFromMatrixPosition(this.matrixWorld);
            const i = Oh.distanceTo(Bw) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1, s = t.length; r < s; r++) {
                let o = t[r].distance;
                if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
                    (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
                else break;
            }
            for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1), (t.object.levels = []);
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis,
            });
        }
        return t;
    }
}
const Hw = new k(),
    Vw = new Wt(),
    Gw = new Wt(),
    s4 = new k(),
    Ww = new ft(),
    Fh = new k(),
    o0 = new mi(),
    jw = new ft(),
    a0 = new bu();
class QC extends On {
    constructor(e, t) {
        super(e, t),
            (this.isSkinnedMesh = !0),
            (this.type = 'SkinnedMesh'),
            (this.bindMode = L_),
            (this.bindMatrix = new ft()),
            (this.bindMatrixInverse = new ft()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Ci()), this.boundingBox.makeEmpty();
        const t = e.getAttribute('position');
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, Fh), this.boundingBox.expandByPoint(Fh);
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new mi()),
            this.boundingSphere.makeEmpty();
        const t = e.getAttribute('position');
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, Fh), this.boundingSphere.expandByPoint(Fh);
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
            e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
            this
        );
    }
    raycast(e, t) {
        const i = this.material,
            r = this.matrixWorld;
        i !== void 0 &&
            (this.boundingSphere === null && this.computeBoundingSphere(),
            o0.copy(this.boundingSphere),
            o0.applyMatrix4(r),
            e.ray.intersectsSphere(o0) !== !1 &&
                (jw.copy(r).invert(),
                a0.copy(e.ray).applyMatrix4(jw),
                !(this.boundingBox !== null && a0.intersectsBox(this.boundingBox) === !1) &&
                    this._computeIntersections(e, t, a0)));
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
    }
    bind(e, t) {
        (this.skeleton = e),
            t === void 0 &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        const e = new Wt(),
            t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
            this.bindMode === L_
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : this.bindMode === cC
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton,
            r = this.geometry;
        Vw.fromBufferAttribute(r.attributes.skinIndex, e),
            Gw.fromBufferAttribute(r.attributes.skinWeight, e),
            Hw.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = Gw.getComponent(s);
            if (o !== 0) {
                const a = Vw.getComponent(s);
                Ww.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                    t.addScaledVector(s4.copy(Hw).applyMatrix4(Ww), o);
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
    }
}
class Bx extends Ht {
    constructor() {
        super(), (this.isBone = !0), (this.type = 'Bone');
    }
}
class Do extends mn {
    constructor(e = null, t = 1, i = 1, r, s, o, a, c, f = bn, d = bn, h, p) {
        super(null, o, a, c, f, d, r, s, h, p),
            (this.isDataTexture = !0),
            (this.image = { data: e, width: t, height: i }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
}
const Xw = new ft(),
    o4 = new ft();
class Om {
    constructor(e = [], t = []) {
        (this.uuid = er()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            this.init();
    }
    init() {
        const e = this.bones,
            t = this.boneInverses;
        if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn(
                'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
            ),
                (this.boneInverses = []);
            for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new ft());
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new ft();
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i &&
                (i.parent && i.parent.isBone
                    ? (i.matrix.copy(i.parent.matrixWorld).invert(),
                      i.matrix.multiply(i.matrixWorld))
                    : i.matrix.copy(i.matrixWorld),
                i.matrix.decompose(i.position, i.quaternion, i.scale));
        }
    }
    update() {
        const e = this.bones,
            t = this.boneInverses,
            i = this.boneMatrices,
            r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : o4;
            Xw.multiplyMatrices(a, t[s]), Xw.toArray(i, s * 16);
        }
        r !== null && (r.needsUpdate = !0);
    }
    clone() {
        return new Om(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Do(t, e, e, wi, Ki);
        return (i.needsUpdate = !0), (this.boneMatrices = t), (this.boneTexture = i), this;
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e) return r;
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 &&
                (console.warn('THREE.Skeleton: No bone found with UUID:', s), (o = new Bx())),
                this.bones.push(o),
                this.boneInverses.push(new ft().fromArray(e.boneInverses[i]));
        }
        return this.init(), this;
    }
    toJSON() {
        const e = {
            metadata: { version: 4.6, type: 'Skeleton', generator: 'Skeleton.toJSON' },
            bones: [],
            boneInverses: [],
        };
        e.uuid = this.uuid;
        const t = this.bones,
            i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray());
        }
        return e;
    }
}
class Su extends Yt {
    constructor(e, t, i, r = 1) {
        super(e, t, i), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = r);
    }
    copy(e) {
        return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e;
    }
}
const Il = new ft(),
    Yw = new ft(),
    kh = [],
    qw = new Ci(),
    a4 = new ft(),
    mc = new On(),
    gc = new mi();
class $C extends On {
    constructor(e, t, i) {
        super(e, t),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new Su(new Float32Array(i * 16), 16)),
            (this.instanceColor = null),
            (this.morphTexture = null),
            (this.count = i),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        for (let r = 0; r < i; r++) this.setMatrixAt(r, a4);
    }
    computeBoundingBox() {
        const e = this.geometry,
            t = this.count;
        this.boundingBox === null && (this.boundingBox = new Ci()),
            e.boundingBox === null && e.computeBoundingBox(),
            this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Il),
                qw.copy(e.boundingBox).applyMatrix4(Il),
                this.boundingBox.union(qw);
    }
    computeBoundingSphere() {
        const e = this.geometry,
            t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new mi()),
            e.boundingSphere === null && e.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Il),
                gc.copy(e.boundingSphere).applyMatrix4(Il),
                this.boundingSphere.union(gc);
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
            e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
            this
        );
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16);
    }
    getMorphAt(e, t) {
        const i = t.morphTargetInfluences,
            r = this.morphTexture.source.data.data,
            s = i.length + 1,
            o = e * s + 1;
        for (let a = 0; a < i.length; a++) i[a] = r[o + a];
    }
    raycast(e, t) {
        const i = this.matrixWorld,
            r = this.count;
        if (
            ((mc.geometry = this.geometry),
            (mc.material = this.material),
            mc.material !== void 0 &&
                (this.boundingSphere === null && this.computeBoundingSphere(),
                gc.copy(this.boundingSphere),
                gc.applyMatrix4(i),
                e.ray.intersectsSphere(gc) !== !1))
        )
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, Il),
                    Yw.multiplyMatrices(i, Il),
                    (mc.matrixWorld = Yw),
                    mc.raycast(e, kh);
                for (let o = 0, a = kh.length; o < a; o++) {
                    const c = kh[o];
                    (c.instanceId = s), (c.object = this), t.push(c);
                }
                kh.length = 0;
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null &&
            (this.instanceColor = new Su(new Float32Array(this.instanceMatrix.count * 3), 3)),
            t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16);
    }
    setMorphAt(e, t) {
        const i = t.morphTargetInfluences,
            r = i.length + 1;
        this.morphTexture === null &&
            (this.morphTexture = new Do(new Float32Array(r * this.count), r, this.count, Mx, Ki));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let f = 0; f < i.length; f++) o += i[f];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
            c = r * e;
        (s[c] = a), s.set(i, c + 1);
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
}
function l4(n, e) {
    return n.z - e.z;
}
function u4(n, e) {
    return e.z - n.z;
}
class c4 {
    constructor() {
        (this.index = 0), (this.pool = []), (this.list = []);
    }
    push(e, t) {
        const i = this.pool,
            r = this.list;
        this.index >= i.length && i.push({ start: -1, count: -1, z: -1 });
        const s = i[this.index];
        r.push(s), this.index++, (s.start = e.start), (s.count = e.count), (s.z = t);
    }
    reset() {
        (this.list.length = 0), (this.index = 0);
    }
}
const Nl = 'batchId',
    ho = new ft(),
    Zw = new ft(),
    f4 = new ft(),
    Kw = new ft(),
    l0 = new Gf(),
    zh = new Ci(),
    ua = new mi(),
    vc = new k(),
    u0 = new c4(),
    di = new On(),
    Bh = [];
function d4(n, e, t = 0) {
    const i = e.itemSize;
    if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
        const r = n.count;
        for (let s = 0; s < r; s++)
            for (let o = 0; o < i; o++) e.setComponent(s + t, o, n.getComponent(s, o));
    } else e.array.set(n.array, t * i);
    e.needsUpdate = !0;
}
class eb extends On {
    get maxGeometryCount() {
        return this._maxGeometryCount;
    }
    constructor(e, t, i = t * 2, r) {
        super(new bt(), r),
            (this.isBatchedMesh = !0),
            (this.perObjectFrustumCulled = !0),
            (this.sortObjects = !0),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.customSort = null),
            (this._drawRanges = []),
            (this._reservedRanges = []),
            (this._visibility = []),
            (this._active = []),
            (this._bounds = []),
            (this._maxGeometryCount = e),
            (this._maxVertexCount = t),
            (this._maxIndexCount = i),
            (this._geometryInitialized = !1),
            (this._geometryCount = 0),
            (this._multiDrawCounts = new Int32Array(e)),
            (this._multiDrawStarts = new Int32Array(e)),
            (this._multiDrawCount = 0),
            (this._visibilityChanged = !0),
            (this._matricesTexture = null),
            this._initMatricesTexture();
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxGeometryCount * 4);
        (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4),
            i = new Do(t, e, e, wi, Ki);
        this._matricesTexture = i;
    }
    _initializeGeometry(e) {
        const t = this.geometry,
            i = this._maxVertexCount,
            r = this._maxGeometryCount,
            s = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const a in e.attributes) {
                const c = e.getAttribute(a),
                    { array: f, itemSize: d, normalized: h } = c,
                    p = new f.constructor(i * d),
                    v = new c.constructor(p, d, h);
                v.setUsage(c.usage), t.setAttribute(a, v);
            }
            if (e.getIndex() !== null) {
                const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
                t.setIndex(new Yt(a, 1));
            }
            const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
            t.setAttribute(Nl, new Yt(o, 1)), (this._geometryInitialized = !0);
        }
    }
    _validateGeometry(e) {
        if (e.getAttribute(Nl))
            throw new Error(`BatchedMesh: Geometry cannot use attribute "${Nl}"`);
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const i in t.attributes) {
            if (i === Nl) continue;
            if (!e.hasAttribute(i))
                throw new Error(
                    `BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`
                );
            const r = e.getAttribute(i),
                s = t.getAttribute(i);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
                throw new Error(
                    'BatchedMesh: All attributes must have a consistent itemSize and normalized value.'
                );
        }
    }
    setCustomSort(e) {
        return (this.customSort = e), this;
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Ci());
        const e = this._geometryCount,
            t = this.boundingBox,
            i = this._active;
        t.makeEmpty();
        for (let r = 0; r < e; r++)
            i[r] !== !1 &&
                (this.getMatrixAt(r, ho),
                this.getBoundingBoxAt(r, zh).applyMatrix4(ho),
                t.union(zh));
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new mi());
        const e = this._geometryCount,
            t = this.boundingSphere,
            i = this._active;
        t.makeEmpty();
        for (let r = 0; r < e; r++)
            i[r] !== !1 &&
                (this.getMatrixAt(r, ho),
                this.getBoundingSphereAt(r, ua).applyMatrix4(ho),
                t.union(ua));
    }
    addGeometry(e, t = -1, i = -1) {
        if (
            (this._initializeGeometry(e),
            this._validateGeometry(e),
            this._geometryCount >= this._maxGeometryCount)
        )
            throw new Error('BatchedMesh: Maximum geometry count reached.');
        const r = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
        let s = null;
        const o = this._reservedRanges,
            a = this._drawRanges,
            c = this._bounds;
        this._geometryCount !== 0 && (s = o[o.length - 1]),
            t === -1 ? (r.vertexCount = e.getAttribute('position').count) : (r.vertexCount = t),
            s === null ? (r.vertexStart = 0) : (r.vertexStart = s.vertexStart + s.vertexCount);
        const f = e.getIndex(),
            d = f !== null;
        if (
            (d &&
                (i === -1 ? (r.indexCount = f.count) : (r.indexCount = i),
                s === null ? (r.indexStart = 0) : (r.indexStart = s.indexStart + s.indexCount)),
            (r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount) ||
                r.vertexStart + r.vertexCount > this._maxVertexCount)
        )
            throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.');
        const h = this._visibility,
            p = this._active,
            v = this._matricesTexture,
            _ = this._matricesTexture.image.data;
        h.push(!0), p.push(!0);
        const w = this._geometryCount;
        this._geometryCount++,
            f4.toArray(_, w * 16),
            (v.needsUpdate = !0),
            o.push(r),
            a.push({ start: d ? r.indexStart : r.vertexStart, count: -1 }),
            c.push({ boxInitialized: !1, box: new Ci(), sphereInitialized: !1, sphere: new mi() });
        const x = this.geometry.getAttribute(Nl);
        for (let g = 0; g < r.vertexCount; g++) x.setX(r.vertexStart + g, w);
        return (x.needsUpdate = !0), this.setGeometryAt(w, e), w;
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error('BatchedMesh: Maximum geometry count reached.');
        this._validateGeometry(t);
        const i = this.geometry,
            r = i.getIndex() !== null,
            s = i.getIndex(),
            o = t.getIndex(),
            a = this._reservedRanges[e];
        if ((r && o.count > a.indexCount) || t.attributes.position.count > a.vertexCount)
            throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.');
        const c = a.vertexStart,
            f = a.vertexCount;
        for (const v in i.attributes) {
            if (v === Nl) continue;
            const _ = t.getAttribute(v),
                w = i.getAttribute(v);
            d4(_, w, c);
            const x = _.itemSize;
            for (let g = _.count, S = f; g < S; g++) {
                const M = c + g;
                for (let T = 0; T < x; T++) w.setComponent(M, T, 0);
            }
            w.needsUpdate = !0;
        }
        if (r) {
            const v = a.indexStart;
            for (let _ = 0; _ < o.count; _++) s.setX(v + _, c + o.getX(_));
            for (let _ = o.count, w = a.indexCount; _ < w; _++) s.setX(v + _, c);
            s.needsUpdate = !0;
        }
        const d = this._bounds[e];
        t.boundingBox !== null
            ? (d.box.copy(t.boundingBox), (d.boxInitialized = !0))
            : (d.boxInitialized = !1),
            t.boundingSphere !== null
                ? (d.sphere.copy(t.boundingSphere), (d.sphereInitialized = !0))
                : (d.sphereInitialized = !1);
        const h = this._drawRanges[e],
            p = t.getAttribute('position');
        return (h.count = r ? o.count : p.count), (this._visibilityChanged = !0), e;
    }
    deleteGeometry(e) {
        const t = this._active;
        return e >= t.length || t[e] === !1
            ? this
            : ((t[e] = !1), (this._visibilityChanged = !0), this);
    }
    getBoundingBoxAt(e, t) {
        if (this._active[e] === !1) return null;
        const r = this._bounds[e],
            s = r.box,
            o = this.geometry;
        if (r.boxInitialized === !1) {
            s.makeEmpty();
            const a = o.index,
                c = o.attributes.position,
                f = this._drawRanges[e];
            for (let d = f.start, h = f.start + f.count; d < h; d++) {
                let p = d;
                a && (p = a.getX(p)), s.expandByPoint(vc.fromBufferAttribute(c, p));
            }
            r.boxInitialized = !0;
        }
        return t.copy(s), t;
    }
    getBoundingSphereAt(e, t) {
        if (this._active[e] === !1) return null;
        const r = this._bounds[e],
            s = r.sphere,
            o = this.geometry;
        if (r.sphereInitialized === !1) {
            s.makeEmpty(), this.getBoundingBoxAt(e, zh), zh.getCenter(s.center);
            const a = o.index,
                c = o.attributes.position,
                f = this._drawRanges[e];
            let d = 0;
            for (let h = f.start, p = f.start + f.count; h < p; h++) {
                let v = h;
                a && (v = a.getX(v)),
                    vc.fromBufferAttribute(c, v),
                    (d = Math.max(d, s.center.distanceToSquared(vc)));
            }
            (s.radius = Math.sqrt(d)), (r.sphereInitialized = !0);
        }
        return t.copy(s), t;
    }
    setMatrixAt(e, t) {
        const i = this._active,
            r = this._matricesTexture,
            s = this._matricesTexture.image.data,
            o = this._geometryCount;
        return e >= o || i[e] === !1 ? this : (t.toArray(s, e * 16), (r.needsUpdate = !0), this);
    }
    getMatrixAt(e, t) {
        const i = this._active,
            r = this._matricesTexture.image.data,
            s = this._geometryCount;
        return e >= s || i[e] === !1 ? null : t.fromArray(r, e * 16);
    }
    setVisibleAt(e, t) {
        const i = this._visibility,
            r = this._active,
            s = this._geometryCount;
        return e >= s || r[e] === !1 || i[e] === t
            ? this
            : ((i[e] = t), (this._visibilityChanged = !0), this);
    }
    getVisibleAt(e) {
        const t = this._visibility,
            i = this._active,
            r = this._geometryCount;
        return e >= r || i[e] === !1 ? !1 : t[e];
    }
    raycast(e, t) {
        const i = this._visibility,
            r = this._active,
            s = this._drawRanges,
            o = this._geometryCount,
            a = this.matrixWorld,
            c = this.geometry;
        (di.material = this.material),
            (di.geometry.index = c.index),
            (di.geometry.attributes = c.attributes),
            di.geometry.boundingBox === null && (di.geometry.boundingBox = new Ci()),
            di.geometry.boundingSphere === null && (di.geometry.boundingSphere = new mi());
        for (let f = 0; f < o; f++) {
            if (!i[f] || !r[f]) continue;
            const d = s[f];
            di.geometry.setDrawRange(d.start, d.count),
                this.getMatrixAt(f, di.matrixWorld).premultiply(a),
                this.getBoundingBoxAt(f, di.geometry.boundingBox),
                this.getBoundingSphereAt(f, di.geometry.boundingSphere),
                di.raycast(e, Bh);
            for (let h = 0, p = Bh.length; h < p; h++) {
                const v = Bh[h];
                (v.object = this), (v.batchId = f), t.push(v);
            }
            Bh.length = 0;
        }
        (di.material = null),
            (di.geometry.index = null),
            (di.geometry.attributes = {}),
            di.geometry.setDrawRange(0, 1 / 0);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.geometry = e.geometry.clone()),
            (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
            (this.sortObjects = e.sortObjects),
            (this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null),
            (this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null),
            (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
            (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
            (this._visibility = e._visibility.slice()),
            (this._active = e._active.slice()),
            (this._bounds = e._bounds.map((t) => ({
                boxInitialized: t.boxInitialized,
                box: t.box.clone(),
                sphereInitialized: t.sphereInitialized,
                sphere: t.sphere.clone(),
            }))),
            (this._maxGeometryCount = e._maxGeometryCount),
            (this._maxVertexCount = e._maxVertexCount),
            (this._maxIndexCount = e._maxIndexCount),
            (this._geometryInitialized = e._geometryInitialized),
            (this._geometryCount = e._geometryCount),
            (this._multiDrawCounts = e._multiDrawCounts.slice()),
            (this._multiDrawStarts = e._multiDrawStarts.slice()),
            (this._matricesTexture = e._matricesTexture.clone()),
            (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
            this
        );
    }
    dispose() {
        return (
            this.geometry.dispose(),
            this._matricesTexture.dispose(),
            (this._matricesTexture = null),
            this
        );
    }
    onBeforeRender(e, t, i, r, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
        const o = r.getIndex(),
            a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
            c = this._active,
            f = this._visibility,
            d = this._multiDrawStarts,
            h = this._multiDrawCounts,
            p = this._drawRanges,
            v = this.perObjectFrustumCulled;
        v &&
            (Kw.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(
                this.matrixWorld
            ),
            l0.setFromProjectionMatrix(Kw, e.coordinateSystem));
        let _ = 0;
        if (this.sortObjects) {
            Zw.copy(this.matrixWorld).invert(),
                vc.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Zw);
            for (let g = 0, S = f.length; g < S; g++)
                if (f[g] && c[g]) {
                    this.getMatrixAt(g, ho), this.getBoundingSphereAt(g, ua).applyMatrix4(ho);
                    let M = !1;
                    if ((v && (M = !l0.intersectsSphere(ua)), !M)) {
                        const T = vc.distanceTo(ua.center);
                        u0.push(p[g], T);
                    }
                }
            const w = u0.list,
                x = this.customSort;
            x === null ? w.sort(s.transparent ? u4 : l4) : x.call(this, w, i);
            for (let g = 0, S = w.length; g < S; g++) {
                const M = w[g];
                (d[_] = M.start * a), (h[_] = M.count), _++;
            }
            u0.reset();
        } else
            for (let w = 0, x = f.length; w < x; w++)
                if (f[w] && c[w]) {
                    let g = !1;
                    if (
                        (v &&
                            (this.getMatrixAt(w, ho),
                            this.getBoundingSphereAt(w, ua).applyMatrix4(ho),
                            (g = !l0.intersectsSphere(ua))),
                        !g)
                    ) {
                        const S = p[w];
                        (d[_] = S.start * a), (h[_] = S.count), _++;
                    }
                }
        (this._multiDrawCount = _), (this._visibilityChanged = !1);
    }
    onBeforeShadow(e, t, i, r, s, o) {
        this.onBeforeRender(e, null, r, s, o);
    }
}
class Pi extends ii {
    constructor(e) {
        super(),
            (this.isLineBasicMaterial = !0),
            (this.type = 'LineBasicMaterial'),
            (this.color = new je(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = 'round'),
            (this.linejoin = 'round'),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
        );
    }
}
const Jw = new k(),
    Qw = new k(),
    $w = new ft(),
    c0 = new bu(),
    Hh = new mi();
class ko extends Ht {
    constructor(e = new bt(), t = new Pi()) {
        super(),
            (this.isLine = !0),
            (this.type = 'Line'),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
            (this.geometry = e.geometry),
            this
        );
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                Jw.fromBufferAttribute(t, r - 1),
                    Qw.fromBufferAttribute(t, r),
                    (i[r] = i[r - 1]),
                    (i[r] += Jw.distanceTo(Qw));
            e.setAttribute('lineDistance', new nt(i, 1));
        } else
            console.warn(
                'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
            );
        return this;
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Line.threshold,
            o = i.drawRange;
        if (
            (i.boundingSphere === null && i.computeBoundingSphere(),
            Hh.copy(i.boundingSphere),
            Hh.applyMatrix4(r),
            (Hh.radius += s),
            e.ray.intersectsSphere(Hh) === !1)
        )
            return;
        $w.copy(r).invert(), c0.copy(e.ray).applyMatrix4($w);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            c = a * a,
            f = new k(),
            d = new k(),
            h = new k(),
            p = new k(),
            v = this.isLineSegments ? 2 : 1,
            _ = i.index,
            x = i.attributes.position;
        if (_ !== null) {
            const g = Math.max(0, o.start),
                S = Math.min(_.count, o.start + o.count);
            for (let M = g, T = S - 1; M < T; M += v) {
                const P = _.getX(M),
                    A = _.getX(M + 1);
                if (
                    (f.fromBufferAttribute(x, P),
                    d.fromBufferAttribute(x, A),
                    c0.distanceSqToSegment(f, d, p, h) > c)
                )
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const D = e.ray.origin.distanceTo(p);
                D < e.near ||
                    D > e.far ||
                    t.push({
                        distance: D,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: M,
                        face: null,
                        faceIndex: null,
                        object: this,
                    });
            }
        } else {
            const g = Math.max(0, o.start),
                S = Math.min(x.count, o.start + o.count);
            for (let M = g, T = S - 1; M < T; M += v) {
                if (
                    (f.fromBufferAttribute(x, M),
                    d.fromBufferAttribute(x, M + 1),
                    c0.distanceSqToSegment(f, d, p, h) > c)
                )
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const A = e.ray.origin.distanceTo(p);
                A < e.near ||
                    A > e.far ||
                    t.push({
                        distance: A,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: M,
                        face: null,
                        faceIndex: null,
                        object: this,
                    });
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = s);
                }
            }
        }
    }
}
const eE = new k(),
    tE = new k();
class ps extends ko {
    constructor(e, t) {
        super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments');
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                eE.fromBufferAttribute(t, r),
                    tE.fromBufferAttribute(t, r + 1),
                    (i[r] = r === 0 ? 0 : i[r - 1]),
                    (i[r + 1] = i[r] + eE.distanceTo(tE));
            e.setAttribute('lineDistance', new nt(i, 1));
        } else
            console.warn(
                'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
            );
        return this;
    }
}
class tb extends ko {
    constructor(e, t) {
        super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop');
    }
}
class Hx extends ii {
    constructor(e) {
        super(),
            (this.isPointsMaterial = !0),
            (this.type = 'PointsMaterial'),
            (this.color = new je(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
        );
    }
}
const nE = new ft(),
    ly = new bu(),
    Vh = new mi(),
    Gh = new k();
class nb extends Ht {
    constructor(e = new bt(), t = new Hx()) {
        super(),
            (this.isPoints = !0),
            (this.type = 'Points'),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
            (this.geometry = e.geometry),
            this
        );
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Points.threshold,
            o = i.drawRange;
        if (
            (i.boundingSphere === null && i.computeBoundingSphere(),
            Vh.copy(i.boundingSphere),
            Vh.applyMatrix4(r),
            (Vh.radius += s),
            e.ray.intersectsSphere(Vh) === !1)
        )
            return;
        nE.copy(r).invert(), ly.copy(e.ray).applyMatrix4(nE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            c = a * a,
            f = i.index,
            h = i.attributes.position;
        if (f !== null) {
            const p = Math.max(0, o.start),
                v = Math.min(f.count, o.start + o.count);
            for (let _ = p, w = v; _ < w; _++) {
                const x = f.getX(_);
                Gh.fromBufferAttribute(h, x), iE(Gh, x, c, r, e, t, this);
            }
        } else {
            const p = Math.max(0, o.start),
                v = Math.min(h.count, o.start + o.count);
            for (let _ = p, w = v; _ < w; _++)
                Gh.fromBufferAttribute(h, _), iE(Gh, _, c, r, e, t, this);
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = s);
                }
            }
        }
    }
}
function iE(n, e, t, i, r, s, o) {
    const a = ly.distanceSqToPoint(n);
    if (a < t) {
        const c = new k();
        ly.closestPointToPoint(n, c), c.applyMatrix4(i);
        const f = r.ray.origin.distanceTo(c);
        if (f < r.near || f > r.far) return;
        s.push({
            distance: f,
            distanceToRay: Math.sqrt(a),
            point: c,
            index: e,
            face: null,
            object: o,
        });
    }
}
class h4 extends mn {
    constructor(e, t, i, r, s, o, a, c, f) {
        super(e, t, i, r, s, o, a, c, f),
            (this.isVideoTexture = !0),
            (this.minFilter = o !== void 0 ? o : dn),
            (this.magFilter = s !== void 0 ? s : dn),
            (this.generateMipmaps = !1);
        const d = this;
        function h() {
            (d.needsUpdate = !0), e.requestVideoFrameCallback(h);
        }
        'requestVideoFrameCallback' in e && e.requestVideoFrameCallback(h);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        const e = this.image;
        'requestVideoFrameCallback' in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
    }
}
class p4 extends mn {
    constructor(e, t) {
        super({ width: e, height: t }),
            (this.isFramebufferTexture = !0),
            (this.magFilter = bn),
            (this.minFilter = bn),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
    }
}
class Fm extends mn {
    constructor(e, t, i, r, s, o, a, c, f, d, h, p) {
        super(null, o, a, c, f, d, r, s, h, p),
            (this.isCompressedTexture = !0),
            (this.image = { width: t, height: i }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
    }
}
class m4 extends Fm {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
            (this.isCompressedArrayTexture = !0),
            (this.image.depth = r),
            (this.wrapR = pi);
    }
}
class g4 extends Fm {
    constructor(e, t, i) {
        super(void 0, e[0].width, e[0].height, t, i, Ws),
            (this.isCompressedCubeTexture = !0),
            (this.isCubeTexture = !0),
            (this.image = e);
    }
}
class v4 extends mn {
    constructor(e, t, i, r, s, o, a, c, f) {
        super(e, t, i, r, s, o, a, c, f), (this.isCanvasTexture = !0), (this.needsUpdate = !0);
    }
}
class jr {
    constructor() {
        (this.type = 'Curve'), (this.arcLengthDivisions = 200);
    }
    getPoint() {
        return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t);
    }
    getPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return t;
    }
    getSpacedPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
        return t;
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i,
            r = this.getPoint(0),
            s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
        return (this.cacheArcLengths = t), t;
    }
    updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? (o = t) : (o = e * i[s - 1]);
        let a = 0,
            c = s - 1,
            f;
        for (; a <= c; )
            if (((r = Math.floor(a + (c - a) / 2)), (f = i[r] - o), f < 0)) a = r + 1;
            else if (f > 0) c = r - 1;
            else {
                c = r;
                break;
            }
        if (((r = c), i[r] === o)) return r / (s - 1);
        const d = i[r],
            p = i[r + 1] - d,
            v = (o - d) / p;
        return (r + v) / (s - 1);
    }
    getTangent(e, t) {
        let r = e - 1e-4,
            s = e + 1e-4;
        r < 0 && (r = 0), s > 1 && (s = 1);
        const o = this.getPoint(r),
            a = this.getPoint(s),
            c = t || (o.isVector2 ? new _e() : new k());
        return c.copy(a).sub(o).normalize(), c;
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t);
    }
    computeFrenetFrames(e, t) {
        const i = new k(),
            r = [],
            s = [],
            o = [],
            a = new k(),
            c = new ft();
        for (let v = 0; v <= e; v++) {
            const _ = v / e;
            r[v] = this.getTangentAt(_, new k());
        }
        (s[0] = new k()), (o[0] = new k());
        let f = Number.MAX_VALUE;
        const d = Math.abs(r[0].x),
            h = Math.abs(r[0].y),
            p = Math.abs(r[0].z);
        d <= f && ((f = d), i.set(1, 0, 0)),
            h <= f && ((f = h), i.set(0, 1, 0)),
            p <= f && i.set(0, 0, 1),
            a.crossVectors(r[0], i).normalize(),
            s[0].crossVectors(r[0], a),
            o[0].crossVectors(r[0], s[0]);
        for (let v = 1; v <= e; v++) {
            if (
                ((s[v] = s[v - 1].clone()),
                (o[v] = o[v - 1].clone()),
                a.crossVectors(r[v - 1], r[v]),
                a.length() > Number.EPSILON)
            ) {
                a.normalize();
                const _ = Math.acos(wn(r[v - 1].dot(r[v]), -1, 1));
                s[v].applyMatrix4(c.makeRotationAxis(a, _));
            }
            o[v].crossVectors(r[v], s[v]);
        }
        if (t === !0) {
            let v = Math.acos(wn(s[0].dot(s[e]), -1, 1));
            (v /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (v = -v);
            for (let _ = 1; _ <= e; _++)
                s[_].applyMatrix4(c.makeRotationAxis(r[_], v * _)), o[_].crossVectors(r[_], s[_]);
        }
        return { tangents: r, normals: s, binormals: o };
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
    }
    toJSON() {
        const e = { metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' } };
        return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
    }
    fromJSON(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
    }
}
class km extends jr {
    constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, c = 0) {
        super(),
            (this.isEllipseCurve = !0),
            (this.type = 'EllipseCurve'),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = i),
            (this.yRadius = r),
            (this.aStartAngle = s),
            (this.aEndAngle = o),
            (this.aClockwise = a),
            (this.aRotation = c);
    }
    getPoint(e, t = new _e()) {
        const i = t,
            r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; ) s += r;
        for (; s > r; ) s -= r;
        s < Number.EPSILON && (o ? (s = 0) : (s = r)),
            this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r));
        const a = this.aStartAngle + e * s;
        let c = this.aX + this.xRadius * Math.cos(a),
            f = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation),
                h = Math.sin(this.aRotation),
                p = c - this.aX,
                v = f - this.aY;
            (c = p * d - v * h + this.aX), (f = p * h + v * d + this.aY);
        }
        return i.set(c, f);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
        );
    }
}
class ib extends km {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o), (this.isArcCurve = !0), (this.type = 'ArcCurve');
    }
}
function Vx() {
    let n = 0,
        e = 0,
        t = 0,
        i = 0;
    function r(s, o, a, c) {
        (n = s), (e = a), (t = -3 * s + 3 * o - 2 * a - c), (i = 2 * s - 2 * o + a + c);
    }
    return {
        initCatmullRom: function (s, o, a, c, f) {
            r(o, a, f * (a - s), f * (c - o));
        },
        initNonuniformCatmullRom: function (s, o, a, c, f, d, h) {
            let p = (o - s) / f - (a - s) / (f + d) + (a - o) / d,
                v = (a - o) / d - (c - o) / (d + h) + (c - a) / h;
            (p *= d), (v *= d), r(o, a, p, v);
        },
        calc: function (s) {
            const o = s * s,
                a = o * s;
            return n + e * s + t * o + i * a;
        },
    };
}
const Wh = new k(),
    f0 = new Vx(),
    d0 = new Vx(),
    h0 = new Vx();
class rb extends jr {
    constructor(e = [], t = !1, i = 'centripetal', r = 0.5) {
        super(),
            (this.isCatmullRomCurve3 = !0),
            (this.type = 'CatmullRomCurve3'),
            (this.points = e),
            (this.closed = t),
            (this.curveType = i),
            (this.tension = r);
    }
    getPoint(e, t = new k()) {
        const i = t,
            r = this.points,
            s = r.length,
            o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o),
            c = o - a;
        this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
            : c === 0 && a === s - 1 && ((a = s - 2), (c = 1));
        let f, d;
        this.closed || a > 0
            ? (f = r[(a - 1) % s])
            : (Wh.subVectors(r[0], r[1]).add(r[0]), (f = Wh));
        const h = r[a % s],
            p = r[(a + 1) % s];
        if (
            (this.closed || a + 2 < s
                ? (d = r[(a + 2) % s])
                : (Wh.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (d = Wh)),
            this.curveType === 'centripetal' || this.curveType === 'chordal')
        ) {
            const v = this.curveType === 'chordal' ? 0.5 : 0.25;
            let _ = Math.pow(f.distanceToSquared(h), v),
                w = Math.pow(h.distanceToSquared(p), v),
                x = Math.pow(p.distanceToSquared(d), v);
            w < 1e-4 && (w = 1),
                _ < 1e-4 && (_ = w),
                x < 1e-4 && (x = w),
                f0.initNonuniformCatmullRom(f.x, h.x, p.x, d.x, _, w, x),
                d0.initNonuniformCatmullRom(f.y, h.y, p.y, d.y, _, w, x),
                h0.initNonuniformCatmullRom(f.z, h.z, p.z, d.z, _, w, x);
        } else
            this.curveType === 'catmullrom' &&
                (f0.initCatmullRom(f.x, h.x, p.x, d.x, this.tension),
                d0.initCatmullRom(f.y, h.y, p.y, d.y, this.tension),
                h0.initCatmullRom(f.z, h.z, p.z, d.z, this.tension));
        return i.set(f0.calc(c), d0.calc(c), h0.calc(c)), i;
    }
    copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
        }
        return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
        }
        return (
            (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e
        );
    }
    fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new k().fromArray(r));
        }
        return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
        );
    }
}
function rE(n, e, t, i, r) {
    const s = (i - e) * 0.5,
        o = (r - t) * 0.5,
        a = n * n,
        c = n * a;
    return (2 * t - 2 * i + s + o) * c + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t;
}
function _4(n, e) {
    const t = 1 - n;
    return t * t * e;
}
function y4(n, e) {
    return 2 * (1 - n) * n * e;
}
function x4(n, e) {
    return n * n * e;
}
function Gc(n, e, t, i) {
    return _4(n, e) + y4(n, t) + x4(n, i);
}
function S4(n, e) {
    const t = 1 - n;
    return t * t * t * e;
}
function M4(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e;
}
function w4(n, e) {
    return 3 * (1 - n) * n * n * e;
}
function E4(n, e) {
    return n * n * n * e;
}
function Wc(n, e, t, i, r) {
    return S4(n, e) + M4(n, t) + w4(n, i) + E4(n, r);
}
class Gx extends jr {
    constructor(e = new _e(), t = new _e(), i = new _e(), r = new _e()) {
        super(),
            (this.isCubicBezierCurve = !0),
            (this.type = 'CubicBezierCurve'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = i),
            (this.v3 = r);
    }
    getPoint(e, t = new _e()) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(Wc(e, r.x, s.x, o.x, a.x), Wc(e, r.y, s.y, o.y, a.y)), i;
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        );
    }
}
class sb extends jr {
    constructor(e = new k(), t = new k(), i = new k(), r = new k()) {
        super(),
            (this.isCubicBezierCurve3 = !0),
            (this.type = 'CubicBezierCurve3'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = i),
            (this.v3 = r);
    }
    getPoint(e, t = new k()) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return (
            i.set(Wc(e, r.x, s.x, o.x, a.x), Wc(e, r.y, s.y, o.y, a.y), Wc(e, r.z, s.z, o.z, a.z)),
            i
        );
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        );
    }
}
class Wx extends jr {
    constructor(e = new _e(), t = new _e()) {
        super(), (this.isLineCurve = !0), (this.type = 'LineCurve'), (this.v1 = e), (this.v2 = t);
    }
    getPoint(e, t = new _e()) {
        const i = t;
        return (
            e === 1
                ? i.copy(this.v2)
                : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
            i
        );
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    getTangent(e, t = new _e()) {
        return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t);
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
}
class ob extends jr {
    constructor(e = new k(), t = new k()) {
        super(), (this.isLineCurve3 = !0), (this.type = 'LineCurve3'), (this.v1 = e), (this.v2 = t);
    }
    getPoint(e, t = new k()) {
        const i = t;
        return (
            e === 1
                ? i.copy(this.v2)
                : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
            i
        );
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    getTangent(e, t = new k()) {
        return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t);
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
}
class jx extends jr {
    constructor(e = new _e(), t = new _e(), i = new _e()) {
        super(),
            (this.isQuadraticBezierCurve = !0),
            (this.type = 'QuadraticBezierCurve'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = i);
    }
    getPoint(e, t = new _e()) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2;
        return i.set(Gc(e, r.x, s.x, o.x), Gc(e, r.y, s.y, o.y)), i;
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
}
class Xx extends jr {
    constructor(e = new k(), t = new k(), i = new k()) {
        super(),
            (this.isQuadraticBezierCurve3 = !0),
            (this.type = 'QuadraticBezierCurve3'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = i);
    }
    getPoint(e, t = new k()) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2;
        return i.set(Gc(e, r.x, s.x, o.x), Gc(e, r.y, s.y, o.y), Gc(e, r.z, s.z, o.z)), i;
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
}
class Yx extends jr {
    constructor(e = []) {
        super(), (this.isSplineCurve = !0), (this.type = 'SplineCurve'), (this.points = e);
    }
    getPoint(e, t = new _e()) {
        const i = t,
            r = this.points,
            s = (r.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            c = r[o === 0 ? o : o - 1],
            f = r[o],
            d = r[o > r.length - 2 ? r.length - 1 : o + 1],
            h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(rE(a, c.x, f.x, d.x, h.x), rE(a, c.y, f.y, d.y, h.y)), i;
    }
    copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
        }
        return this;
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new _e().fromArray(r));
        }
        return this;
    }
}
var im = Object.freeze({
    __proto__: null,
    ArcCurve: ib,
    CatmullRomCurve3: rb,
    CubicBezierCurve: Gx,
    CubicBezierCurve3: sb,
    EllipseCurve: km,
    LineCurve: Wx,
    LineCurve3: ob,
    QuadraticBezierCurve: jx,
    QuadraticBezierCurve3: Xx,
    SplineCurve: Yx,
});
class ab extends jr {
    constructor() {
        super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
    }
    add(e) {
        this.curves.push(e);
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? 'LineCurve' : 'LineCurve3';
            this.curves.push(new im[i](t, e));
        }
        return this;
    }
    getPoint(e, t) {
        const i = e * this.getLength(),
            r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i,
                    a = this.curves[s],
                    c = a.getLength(),
                    f = c === 0 ? 0 : 1 - o / c;
                return a.getPointAt(f, t);
            }
            s++;
        }
        return null;
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
    }
    updateArcLengths() {
        (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            (t += this.curves[i].getLength()), e.push(t);
        return (this.cacheLengths = e), e;
    }
    getSpacedPoints(e = 40) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r],
                a = o.isEllipseCurve
                    ? e * 2
                    : o.isLineCurve || o.isLineCurve3
                    ? 1
                    : o.isSplineCurve
                    ? e * o.points.length
                    : e,
                c = o.getPoints(a);
            for (let f = 0; f < c.length; f++) {
                const d = c[f];
                (i && i.equals(d)) || (t.push(d), (i = d));
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
    }
    copy(e) {
        super.copy(e), (this.curves = []);
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone());
        }
        return (this.autoClose = e.autoClose), this;
    }
    toJSON() {
        const e = super.toJSON();
        (e.autoClose = this.autoClose), (e.curves = []);
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new im[r.type]().fromJSON(r));
        }
        return this;
    }
}
class Ef extends ab {
    constructor(e) {
        super(), (this.type = 'Path'), (this.currentPoint = new _e()), e && this.setFromPoints(e);
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
        return this;
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
        const i = new Wx(this.currentPoint.clone(), new _e(e, t));
        return this.curves.push(i), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new jx(this.currentPoint.clone(), new _e(e, t), new _e(i, r));
        return this.curves.push(s), this.currentPoint.set(i, r), this;
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new Gx(this.currentPoint.clone(), new _e(e, t), new _e(i, r), new _e(s, o));
        return this.curves.push(a), this.currentPoint.set(s, o), this;
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
            i = new Yx(t);
        return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x,
            c = this.currentPoint.y;
        return this.absarc(e + a, t + c, i, r, s, o), this;
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o), this;
    }
    ellipse(e, t, i, r, s, o, a, c) {
        const f = this.currentPoint.x,
            d = this.currentPoint.y;
        return this.absellipse(e + f, t + d, i, r, s, o, a, c), this;
    }
    absellipse(e, t, i, r, s, o, a, c) {
        const f = new km(e, t, i, r, s, o, a, c);
        if (this.curves.length > 0) {
            const h = f.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
        }
        this.curves.push(f);
        const d = f.getPoint(1);
        return this.currentPoint.copy(d), this;
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.currentPoint = this.currentPoint.toArray()), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
    }
}
class jf extends bt {
    constructor(
        e = [new _e(0, -0.5), new _e(0.5, 0), new _e(0, 0.5)],
        t = 12,
        i = 0,
        r = Math.PI * 2
    ) {
        super(),
            (this.type = 'LatheGeometry'),
            (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
            (t = Math.floor(t)),
            (r = wn(r, 0, Math.PI * 2));
        const s = [],
            o = [],
            a = [],
            c = [],
            f = [],
            d = 1 / t,
            h = new k(),
            p = new _e(),
            v = new k(),
            _ = new k(),
            w = new k();
        let x = 0,
            g = 0;
        for (let S = 0; S <= e.length - 1; S++)
            switch (S) {
                case 0:
                    (x = e[S + 1].x - e[S].x),
                        (g = e[S + 1].y - e[S].y),
                        (v.x = g * 1),
                        (v.y = -x),
                        (v.z = g * 0),
                        w.copy(v),
                        v.normalize(),
                        c.push(v.x, v.y, v.z);
                    break;
                case e.length - 1:
                    c.push(w.x, w.y, w.z);
                    break;
                default:
                    (x = e[S + 1].x - e[S].x),
                        (g = e[S + 1].y - e[S].y),
                        (v.x = g * 1),
                        (v.y = -x),
                        (v.z = g * 0),
                        _.copy(v),
                        (v.x += w.x),
                        (v.y += w.y),
                        (v.z += w.z),
                        v.normalize(),
                        c.push(v.x, v.y, v.z),
                        w.copy(_);
            }
        for (let S = 0; S <= t; S++) {
            const M = i + S * d * r,
                T = Math.sin(M),
                P = Math.cos(M);
            for (let A = 0; A <= e.length - 1; A++) {
                (h.x = e[A].x * T),
                    (h.y = e[A].y),
                    (h.z = e[A].x * P),
                    o.push(h.x, h.y, h.z),
                    (p.x = S / t),
                    (p.y = A / (e.length - 1)),
                    a.push(p.x, p.y);
                const R = c[3 * A + 0] * T,
                    D = c[3 * A + 1],
                    G = c[3 * A + 0] * P;
                f.push(R, D, G);
            }
        }
        for (let S = 0; S < t; S++)
            for (let M = 0; M < e.length - 1; M++) {
                const T = M + S * e.length,
                    P = T,
                    A = T + e.length,
                    R = T + e.length + 1,
                    D = T + 1;
                s.push(P, A, D), s.push(R, D, A);
            }
        this.setIndex(s),
            this.setAttribute('position', new nt(o, 3)),
            this.setAttribute('uv', new nt(a, 2)),
            this.setAttribute('normal', new nt(f, 3));
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new jf(e.points, e.segments, e.phiStart, e.phiLength);
    }
}
class zm extends jf {
    constructor(e = 1, t = 1, i = 4, r = 8) {
        const s = new Ef();
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
            s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
            super(s.getPoints(i), r),
            (this.type = 'CapsuleGeometry'),
            (this.parameters = { radius: e, length: t, capSegments: i, radialSegments: r });
    }
    static fromJSON(e) {
        return new zm(e.radius, e.length, e.capSegments, e.radialSegments);
    }
}
class Bm extends bt {
    constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
        super(),
            (this.type = 'CircleGeometry'),
            (this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }),
            (t = Math.max(3, t));
        const s = [],
            o = [],
            a = [],
            c = [],
            f = new k(),
            d = new _e();
        o.push(0, 0, 0), a.push(0, 0, 1), c.push(0.5, 0.5);
        for (let h = 0, p = 3; h <= t; h++, p += 3) {
            const v = i + (h / t) * r;
            (f.x = e * Math.cos(v)),
                (f.y = e * Math.sin(v)),
                o.push(f.x, f.y, f.z),
                a.push(0, 0, 1),
                (d.x = (o[p] / e + 1) / 2),
                (d.y = (o[p + 1] / e + 1) / 2),
                c.push(d.x, d.y);
        }
        for (let h = 1; h <= t; h++) s.push(h, h + 1, 0);
        this.setIndex(s),
            this.setAttribute('position', new nt(o, 3)),
            this.setAttribute('normal', new nt(a, 3)),
            this.setAttribute('uv', new nt(c, 2));
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Bm(e.radius, e.segments, e.thetaStart, e.thetaLength);
    }
}
class Lu extends bt {
    constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, a = 0, c = Math.PI * 2) {
        super(),
            (this.type = 'CylinderGeometry'),
            (this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: i,
                radialSegments: r,
                heightSegments: s,
                openEnded: o,
                thetaStart: a,
                thetaLength: c,
            });
        const f = this;
        (r = Math.floor(r)), (s = Math.floor(s));
        const d = [],
            h = [],
            p = [],
            v = [];
        let _ = 0;
        const w = [],
            x = i / 2;
        let g = 0;
        S(),
            o === !1 && (e > 0 && M(!0), t > 0 && M(!1)),
            this.setIndex(d),
            this.setAttribute('position', new nt(h, 3)),
            this.setAttribute('normal', new nt(p, 3)),
            this.setAttribute('uv', new nt(v, 2));
        function S() {
            const T = new k(),
                P = new k();
            let A = 0;
            const R = (t - e) / i;
            for (let D = 0; D <= s; D++) {
                const G = [],
                    b = D / s,
                    L = b * (t - e) + e;
                for (let ee = 0; ee <= r; ee++) {
                    const ie = ee / r,
                        j = ie * c + a,
                        oe = Math.sin(j),
                        te = Math.cos(j);
                    (P.x = L * oe),
                        (P.y = -b * i + x),
                        (P.z = L * te),
                        h.push(P.x, P.y, P.z),
                        T.set(oe, R, te).normalize(),
                        p.push(T.x, T.y, T.z),
                        v.push(ie, 1 - b),
                        G.push(_++);
                }
                w.push(G);
            }
            for (let D = 0; D < r; D++)
                for (let G = 0; G < s; G++) {
                    const b = w[G][D],
                        L = w[G + 1][D],
                        ee = w[G + 1][D + 1],
                        ie = w[G][D + 1];
                    d.push(b, L, ie), d.push(L, ee, ie), (A += 6);
                }
            f.addGroup(g, A, 0), (g += A);
        }
        function M(T) {
            const P = _,
                A = new _e(),
                R = new k();
            let D = 0;
            const G = T === !0 ? e : t,
                b = T === !0 ? 1 : -1;
            for (let ee = 1; ee <= r; ee++)
                h.push(0, x * b, 0), p.push(0, b, 0), v.push(0.5, 0.5), _++;
            const L = _;
            for (let ee = 0; ee <= r; ee++) {
                const j = (ee / r) * c + a,
                    oe = Math.cos(j),
                    te = Math.sin(j);
                (R.x = G * te),
                    (R.y = x * b),
                    (R.z = G * oe),
                    h.push(R.x, R.y, R.z),
                    p.push(0, b, 0),
                    (A.x = oe * 0.5 + 0.5),
                    (A.y = te * 0.5 * b + 0.5),
                    v.push(A.x, A.y),
                    _++;
            }
            for (let ee = 0; ee < r; ee++) {
                const ie = P + ee,
                    j = L + ee;
                T === !0 ? d.push(j, j + 1, ie) : d.push(j + 1, j, ie), (D += 3);
            }
            f.addGroup(g, D, T === !0 ? 1 : 2), (g += D);
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Lu(
            e.radiusTop,
            e.radiusBottom,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Hm extends Lu {
    constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
        super(0, e, t, i, r, s, o, a),
            (this.type = 'ConeGeometry'),
            (this.parameters = {
                radius: e,
                height: t,
                radialSegments: i,
                heightSegments: r,
                openEnded: s,
                thetaStart: o,
                thetaLength: a,
            });
    }
    static fromJSON(e) {
        return new Hm(
            e.radius,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Wo extends bt {
    constructor(e = [], t = [], i = 1, r = 0) {
        super(),
            (this.type = 'PolyhedronGeometry'),
            (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
        const s = [],
            o = [];
        a(r),
            f(i),
            d(),
            this.setAttribute('position', new nt(s, 3)),
            this.setAttribute('normal', new nt(s.slice(), 3)),
            this.setAttribute('uv', new nt(o, 2)),
            r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(S) {
            const M = new k(),
                T = new k(),
                P = new k();
            for (let A = 0; A < t.length; A += 3)
                v(t[A + 0], M), v(t[A + 1], T), v(t[A + 2], P), c(M, T, P, S);
        }
        function c(S, M, T, P) {
            const A = P + 1,
                R = [];
            for (let D = 0; D <= A; D++) {
                R[D] = [];
                const G = S.clone().lerp(T, D / A),
                    b = M.clone().lerp(T, D / A),
                    L = A - D;
                for (let ee = 0; ee <= L; ee++)
                    ee === 0 && D === A ? (R[D][ee] = G) : (R[D][ee] = G.clone().lerp(b, ee / L));
            }
            for (let D = 0; D < A; D++)
                for (let G = 0; G < 2 * (A - D) - 1; G++) {
                    const b = Math.floor(G / 2);
                    G % 2 === 0
                        ? (p(R[D][b + 1]), p(R[D + 1][b]), p(R[D][b]))
                        : (p(R[D][b + 1]), p(R[D + 1][b + 1]), p(R[D + 1][b]));
                }
        }
        function f(S) {
            const M = new k();
            for (let T = 0; T < s.length; T += 3)
                (M.x = s[T + 0]),
                    (M.y = s[T + 1]),
                    (M.z = s[T + 2]),
                    M.normalize().multiplyScalar(S),
                    (s[T + 0] = M.x),
                    (s[T + 1] = M.y),
                    (s[T + 2] = M.z);
        }
        function d() {
            const S = new k();
            for (let M = 0; M < s.length; M += 3) {
                (S.x = s[M + 0]), (S.y = s[M + 1]), (S.z = s[M + 2]);
                const T = x(S) / 2 / Math.PI + 0.5,
                    P = g(S) / Math.PI + 0.5;
                o.push(T, 1 - P);
            }
            _(), h();
        }
        function h() {
            for (let S = 0; S < o.length; S += 6) {
                const M = o[S + 0],
                    T = o[S + 2],
                    P = o[S + 4],
                    A = Math.max(M, T, P),
                    R = Math.min(M, T, P);
                A > 0.9 &&
                    R < 0.1 &&
                    (M < 0.2 && (o[S + 0] += 1),
                    T < 0.2 && (o[S + 2] += 1),
                    P < 0.2 && (o[S + 4] += 1));
            }
        }
        function p(S) {
            s.push(S.x, S.y, S.z);
        }
        function v(S, M) {
            const T = S * 3;
            (M.x = e[T + 0]), (M.y = e[T + 1]), (M.z = e[T + 2]);
        }
        function _() {
            const S = new k(),
                M = new k(),
                T = new k(),
                P = new k(),
                A = new _e(),
                R = new _e(),
                D = new _e();
            for (let G = 0, b = 0; G < s.length; G += 9, b += 6) {
                S.set(s[G + 0], s[G + 1], s[G + 2]),
                    M.set(s[G + 3], s[G + 4], s[G + 5]),
                    T.set(s[G + 6], s[G + 7], s[G + 8]),
                    A.set(o[b + 0], o[b + 1]),
                    R.set(o[b + 2], o[b + 3]),
                    D.set(o[b + 4], o[b + 5]),
                    P.copy(S).add(M).add(T).divideScalar(3);
                const L = x(P);
                w(A, b + 0, S, L), w(R, b + 2, M, L), w(D, b + 4, T, L);
            }
        }
        function w(S, M, T, P) {
            P < 0 && S.x === 1 && (o[M] = S.x - 1),
                T.x === 0 && T.z === 0 && (o[M] = P / 2 / Math.PI + 0.5);
        }
        function x(S) {
            return Math.atan2(S.z, -S.x);
        }
        function g(S) {
            return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Wo(e.vertices, e.indices, e.radius, e.details);
    }
}
class Vm extends Wo {
    constructor(e = 1, t = 0) {
        const i = (1 + Math.sqrt(5)) / 2,
            r = 1 / i,
            s = [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -r,
                -i,
                0,
                -r,
                i,
                0,
                r,
                -i,
                0,
                r,
                i,
                -r,
                -i,
                0,
                -r,
                i,
                0,
                r,
                -i,
                0,
                r,
                i,
                0,
                -i,
                0,
                -r,
                i,
                0,
                -r,
                -i,
                0,
                r,
                i,
                0,
                r,
            ],
            o = [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10,
                17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6,
                2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
                4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ];
        super(s, o, e, t),
            (this.type = 'DodecahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new Vm(e.radius, e.detail);
    }
}
const jh = new k(),
    Xh = new k(),
    p0 = new k(),
    Yh = new Ji();
class lb extends bt {
    constructor(e = null, t = 1) {
        if (
            (super(),
            (this.type = 'EdgesGeometry'),
            (this.parameters = { geometry: e, thresholdAngle: t }),
            e !== null)
        ) {
            const r = Math.pow(10, 4),
                s = Math.cos(Na * t),
                o = e.getIndex(),
                a = e.getAttribute('position'),
                c = o ? o.count : a.count,
                f = [0, 0, 0],
                d = ['a', 'b', 'c'],
                h = new Array(3),
                p = {},
                v = [];
            for (let _ = 0; _ < c; _ += 3) {
                o
                    ? ((f[0] = o.getX(_)), (f[1] = o.getX(_ + 1)), (f[2] = o.getX(_ + 2)))
                    : ((f[0] = _), (f[1] = _ + 1), (f[2] = _ + 2));
                const { a: w, b: x, c: g } = Yh;
                if (
                    (w.fromBufferAttribute(a, f[0]),
                    x.fromBufferAttribute(a, f[1]),
                    g.fromBufferAttribute(a, f[2]),
                    Yh.getNormal(p0),
                    (h[0] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`),
                    (h[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`),
                    (h[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`),
                    !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                )
                    for (let S = 0; S < 3; S++) {
                        const M = (S + 1) % 3,
                            T = h[S],
                            P = h[M],
                            A = Yh[d[S]],
                            R = Yh[d[M]],
                            D = `${T}_${P}`,
                            G = `${P}_${T}`;
                        G in p && p[G]
                            ? (p0.dot(p[G].normal) <= s &&
                                  (v.push(A.x, A.y, A.z), v.push(R.x, R.y, R.z)),
                              (p[G] = null))
                            : D in p || (p[D] = { index0: f[S], index1: f[M], normal: p0.clone() });
                    }
            }
            for (const _ in p)
                if (p[_]) {
                    const { index0: w, index1: x } = p[_];
                    jh.fromBufferAttribute(a, w),
                        Xh.fromBufferAttribute(a, x),
                        v.push(jh.x, jh.y, jh.z),
                        v.push(Xh.x, Xh.y, Xh.z);
                }
            this.setAttribute('position', new nt(v, 3));
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
}
class Ua extends Ef {
    constructor(e) {
        super(e), (this.uuid = er()), (this.type = 'Shape'), (this.holes = []);
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
        return t;
    }
    extractPoints(e) {
        return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
    }
    copy(e) {
        super.copy(e), (this.holes = []);
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone());
        }
        return this;
    }
    toJSON() {
        const e = super.toJSON();
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new Ef().fromJSON(r));
        }
        return this;
    }
}
const T4 = {
    triangulate: function (n, e, t = 2) {
        const i = e && e.length,
            r = i ? e[0] * t : n.length;
        let s = ub(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, c, f, d, h, p, v;
        if ((i && (s = P4(n, e, s, t)), n.length > 80 * t)) {
            (a = f = n[0]), (c = d = n[1]);
            for (let _ = t; _ < r; _ += t)
                (h = n[_]),
                    (p = n[_ + 1]),
                    h < a && (a = h),
                    p < c && (c = p),
                    h > f && (f = h),
                    p > d && (d = p);
            (v = Math.max(f - a, d - c)), (v = v !== 0 ? 32767 / v : 0);
        }
        return Tf(s, o, t, a, c, v, 0), o;
    },
};
function ub(n, e, t, i, r) {
    let s, o;
    if (r === H4(n, e, t, i) > 0) for (s = e; s < t; s += i) o = sE(s, n[s], n[s + 1], o);
    else for (s = t - i; s >= e; s -= i) o = sE(s, n[s], n[s + 1], o);
    return o && Gm(o, o.next) && (Cf(o), (o = o.next)), o;
}
function Wa(n, e) {
    if (!n) return n;
    e || (e = n);
    let t = n,
        i;
    do
        if (((i = !1), !t.steiner && (Gm(t, t.next) || hn(t.prev, t, t.next) === 0))) {
            if ((Cf(t), (t = e = t.prev), t === t.next)) break;
            i = !0;
        } else t = t.next;
    while (i || t !== e);
    return e;
}
function Tf(n, e, t, i, r, s, o) {
    if (!n) return;
    !o && s && U4(n, i, r, s);
    let a = n,
        c,
        f;
    for (; n.prev !== n.next; ) {
        if (((c = n.prev), (f = n.next), s ? C4(n, i, r, s) : A4(n))) {
            e.push((c.i / t) | 0),
                e.push((n.i / t) | 0),
                e.push((f.i / t) | 0),
                Cf(n),
                (n = f.next),
                (a = f.next);
            continue;
        }
        if (((n = f), n === a)) {
            o
                ? o === 1
                    ? ((n = b4(Wa(n), e, t)), Tf(n, e, t, i, r, s, 2))
                    : o === 2 && R4(n, e, t, i, r, s)
                : Tf(Wa(n), e, t, i, r, s, 1);
            break;
        }
    }
}
function A4(n) {
    const e = n.prev,
        t = n,
        i = n.next;
    if (hn(e, t, i) >= 0) return !1;
    const r = e.x,
        s = t.x,
        o = i.x,
        a = e.y,
        c = t.y,
        f = i.y,
        d = r < s ? (r < o ? r : o) : s < o ? s : o,
        h = a < c ? (a < f ? a : f) : c < f ? c : f,
        p = r > s ? (r > o ? r : o) : s > o ? s : o,
        v = a > c ? (a > f ? a : f) : c > f ? c : f;
    let _ = i.next;
    for (; _ !== e; ) {
        if (
            _.x >= d &&
            _.x <= p &&
            _.y >= h &&
            _.y <= v &&
            eu(r, a, s, c, o, f, _.x, _.y) &&
            hn(_.prev, _, _.next) >= 0
        )
            return !1;
        _ = _.next;
    }
    return !0;
}
function C4(n, e, t, i) {
    const r = n.prev,
        s = n,
        o = n.next;
    if (hn(r, s, o) >= 0) return !1;
    const a = r.x,
        c = s.x,
        f = o.x,
        d = r.y,
        h = s.y,
        p = o.y,
        v = a < c ? (a < f ? a : f) : c < f ? c : f,
        _ = d < h ? (d < p ? d : p) : h < p ? h : p,
        w = a > c ? (a > f ? a : f) : c > f ? c : f,
        x = d > h ? (d > p ? d : p) : h > p ? h : p,
        g = uy(v, _, e, t, i),
        S = uy(w, x, e, t, i);
    let M = n.prevZ,
        T = n.nextZ;
    for (; M && M.z >= g && T && T.z <= S; ) {
        if (
            (M.x >= v &&
                M.x <= w &&
                M.y >= _ &&
                M.y <= x &&
                M !== r &&
                M !== o &&
                eu(a, d, c, h, f, p, M.x, M.y) &&
                hn(M.prev, M, M.next) >= 0) ||
            ((M = M.prevZ),
            T.x >= v &&
                T.x <= w &&
                T.y >= _ &&
                T.y <= x &&
                T !== r &&
                T !== o &&
                eu(a, d, c, h, f, p, T.x, T.y) &&
                hn(T.prev, T, T.next) >= 0)
        )
            return !1;
        T = T.nextZ;
    }
    for (; M && M.z >= g; ) {
        if (
            M.x >= v &&
            M.x <= w &&
            M.y >= _ &&
            M.y <= x &&
            M !== r &&
            M !== o &&
            eu(a, d, c, h, f, p, M.x, M.y) &&
            hn(M.prev, M, M.next) >= 0
        )
            return !1;
        M = M.prevZ;
    }
    for (; T && T.z <= S; ) {
        if (
            T.x >= v &&
            T.x <= w &&
            T.y >= _ &&
            T.y <= x &&
            T !== r &&
            T !== o &&
            eu(a, d, c, h, f, p, T.x, T.y) &&
            hn(T.prev, T, T.next) >= 0
        )
            return !1;
        T = T.nextZ;
    }
    return !0;
}
function b4(n, e, t) {
    let i = n;
    do {
        const r = i.prev,
            s = i.next.next;
        !Gm(r, s) &&
            cb(r, i, i.next, s) &&
            Af(r, s) &&
            Af(s, r) &&
            (e.push((r.i / t) | 0),
            e.push((i.i / t) | 0),
            e.push((s.i / t) | 0),
            Cf(i),
            Cf(i.next),
            (i = n = s)),
            (i = i.next);
    } while (i !== n);
    return Wa(i);
}
function R4(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && k4(o, a)) {
                let c = fb(o, a);
                (o = Wa(o, o.next)),
                    (c = Wa(c, c.next)),
                    Tf(o, e, t, i, r, s, 0),
                    Tf(c, e, t, i, r, s, 0);
                return;
            }
            a = a.next;
        }
        o = o.next;
    } while (o !== n);
}
function P4(n, e, t, i) {
    const r = [];
    let s, o, a, c, f;
    for (s = 0, o = e.length; s < o; s++)
        (a = e[s] * i),
            (c = s < o - 1 ? e[s + 1] * i : n.length),
            (f = ub(n, a, c, i, !1)),
            f === f.next && (f.steiner = !0),
            r.push(F4(f));
    for (r.sort(L4), s = 0; s < r.length; s++) t = I4(r[s], t);
    return t;
}
function L4(n, e) {
    return n.x - e.x;
}
function I4(n, e) {
    const t = N4(n, e);
    if (!t) return e;
    const i = fb(t, n);
    return Wa(i, i.next), Wa(t, t.next);
}
function N4(n, e) {
    let t = e,
        i = -1 / 0,
        r;
    const s = n.x,
        o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (p <= s && p > i && ((i = p), (r = t.x < t.next.x ? t : t.next), p === s)) return r;
        }
        t = t.next;
    } while (t !== e);
    if (!r) return null;
    const a = r,
        c = r.x,
        f = r.y;
    let d = 1 / 0,
        h;
    t = r;
    do
        s >= t.x &&
            t.x >= c &&
            s !== t.x &&
            eu(o < f ? s : i, o, c, f, o < f ? i : s, o, t.x, t.y) &&
            ((h = Math.abs(o - t.y) / (s - t.x)),
            Af(t, n) &&
                (h < d || (h === d && (t.x > r.x || (t.x === r.x && D4(r, t))))) &&
                ((r = t), (d = h))),
            (t = t.next);
    while (t !== a);
    return r;
}
function D4(n, e) {
    return hn(n.prev, n, e.prev) < 0 && hn(e.next, n, n.next) < 0;
}
function U4(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = uy(r.x, r.y, e, t, i)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
    while (r !== n);
    (r.prevZ.nextZ = null), (r.prevZ = null), O4(r);
}
function O4(n) {
    let e,
        t,
        i,
        r,
        s,
        o,
        a,
        c,
        f = 1;
    do {
        for (t = n, n = null, s = null, o = 0; t; ) {
            for (o++, i = t, a = 0, e = 0; e < f && (a++, (i = i.nextZ), !!i); e++);
            for (c = f; a > 0 || (c > 0 && i); )
                a !== 0 && (c === 0 || !i || t.z <= i.z)
                    ? ((r = t), (t = t.nextZ), a--)
                    : ((r = i), (i = i.nextZ), c--),
                    s ? (s.nextZ = r) : (n = r),
                    (r.prevZ = s),
                    (s = r);
            t = i;
        }
        (s.nextZ = null), (f *= 2);
    } while (o > 1);
    return n;
}
function uy(n, e, t, i, r) {
    return (
        (n = ((n - t) * r) | 0),
        (e = ((e - i) * r) | 0),
        (n = (n | (n << 8)) & 16711935),
        (n = (n | (n << 4)) & 252645135),
        (n = (n | (n << 2)) & 858993459),
        (n = (n | (n << 1)) & 1431655765),
        (e = (e | (e << 8)) & 16711935),
        (e = (e | (e << 4)) & 252645135),
        (e = (e | (e << 2)) & 858993459),
        (e = (e | (e << 1)) & 1431655765),
        n | (e << 1)
    );
}
function F4(n) {
    let e = n,
        t = n;
    do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
    while (e !== n);
    return t;
}
function eu(n, e, t, i, r, s, o, a) {
    return (
        (r - o) * (e - a) >= (n - o) * (s - a) &&
        (n - o) * (i - a) >= (t - o) * (e - a) &&
        (t - o) * (s - a) >= (r - o) * (i - a)
    );
}
function k4(n, e) {
    return (
        n.next.i !== e.i &&
        n.prev.i !== e.i &&
        !z4(n, e) &&
        ((Af(n, e) && Af(e, n) && B4(n, e) && (hn(n.prev, n, e.prev) || hn(n, e.prev, e))) ||
            (Gm(n, e) && hn(n.prev, n, n.next) > 0 && hn(e.prev, e, e.next) > 0))
    );
}
function hn(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function Gm(n, e) {
    return n.x === e.x && n.y === e.y;
}
function cb(n, e, t, i) {
    const r = Zh(hn(n, e, t)),
        s = Zh(hn(n, e, i)),
        o = Zh(hn(t, i, n)),
        a = Zh(hn(t, i, e));
    return !!(
        (r !== s && o !== a) ||
        (r === 0 && qh(n, t, e)) ||
        (s === 0 && qh(n, i, e)) ||
        (o === 0 && qh(t, n, i)) ||
        (a === 0 && qh(t, e, i))
    );
}
function qh(n, e, t) {
    return (
        e.x <= Math.max(n.x, t.x) &&
        e.x >= Math.min(n.x, t.x) &&
        e.y <= Math.max(n.y, t.y) &&
        e.y >= Math.min(n.y, t.y)
    );
}
function Zh(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function z4(n, e) {
    let t = n;
    do {
        if (
            t.i !== n.i &&
            t.next.i !== n.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            cb(t, t.next, n, e)
        )
            return !0;
        t = t.next;
    } while (t !== n);
    return !1;
}
function Af(n, e) {
    return hn(n.prev, n, n.next) < 0
        ? hn(n, e, n.next) >= 0 && hn(n, n.prev, e) >= 0
        : hn(n, e, n.prev) < 0 || hn(n, n.next, e) < 0;
}
function B4(n, e) {
    let t = n,
        i = !1;
    const r = (n.x + e.x) / 2,
        s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s &&
            t.next.y !== t.y &&
            r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
            (i = !i),
            (t = t.next);
    while (t !== n);
    return i;
}
function fb(n, e) {
    const t = new cy(n.i, n.x, n.y),
        i = new cy(e.i, e.x, e.y),
        r = n.next,
        s = e.prev;
    return (
        (n.next = e),
        (e.prev = n),
        (t.next = r),
        (r.prev = t),
        (i.next = t),
        (t.prev = i),
        (s.next = i),
        (i.prev = s),
        i
    );
}
function sE(n, e, t, i) {
    const r = new cy(n, e, t);
    return (
        i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
        r
    );
}
function Cf(n) {
    (n.next.prev = n.prev),
        (n.prev.next = n.next),
        n.prevZ && (n.prevZ.nextZ = n.nextZ),
        n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function cy(n, e, t) {
    (this.i = n),
        (this.x = e),
        (this.y = t),
        (this.prev = null),
        (this.next = null),
        (this.z = 0),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
}
function H4(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i) (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
    return r;
}
class hs {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * 0.5;
    }
    static isClockWise(e) {
        return hs.area(e) < 0;
    }
    static triangulateShape(e, t) {
        const i = [],
            r = [],
            s = [];
        oE(e), aE(i, e);
        let o = e.length;
        t.forEach(oE);
        for (let c = 0; c < t.length; c++) r.push(o), (o += t[c].length), aE(i, t[c]);
        const a = T4.triangulate(i, r);
        for (let c = 0; c < a.length; c += 3) s.push(a.slice(c, c + 3));
        return s;
    }
}
function oE(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function aE(n, e) {
    for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Wm extends bt {
    constructor(
        e = new Ua([new _e(0.5, 0.5), new _e(-0.5, 0.5), new _e(-0.5, -0.5), new _e(0.5, -0.5)]),
        t = {}
    ) {
        super(),
            (this.type = 'ExtrudeGeometry'),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
        const i = this,
            r = [],
            s = [];
        for (let a = 0, c = e.length; a < c; a++) {
            const f = e[a];
            o(f);
        }
        this.setAttribute('position', new nt(r, 3)),
            this.setAttribute('uv', new nt(s, 2)),
            this.computeVertexNormals();
        function o(a) {
            const c = [],
                f = t.curveSegments !== void 0 ? t.curveSegments : 12,
                d = t.steps !== void 0 ? t.steps : 1,
                h = t.depth !== void 0 ? t.depth : 1;
            let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
                _ = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1,
                w = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const g = t.extrudePath,
                S = t.UVGenerator !== void 0 ? t.UVGenerator : V4;
            let M,
                T = !1,
                P,
                A,
                R,
                D;
            g &&
                ((M = g.getSpacedPoints(d)),
                (T = !0),
                (p = !1),
                (P = g.computeFrenetFrames(d, !1)),
                (A = new k()),
                (R = new k()),
                (D = new k())),
                p || ((x = 0), (v = 0), (_ = 0), (w = 0));
            const G = a.extractPoints(f);
            let b = G.shape;
            const L = G.holes;
            if (!hs.isClockWise(b)) {
                b = b.reverse();
                for (let V = 0, we = L.length; V < we; V++) {
                    const ve = L[V];
                    hs.isClockWise(ve) && (L[V] = ve.reverse());
                }
            }
            const ie = hs.triangulateShape(b, L),
                j = b;
            for (let V = 0, we = L.length; V < we; V++) {
                const ve = L[V];
                b = b.concat(ve);
            }
            function oe(V, we, ve) {
                return (
                    we || console.error('THREE.ExtrudeGeometry: vec does not exist'),
                    V.clone().addScaledVector(we, ve)
                );
            }
            const te = b.length,
                ae = ie.length;
            function N(V, we, ve) {
                let Ee, ye, We;
                const He = V.x - we.x,
                    Ke = V.y - we.y,
                    yt = ve.x - V.x,
                    F = ve.y - V.y,
                    I = He * He + Ke * Ke,
                    ce = He * F - Ke * yt;
                if (Math.abs(ce) > Number.EPSILON) {
                    const de = Math.sqrt(I),
                        Me = Math.sqrt(yt * yt + F * F),
                        xe = we.x - Ke / de,
                        ut = we.y + He / de,
                        at = ve.x - F / Me,
                        Ae = ve.y + yt / Me,
                        Ie = ((at - xe) * F - (Ae - ut) * yt) / (He * F - Ke * yt);
                    (Ee = xe + He * Ie - V.x), (ye = ut + Ke * Ie - V.y);
                    const ht = Ee * Ee + ye * ye;
                    if (ht <= 2) return new _e(Ee, ye);
                    We = Math.sqrt(ht / 2);
                } else {
                    let de = !1;
                    He > Number.EPSILON
                        ? yt > Number.EPSILON && (de = !0)
                        : He < -Number.EPSILON
                        ? yt < -Number.EPSILON && (de = !0)
                        : Math.sign(Ke) === Math.sign(F) && (de = !0),
                        de
                            ? ((Ee = -Ke), (ye = He), (We = Math.sqrt(I)))
                            : ((Ee = He), (ye = Ke), (We = Math.sqrt(I / 2)));
                }
                return new _e(Ee / We, ye / We);
            }
            const B = [];
            for (let V = 0, we = j.length, ve = we - 1, Ee = V + 1; V < we; V++, ve++, Ee++)
                ve === we && (ve = 0), Ee === we && (Ee = 0), (B[V] = N(j[V], j[ve], j[Ee]));
            const H = [];
            let K,
                le = B.concat();
            for (let V = 0, we = L.length; V < we; V++) {
                const ve = L[V];
                K = [];
                for (
                    let Ee = 0, ye = ve.length, We = ye - 1, He = Ee + 1;
                    Ee < ye;
                    Ee++, We++, He++
                )
                    We === ye && (We = 0),
                        He === ye && (He = 0),
                        (K[Ee] = N(ve[Ee], ve[We], ve[He]));
                H.push(K), (le = le.concat(K));
            }
            for (let V = 0; V < x; V++) {
                const we = V / x,
                    ve = v * Math.cos((we * Math.PI) / 2),
                    Ee = _ * Math.sin((we * Math.PI) / 2) + w;
                for (let ye = 0, We = j.length; ye < We; ye++) {
                    const He = oe(j[ye], B[ye], Ee);
                    ke(He.x, He.y, -ve);
                }
                for (let ye = 0, We = L.length; ye < We; ye++) {
                    const He = L[ye];
                    K = H[ye];
                    for (let Ke = 0, yt = He.length; Ke < yt; Ke++) {
                        const F = oe(He[Ke], K[Ke], Ee);
                        ke(F.x, F.y, -ve);
                    }
                }
            }
            const be = _ + w;
            for (let V = 0; V < te; V++) {
                const we = p ? oe(b[V], le[V], be) : b[V];
                T
                    ? (R.copy(P.normals[0]).multiplyScalar(we.x),
                      A.copy(P.binormals[0]).multiplyScalar(we.y),
                      D.copy(M[0]).add(R).add(A),
                      ke(D.x, D.y, D.z))
                    : ke(we.x, we.y, 0);
            }
            for (let V = 1; V <= d; V++)
                for (let we = 0; we < te; we++) {
                    const ve = p ? oe(b[we], le[we], be) : b[we];
                    T
                        ? (R.copy(P.normals[V]).multiplyScalar(ve.x),
                          A.copy(P.binormals[V]).multiplyScalar(ve.y),
                          D.copy(M[V]).add(R).add(A),
                          ke(D.x, D.y, D.z))
                        : ke(ve.x, ve.y, (h / d) * V);
                }
            for (let V = x - 1; V >= 0; V--) {
                const we = V / x,
                    ve = v * Math.cos((we * Math.PI) / 2),
                    Ee = _ * Math.sin((we * Math.PI) / 2) + w;
                for (let ye = 0, We = j.length; ye < We; ye++) {
                    const He = oe(j[ye], B[ye], Ee);
                    ke(He.x, He.y, h + ve);
                }
                for (let ye = 0, We = L.length; ye < We; ye++) {
                    const He = L[ye];
                    K = H[ye];
                    for (let Ke = 0, yt = He.length; Ke < yt; Ke++) {
                        const F = oe(He[Ke], K[Ke], Ee);
                        T ? ke(F.x, F.y + M[d - 1].y, M[d - 1].x + ve) : ke(F.x, F.y, h + ve);
                    }
                }
            }
            Q(), me();
            function Q() {
                const V = r.length / 3;
                if (p) {
                    let we = 0,
                        ve = te * we;
                    for (let Ee = 0; Ee < ae; Ee++) {
                        const ye = ie[Ee];
                        et(ye[2] + ve, ye[1] + ve, ye[0] + ve);
                    }
                    (we = d + x * 2), (ve = te * we);
                    for (let Ee = 0; Ee < ae; Ee++) {
                        const ye = ie[Ee];
                        et(ye[0] + ve, ye[1] + ve, ye[2] + ve);
                    }
                } else {
                    for (let we = 0; we < ae; we++) {
                        const ve = ie[we];
                        et(ve[2], ve[1], ve[0]);
                    }
                    for (let we = 0; we < ae; we++) {
                        const ve = ie[we];
                        et(ve[0] + te * d, ve[1] + te * d, ve[2] + te * d);
                    }
                }
                i.addGroup(V, r.length / 3 - V, 0);
            }
            function me() {
                const V = r.length / 3;
                let we = 0;
                Se(j, we), (we += j.length);
                for (let ve = 0, Ee = L.length; ve < Ee; ve++) {
                    const ye = L[ve];
                    Se(ye, we), (we += ye.length);
                }
                i.addGroup(V, r.length / 3 - V, 1);
            }
            function Se(V, we) {
                let ve = V.length;
                for (; --ve >= 0; ) {
                    const Ee = ve;
                    let ye = ve - 1;
                    ye < 0 && (ye = V.length - 1);
                    for (let We = 0, He = d + x * 2; We < He; We++) {
                        const Ke = te * We,
                            yt = te * (We + 1),
                            F = we + Ee + Ke,
                            I = we + ye + Ke,
                            ce = we + ye + yt,
                            de = we + Ee + yt;
                        Xe(F, I, ce, de);
                    }
                }
            }
            function ke(V, we, ve) {
                c.push(V), c.push(we), c.push(ve);
            }
            function et(V, we, ve) {
                gt(V), gt(we), gt(ve);
                const Ee = r.length / 3,
                    ye = S.generateTopUV(i, r, Ee - 3, Ee - 2, Ee - 1);
                De(ye[0]), De(ye[1]), De(ye[2]);
            }
            function Xe(V, we, ve, Ee) {
                gt(V), gt(we), gt(Ee), gt(we), gt(ve), gt(Ee);
                const ye = r.length / 3,
                    We = S.generateSideWallUV(i, r, ye - 6, ye - 3, ye - 2, ye - 1);
                De(We[0]), De(We[1]), De(We[3]), De(We[1]), De(We[2]), De(We[3]);
            }
            function gt(V) {
                r.push(c[V * 3 + 0]), r.push(c[V * 3 + 1]), r.push(c[V * 3 + 2]);
            }
            function De(V) {
                s.push(V.x), s.push(V.y);
            }
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes,
            i = this.parameters.options;
        return G4(t, i, e);
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a);
        }
        const r = e.options.extrudePath;
        return (
            r !== void 0 && (e.options.extrudePath = new im[r.type]().fromJSON(r)),
            new Wm(i, e.options)
        );
    }
}
const V4 = {
    generateTopUV: function (n, e, t, i, r) {
        const s = e[t * 3],
            o = e[t * 3 + 1],
            a = e[i * 3],
            c = e[i * 3 + 1],
            f = e[r * 3],
            d = e[r * 3 + 1];
        return [new _e(s, o), new _e(a, c), new _e(f, d)];
    },
    generateSideWallUV: function (n, e, t, i, r, s) {
        const o = e[t * 3],
            a = e[t * 3 + 1],
            c = e[t * 3 + 2],
            f = e[i * 3],
            d = e[i * 3 + 1],
            h = e[i * 3 + 2],
            p = e[r * 3],
            v = e[r * 3 + 1],
            _ = e[r * 3 + 2],
            w = e[s * 3],
            x = e[s * 3 + 1],
            g = e[s * 3 + 2];
        return Math.abs(a - d) < Math.abs(o - f)
            ? [new _e(o, 1 - c), new _e(f, 1 - h), new _e(p, 1 - _), new _e(w, 1 - g)]
            : [new _e(a, 1 - c), new _e(d, 1 - h), new _e(v, 1 - _), new _e(x, 1 - g)];
    },
};
function G4(n, e, t) {
    if (((t.shapes = []), Array.isArray(n)))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid);
        }
    else t.shapes.push(n.uuid);
    return (
        (t.options = Object.assign({}, e)),
        e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
        t
    );
}
class jm extends Wo {
    constructor(e = 1, t = 0) {
        const i = (1 + Math.sqrt(5)) / 2,
            r = [
                -1,
                i,
                0,
                1,
                i,
                0,
                -1,
                -i,
                0,
                1,
                -i,
                0,
                0,
                -1,
                i,
                0,
                1,
                i,
                0,
                -1,
                -i,
                0,
                1,
                -i,
                i,
                0,
                -1,
                i,
                0,
                1,
                -i,
                0,
                -1,
                -i,
                0,
                1,
            ],
            s = [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10,
                7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2,
                10, 8, 6, 7, 9, 8, 1,
            ];
        super(r, s, e, t),
            (this.type = 'IcosahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new jm(e.radius, e.detail);
    }
}
class Xf extends Wo {
    constructor(e = 1, t = 0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
            (this.type = 'OctahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new Xf(e.radius, e.detail);
    }
}
class Xm extends bt {
    constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
        super(),
            (this.type = 'RingGeometry'),
            (this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: i,
                phiSegments: r,
                thetaStart: s,
                thetaLength: o,
            }),
            (i = Math.max(3, i)),
            (r = Math.max(1, r));
        const a = [],
            c = [],
            f = [],
            d = [];
        let h = e;
        const p = (t - e) / r,
            v = new k(),
            _ = new _e();
        for (let w = 0; w <= r; w++) {
            for (let x = 0; x <= i; x++) {
                const g = s + (x / i) * o;
                (v.x = h * Math.cos(g)),
                    (v.y = h * Math.sin(g)),
                    c.push(v.x, v.y, v.z),
                    f.push(0, 0, 1),
                    (_.x = (v.x / t + 1) / 2),
                    (_.y = (v.y / t + 1) / 2),
                    d.push(_.x, _.y);
            }
            h += p;
        }
        for (let w = 0; w < r; w++) {
            const x = w * (i + 1);
            for (let g = 0; g < i; g++) {
                const S = g + x,
                    M = S,
                    T = S + i + 1,
                    P = S + i + 2,
                    A = S + 1;
                a.push(M, T, A), a.push(T, P, A);
            }
        }
        this.setIndex(a),
            this.setAttribute('position', new nt(c, 3)),
            this.setAttribute('normal', new nt(f, 3)),
            this.setAttribute('uv', new nt(d, 2));
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Xm(
            e.innerRadius,
            e.outerRadius,
            e.thetaSegments,
            e.phiSegments,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Ym extends bt {
    constructor(e = new Ua([new _e(0, 0.5), new _e(-0.5, -0.5), new _e(0.5, -0.5)]), t = 12) {
        super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: e, curveSegments: t });
        const i = [],
            r = [],
            s = [],
            o = [];
        let a = 0,
            c = 0;
        if (Array.isArray(e) === !1) f(e);
        else for (let d = 0; d < e.length; d++) f(e[d]), this.addGroup(a, c, d), (a += c), (c = 0);
        this.setIndex(i),
            this.setAttribute('position', new nt(r, 3)),
            this.setAttribute('normal', new nt(s, 3)),
            this.setAttribute('uv', new nt(o, 2));
        function f(d) {
            const h = r.length / 3,
                p = d.extractPoints(t);
            let v = p.shape;
            const _ = p.holes;
            hs.isClockWise(v) === !1 && (v = v.reverse());
            for (let x = 0, g = _.length; x < g; x++) {
                const S = _[x];
                hs.isClockWise(S) === !0 && (_[x] = S.reverse());
            }
            const w = hs.triangulateShape(v, _);
            for (let x = 0, g = _.length; x < g; x++) {
                const S = _[x];
                v = v.concat(S);
            }
            for (let x = 0, g = v.length; x < g; x++) {
                const S = v[x];
                r.push(S.x, S.y, 0), s.push(0, 0, 1), o.push(S.x, S.y);
            }
            for (let x = 0, g = w.length; x < g; x++) {
                const S = w[x],
                    M = S[0] + h,
                    T = S[1] + h,
                    P = S[2] + h;
                i.push(M, T, P), (c += 3);
            }
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes;
        return W4(t, e);
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o);
        }
        return new Ym(i, e.curveSegments);
    }
}
function W4(n, e) {
    if (((e.shapes = []), Array.isArray(n)))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid);
        }
    else e.shapes.push(n.uuid);
    return e;
}
class Yf extends bt {
    constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
        super(),
            (this.type = 'SphereGeometry'),
            (this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: i,
                phiStart: r,
                phiLength: s,
                thetaStart: o,
                thetaLength: a,
            }),
            (t = Math.max(3, Math.floor(t))),
            (i = Math.max(2, Math.floor(i)));
        const c = Math.min(o + a, Math.PI);
        let f = 0;
        const d = [],
            h = new k(),
            p = new k(),
            v = [],
            _ = [],
            w = [],
            x = [];
        for (let g = 0; g <= i; g++) {
            const S = [],
                M = g / i;
            let T = 0;
            g === 0 && o === 0 ? (T = 0.5 / t) : g === i && c === Math.PI && (T = -0.5 / t);
            for (let P = 0; P <= t; P++) {
                const A = P / t;
                (h.x = -e * Math.cos(r + A * s) * Math.sin(o + M * a)),
                    (h.y = e * Math.cos(o + M * a)),
                    (h.z = e * Math.sin(r + A * s) * Math.sin(o + M * a)),
                    _.push(h.x, h.y, h.z),
                    p.copy(h).normalize(),
                    w.push(p.x, p.y, p.z),
                    x.push(A + T, 1 - M),
                    S.push(f++);
            }
            d.push(S);
        }
        for (let g = 0; g < i; g++)
            for (let S = 0; S < t; S++) {
                const M = d[g][S + 1],
                    T = d[g][S],
                    P = d[g + 1][S],
                    A = d[g + 1][S + 1];
                (g !== 0 || o > 0) && v.push(M, T, A),
                    (g !== i - 1 || c < Math.PI) && v.push(T, P, A);
            }
        this.setIndex(v),
            this.setAttribute('position', new nt(_, 3)),
            this.setAttribute('normal', new nt(w, 3)),
            this.setAttribute('uv', new nt(x, 2));
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Yf(
            e.radius,
            e.widthSegments,
            e.heightSegments,
            e.phiStart,
            e.phiLength,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class qm extends Wo {
    constructor(e = 1, t = 0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
            (this.type = 'TetrahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new qm(e.radius, e.detail);
    }
}
class Zm extends bt {
    constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
        super(),
            (this.type = 'TorusGeometry'),
            (this.parameters = {
                radius: e,
                tube: t,
                radialSegments: i,
                tubularSegments: r,
                arc: s,
            }),
            (i = Math.floor(i)),
            (r = Math.floor(r));
        const o = [],
            a = [],
            c = [],
            f = [],
            d = new k(),
            h = new k(),
            p = new k();
        for (let v = 0; v <= i; v++)
            for (let _ = 0; _ <= r; _++) {
                const w = (_ / r) * s,
                    x = (v / i) * Math.PI * 2;
                (h.x = (e + t * Math.cos(x)) * Math.cos(w)),
                    (h.y = (e + t * Math.cos(x)) * Math.sin(w)),
                    (h.z = t * Math.sin(x)),
                    a.push(h.x, h.y, h.z),
                    (d.x = e * Math.cos(w)),
                    (d.y = e * Math.sin(w)),
                    p.subVectors(h, d).normalize(),
                    c.push(p.x, p.y, p.z),
                    f.push(_ / r),
                    f.push(v / i);
            }
        for (let v = 1; v <= i; v++)
            for (let _ = 1; _ <= r; _++) {
                const w = (r + 1) * v + _ - 1,
                    x = (r + 1) * (v - 1) + _ - 1,
                    g = (r + 1) * (v - 1) + _,
                    S = (r + 1) * v + _;
                o.push(w, x, S), o.push(x, g, S);
            }
        this.setIndex(o),
            this.setAttribute('position', new nt(a, 3)),
            this.setAttribute('normal', new nt(c, 3)),
            this.setAttribute('uv', new nt(f, 2));
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Zm(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
    }
}
class Km extends bt {
    constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
        super(),
            (this.type = 'TorusKnotGeometry'),
            (this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: i,
                radialSegments: r,
                p: s,
                q: o,
            }),
            (i = Math.floor(i)),
            (r = Math.floor(r));
        const a = [],
            c = [],
            f = [],
            d = [],
            h = new k(),
            p = new k(),
            v = new k(),
            _ = new k(),
            w = new k(),
            x = new k(),
            g = new k();
        for (let M = 0; M <= i; ++M) {
            const T = (M / i) * s * Math.PI * 2;
            S(T, s, o, e, v),
                S(T + 0.01, s, o, e, _),
                x.subVectors(_, v),
                g.addVectors(_, v),
                w.crossVectors(x, g),
                g.crossVectors(w, x),
                w.normalize(),
                g.normalize();
            for (let P = 0; P <= r; ++P) {
                const A = (P / r) * Math.PI * 2,
                    R = -t * Math.cos(A),
                    D = t * Math.sin(A);
                (h.x = v.x + (R * g.x + D * w.x)),
                    (h.y = v.y + (R * g.y + D * w.y)),
                    (h.z = v.z + (R * g.z + D * w.z)),
                    c.push(h.x, h.y, h.z),
                    p.subVectors(h, v).normalize(),
                    f.push(p.x, p.y, p.z),
                    d.push(M / i),
                    d.push(P / r);
            }
        }
        for (let M = 1; M <= i; M++)
            for (let T = 1; T <= r; T++) {
                const P = (r + 1) * (M - 1) + (T - 1),
                    A = (r + 1) * M + (T - 1),
                    R = (r + 1) * M + T,
                    D = (r + 1) * (M - 1) + T;
                a.push(P, A, D), a.push(A, R, D);
            }
        this.setIndex(a),
            this.setAttribute('position', new nt(c, 3)),
            this.setAttribute('normal', new nt(f, 3)),
            this.setAttribute('uv', new nt(d, 2));
        function S(M, T, P, A, R) {
            const D = Math.cos(M),
                G = Math.sin(M),
                b = (P / T) * M,
                L = Math.cos(b);
            (R.x = A * (2 + L) * 0.5 * D),
                (R.y = A * (2 + L) * G * 0.5),
                (R.z = A * Math.sin(b) * 0.5);
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    static fromJSON(e) {
        return new Km(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
    }
}
class Jm extends bt {
    constructor(
        e = new Xx(new k(-1, -1, 0), new k(-1, 1, 0), new k(1, 1, 0)),
        t = 64,
        i = 1,
        r = 8,
        s = !1
    ) {
        super(),
            (this.type = 'TubeGeometry'),
            (this.parameters = {
                path: e,
                tubularSegments: t,
                radius: i,
                radialSegments: r,
                closed: s,
            });
        const o = e.computeFrenetFrames(t, s);
        (this.tangents = o.tangents), (this.normals = o.normals), (this.binormals = o.binormals);
        const a = new k(),
            c = new k(),
            f = new _e();
        let d = new k();
        const h = [],
            p = [],
            v = [],
            _ = [];
        w(),
            this.setIndex(_),
            this.setAttribute('position', new nt(h, 3)),
            this.setAttribute('normal', new nt(p, 3)),
            this.setAttribute('uv', new nt(v, 2));
        function w() {
            for (let M = 0; M < t; M++) x(M);
            x(s === !1 ? t : 0), S(), g();
        }
        function x(M) {
            d = e.getPointAt(M / t, d);
            const T = o.normals[M],
                P = o.binormals[M];
            for (let A = 0; A <= r; A++) {
                const R = (A / r) * Math.PI * 2,
                    D = Math.sin(R),
                    G = -Math.cos(R);
                (c.x = G * T.x + D * P.x),
                    (c.y = G * T.y + D * P.y),
                    (c.z = G * T.z + D * P.z),
                    c.normalize(),
                    p.push(c.x, c.y, c.z),
                    (a.x = d.x + i * c.x),
                    (a.y = d.y + i * c.y),
                    (a.z = d.z + i * c.z),
                    h.push(a.x, a.y, a.z);
            }
        }
        function g() {
            for (let M = 1; M <= t; M++)
                for (let T = 1; T <= r; T++) {
                    const P = (r + 1) * (M - 1) + (T - 1),
                        A = (r + 1) * M + (T - 1),
                        R = (r + 1) * M + T,
                        D = (r + 1) * (M - 1) + T;
                    _.push(P, A, D), _.push(A, R, D);
                }
        }
        function S() {
            for (let M = 0; M <= t; M++)
                for (let T = 0; T <= r; T++) (f.x = M / t), (f.y = T / r), v.push(f.x, f.y);
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.path = this.parameters.path.toJSON()), e;
    }
    static fromJSON(e) {
        return new Jm(
            new im[e.path.type]().fromJSON(e.path),
            e.tubularSegments,
            e.radius,
            e.radialSegments,
            e.closed
        );
    }
}
class db extends bt {
    constructor(e = null) {
        if (
            (super(),
            (this.type = 'WireframeGeometry'),
            (this.parameters = { geometry: e }),
            e !== null)
        ) {
            const t = [],
                i = new Set(),
                r = new k(),
                s = new k();
            if (e.index !== null) {
                const o = e.attributes.position,
                    a = e.index;
                let c = e.groups;
                c.length === 0 && (c = [{ start: 0, count: a.count, materialIndex: 0 }]);
                for (let f = 0, d = c.length; f < d; ++f) {
                    const h = c[f],
                        p = h.start,
                        v = h.count;
                    for (let _ = p, w = p + v; _ < w; _ += 3)
                        for (let x = 0; x < 3; x++) {
                            const g = a.getX(_ + x),
                                S = a.getX(_ + ((x + 1) % 3));
                            r.fromBufferAttribute(o, g),
                                s.fromBufferAttribute(o, S),
                                lE(r, s, i) === !0 &&
                                    (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, c = o.count / 3; a < c; a++)
                    for (let f = 0; f < 3; f++) {
                        const d = 3 * a + f,
                            h = 3 * a + ((f + 1) % 3);
                        r.fromBufferAttribute(o, d),
                            s.fromBufferAttribute(o, h),
                            lE(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
                    }
            }
            this.setAttribute('position', new nt(t, 3));
        }
    }
    copy(e) {
        return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
    }
}
function lE(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
        r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var uE = Object.freeze({
    __proto__: null,
    BoxGeometry: Ya,
    CapsuleGeometry: zm,
    CircleGeometry: Bm,
    ConeGeometry: Hm,
    CylinderGeometry: Lu,
    DodecahedronGeometry: Vm,
    EdgesGeometry: lb,
    ExtrudeGeometry: Wm,
    IcosahedronGeometry: jm,
    LatheGeometry: jf,
    OctahedronGeometry: Xf,
    PlaneGeometry: Ru,
    PolyhedronGeometry: Wo,
    RingGeometry: Xm,
    ShapeGeometry: Ym,
    SphereGeometry: Yf,
    TetrahedronGeometry: qm,
    TorusGeometry: Zm,
    TorusKnotGeometry: Km,
    TubeGeometry: Jm,
    WireframeGeometry: db,
});
class hb extends ii {
    constructor(e) {
        super(),
            (this.isShadowMaterial = !0),
            (this.type = 'ShadowMaterial'),
            (this.color = new je(0)),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
    }
}
class pb extends Gr {
    constructor(e) {
        super(e), (this.isRawShaderMaterial = !0), (this.type = 'RawShaderMaterial');
    }
}
class qx extends ii {
    constructor(e) {
        super(),
            (this.isMeshStandardMaterial = !0),
            (this.defines = { STANDARD: '' }),
            (this.type = 'MeshStandardMaterial'),
            (this.color = new je(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new je(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Vo),
            (this.normalScale = new _e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new nr()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { STANDARD: '' }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class mb extends qx {
    constructor(e) {
        super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.type = 'MeshPhysicalMaterial'),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new _e(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, 'reflectivity', {
                get: function () {
                    return wn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                    this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new je(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new je(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new je(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(e);
    }
    get anisotropy() {
        return this._anisotropy;
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
    }
    get iridescence() {
        return this._iridescence;
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
    }
    get sheen() {
        return this._sheen;
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.anisotropy = e.anisotropy),
            (this.anisotropyRotation = e.anisotropyRotation),
            (this.anisotropyMap = e.anisotropyMap),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.ior = e.ior),
            (this.iridescence = e.iridescence),
            (this.iridescenceMap = e.iridescenceMap),
            (this.iridescenceIOR = e.iridescenceIOR),
            (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
        );
    }
}
class gb extends ii {
    constructor(e) {
        super(),
            (this.isMeshPhongMaterial = !0),
            (this.type = 'MeshPhongMaterial'),
            (this.color = new je(16777215)),
            (this.specular = new je(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new je(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Vo),
            (this.normalScale = new _e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new nr()),
            (this.combine = zf),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class vb extends ii {
    constructor(e) {
        super(),
            (this.isMeshToonMaterial = !0),
            (this.defines = { TOON: '' }),
            (this.type = 'MeshToonMaterial'),
            (this.color = new je(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new je(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Vo),
            (this.normalScale = new _e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
        );
    }
}
class _b extends ii {
    constructor(e) {
        super(),
            (this.isMeshNormalMaterial = !0),
            (this.type = 'MeshNormalMaterial'),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Vo),
            (this.normalScale = new _e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.flatShading = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
        );
    }
}
class yb extends ii {
    constructor(e) {
        super(),
            (this.isMeshLambertMaterial = !0),
            (this.type = 'MeshLambertMaterial'),
            (this.color = new je(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new je(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Vo),
            (this.normalScale = new _e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new nr()),
            (this.combine = zf),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class xb extends ii {
    constructor(e) {
        super(),
            (this.isMeshMatcapMaterial = !0),
            (this.defines = { MATCAP: '' }),
            (this.type = 'MeshMatcapMaterial'),
            (this.color = new je(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Vo),
            (this.normalScale = new _e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { MATCAP: '' }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class Sb extends Pi {
    constructor(e) {
        super(),
            (this.isLineDashedMaterial = !0),
            (this.type = 'LineDashedMaterial'),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
        );
    }
}
function Ca(n, e, t) {
    return !n || (!t && n.constructor === e)
        ? n
        : typeof e.BYTES_PER_ELEMENT == 'number'
        ? new e(n)
        : Array.prototype.slice.call(n);
}
function Mb(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function wb(n) {
    function e(r, s) {
        return n[r] - n[s];
    }
    const t = n.length,
        i = new Array(t);
    for (let r = 0; r !== t; ++r) i[r] = r;
    return i.sort(e), i;
}
function fy(n, e, t) {
    const i = n.length,
        r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let c = 0; c !== e; ++c) r[o++] = n[a + c];
    }
    return r;
}
function Zx(n, e, t, i) {
    let r = 1,
        s = n[0];
    for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
    if (s === void 0) return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do (o = s[i]), o !== void 0 && (e.push(s.time), t.push.apply(t, o)), (s = n[r++]);
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do (o = s[i]), o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), (s = n[r++]);
            while (s !== void 0);
        else
            do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
            while (s !== void 0);
}
function j4(n, e, t, i, r = 30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let c = 0; c < s.tracks.length; ++c) {
        const f = s.tracks[c],
            d = f.getValueSize(),
            h = [],
            p = [];
        for (let v = 0; v < f.times.length; ++v) {
            const _ = f.times[v] * r;
            if (!(_ < t || _ >= i)) {
                h.push(f.times[v]);
                for (let w = 0; w < d; ++w) p.push(f.values[v * d + w]);
            }
        }
        h.length !== 0 &&
            ((f.times = Ca(h, f.times.constructor)),
            (f.values = Ca(p, f.values.constructor)),
            o.push(f));
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let c = 0; c < s.tracks.length; ++c)
        a > s.tracks[c].times[0] && (a = s.tracks[c].times[0]);
    for (let c = 0; c < s.tracks.length; ++c) s.tracks[c].shift(-1 * a);
    return s.resetDuration(), s;
}
function X4(n, e = 0, t = n, i = 30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length,
        s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o],
            c = a.ValueTypeName;
        if (c === 'bool' || c === 'string') continue;
        const f = n.tracks.find(function (g) {
            return g.name === a.name && g.ValueTypeName === c;
        });
        if (f === void 0) continue;
        let d = 0;
        const h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3);
        let p = 0;
        const v = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = v / 3);
        const _ = a.times.length - 1;
        let w;
        if (s <= a.times[0]) {
            const g = d,
                S = h - d;
            w = a.values.slice(g, S);
        } else if (s >= a.times[_]) {
            const g = _ * h + d,
                S = g + h - d;
            w = a.values.slice(g, S);
        } else {
            const g = a.createInterpolant(),
                S = d,
                M = h - d;
            g.evaluate(s), (w = g.resultBuffer.slice(S, M));
        }
        c === 'quaternion' && new Bi().fromArray(w).normalize().conjugate().toArray(w);
        const x = f.times.length;
        for (let g = 0; g < x; ++g) {
            const S = g * v + p;
            if (c === 'quaternion') Bi.multiplyQuaternionsFlat(f.values, S, w, 0, f.values, S);
            else {
                const M = v - p * 2;
                for (let T = 0; T < M; ++T) f.values[S + T] -= w[T];
            }
        }
    }
    return (n.blendMode = Cx), n;
}
const Y4 = {
    convertArray: Ca,
    isTypedArray: Mb,
    getKeyframeOrder: wb,
    sortedArray: fy,
    flattenJSON: Zx,
    subclip: j4,
    makeClipAdditive: X4,
};
class qf {
    constructor(e, t, i, r) {
        (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
            (this.sampleValues = t),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {});
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex,
            r = t[i],
            s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s) break i;
                                return (
                                    (i = t.length),
                                    (this._cachedIndex = i),
                                    this.copySampleValue_(i - 1)
                                );
                            }
                            if (i === a) break;
                            if (((s = r), (r = t[++i]), e < r)) break t;
                        }
                        o = t.length;
                        break n;
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && ((i = 2), (s = a));
                        for (let c = i - 2; ; ) {
                            if (s === void 0)
                                return (this._cachedIndex = 0), this.copySampleValue_(0);
                            if (i === c) break;
                            if (((r = s), (s = t[--i - 1]), e >= s)) break t;
                        }
                        (o = i), (i = 0);
                        break n;
                    }
                    break e;
                }
                for (; i < o; ) {
                    const a = (i + o) >>> 1;
                    e < t[a] ? (o = a) : (i = a + 1);
                }
                if (((r = t[i]), (s = t[i - 1]), s === void 0))
                    return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (r === void 0)
                    return (i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1);
            }
            (this._cachedIndex = i), this.intervalChanged_(i, s, r);
        }
        return this.interpolate_(i, s, e, r);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r;
        for (let o = 0; o !== r; ++o) t[o] = i[s + o];
        return t;
    }
    interpolate_() {
        throw new Error('call to abstract method');
    }
    intervalChanged_() {}
}
class Eb extends qf {
    constructor(e, t, i, r) {
        super(e, t, i, r),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Ea, endingEnd: Ea });
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2,
            o = e + 1,
            a = r[s],
            c = r[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
                case Ta:
                    (s = e), (a = 2 * t - i);
                    break;
                case vf:
                    (s = r.length - 2), (a = t + r[s] - r[s + 1]);
                    break;
                default:
                    (s = e), (a = i);
            }
        if (c === void 0)
            switch (this.getSettings_().endingEnd) {
                case Ta:
                    (o = e), (c = 2 * i - t);
                    break;
                case vf:
                    (o = 1), (c = i + r[1] - r[0]);
                    break;
                default:
                    (o = e - 1), (c = t);
            }
        const f = (i - t) * 0.5,
            d = this.valueSize;
        (this._weightPrev = f / (t - a)),
            (this._weightNext = f / (c - i)),
            (this._offsetPrev = s * d),
            (this._offsetNext = o * d);
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            c = e * a,
            f = c - a,
            d = this._offsetPrev,
            h = this._offsetNext,
            p = this._weightPrev,
            v = this._weightNext,
            _ = (i - t) / (r - t),
            w = _ * _,
            x = w * _,
            g = -p * x + 2 * p * w - p * _,
            S = (1 + p) * x + (-1.5 - 2 * p) * w + (-0.5 + p) * _ + 1,
            M = (-1 - v) * x + (1.5 + v) * w + 0.5 * _,
            T = v * x - v * w;
        for (let P = 0; P !== a; ++P)
            s[P] = g * o[d + P] + S * o[f + P] + M * o[c + P] + T * o[h + P];
        return s;
    }
}
class Kx extends qf {
    constructor(e, t, i, r) {
        super(e, t, i, r);
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            c = e * a,
            f = c - a,
            d = (i - t) / (r - t),
            h = 1 - d;
        for (let p = 0; p !== a; ++p) s[p] = o[f + p] * h + o[c + p] * d;
        return s;
    }
}
class Tb extends qf {
    constructor(e, t, i, r) {
        super(e, t, i, r);
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1);
    }
}
class Xr {
    constructor(e, t, i, r) {
        if (e === void 0) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (t === void 0 || t.length === 0)
            throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
        (this.name = e),
            (this.times = Ca(t, this.TimeBufferType)),
            (this.values = Ca(i, this.ValueBufferType)),
            this.setInterpolation(r || this.DefaultInterpolation);
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
            i = { name: e.name, times: Ca(e.times, Array), values: Ca(e.values, Array) };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r);
        }
        return (i.type = e.ValueTypeName), i;
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new Tb(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
        return new Kx(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Eb(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
        let t;
        switch (e) {
            case mf:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case gf:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case Mp:
                t = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (t === void 0) {
            const i =
                'unsupported interpolation for ' +
                this.ValueTypeName +
                ' keyframe track named ' +
                this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(i);
            return console.warn('THREE.KeyframeTrack:', i), this;
        }
        return (this.createInterpolant = t), this;
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return mf;
            case this.InterpolantFactoryMethodLinear:
                return gf;
            case this.InterpolantFactoryMethodSmooth:
                return Mp;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
        }
        return this;
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
        }
        return this;
    }
    trim(e, t) {
        const i = this.times,
            r = i.length;
        let s = 0,
            o = r - 1;
        for (; s !== r && i[s] < e; ) ++s;
        for (; o !== -1 && i[o] > t; ) --o;
        if ((++o, s !== 0 || o !== r)) {
            s >= o && ((o = Math.max(o, 1)), (s = o - 1));
            const a = this.getValueSize();
            (this.times = i.slice(s, o)), (this.values = this.values.slice(s * a, o * a));
        }
        return this;
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 &&
            (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (e = !1));
        const i = this.times,
            r = this.values,
            s = i.length;
        s === 0 && (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1));
        let o = null;
        for (let a = 0; a !== s; a++) {
            const c = i[a];
            if (typeof c == 'number' && isNaN(c)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, a, c),
                    (e = !1);
                break;
            }
            if (o !== null && o > c) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, a, c, o), (e = !1);
                break;
            }
            o = c;
        }
        if (r !== void 0 && Mb(r))
            for (let a = 0, c = r.length; a !== c; ++a) {
                const f = r[a];
                if (isNaN(f)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, a, f),
                        (e = !1);
                    break;
                }
            }
        return e;
    }
    optimize() {
        const e = this.times.slice(),
            t = this.values.slice(),
            i = this.getValueSize(),
            r = this.getInterpolation() === Mp,
            s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let c = !1;
            const f = e[a],
                d = e[a + 1];
            if (f !== d && (a !== 1 || f !== e[0]))
                if (r) c = !0;
                else {
                    const h = a * i,
                        p = h - i,
                        v = h + i;
                    for (let _ = 0; _ !== i; ++_) {
                        const w = t[h + _];
                        if (w !== t[p + _] || w !== t[v + _]) {
                            c = !0;
                            break;
                        }
                    }
                }
            if (c) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i,
                        p = o * i;
                    for (let v = 0; v !== i; ++v) t[p + v] = t[h + v];
                }
                ++o;
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, c = o * i, f = 0; f !== i; ++f) t[c + f] = t[a + f];
            ++o;
        }
        return (
            o !== e.length
                ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
                : ((this.times = e), (this.values = t)),
            this
        );
    }
    clone() {
        const e = this.times.slice(),
            t = this.values.slice(),
            i = this.constructor,
            r = new i(this.name, e, t);
        return (r.createInterpolant = this.createInterpolant), r;
    }
}
Xr.prototype.TimeBufferType = Float32Array;
Xr.prototype.ValueBufferType = Float32Array;
Xr.prototype.DefaultInterpolation = gf;
class qa extends Xr {}
qa.prototype.ValueTypeName = 'bool';
qa.prototype.ValueBufferType = Array;
qa.prototype.DefaultInterpolation = mf;
qa.prototype.InterpolantFactoryMethodLinear = void 0;
qa.prototype.InterpolantFactoryMethodSmooth = void 0;
class Jx extends Xr {}
Jx.prototype.ValueTypeName = 'color';
class bf extends Xr {}
bf.prototype.ValueTypeName = 'number';
class Ab extends qf {
    constructor(e, t, i, r) {
        super(e, t, i, r);
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            c = (i - t) / (r - t);
        let f = e * a;
        for (let d = f + a; f !== d; f += 4) Bi.slerpFlat(s, 0, o, f - a, o, f, c);
        return s;
    }
}
class Iu extends Xr {
    InterpolantFactoryMethodLinear(e) {
        return new Ab(this.times, this.values, this.getValueSize(), e);
    }
}
Iu.prototype.ValueTypeName = 'quaternion';
Iu.prototype.DefaultInterpolation = gf;
Iu.prototype.InterpolantFactoryMethodSmooth = void 0;
class Za extends Xr {}
Za.prototype.ValueTypeName = 'string';
Za.prototype.ValueBufferType = Array;
Za.prototype.DefaultInterpolation = mf;
Za.prototype.InterpolantFactoryMethodLinear = void 0;
Za.prototype.InterpolantFactoryMethodSmooth = void 0;
class Rf extends Xr {}
Rf.prototype.ValueTypeName = 'vector';
class Pf {
    constructor(e, t = -1, i, r = Rm) {
        (this.name = e),
            (this.tracks = i),
            (this.duration = t),
            (this.blendMode = r),
            (this.uuid = er()),
            this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
        const t = [],
            i = e.tracks,
            r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o) t.push(Z4(i[o]).scale(r));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return (s.uuid = e.uuid), s;
    }
    static toJSON(e) {
        const t = [],
            i = e.tracks,
            r = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode,
            };
        for (let s = 0, o = i.length; s !== o; ++s) t.push(Xr.toJSON(i[s]));
        return r;
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let c = [],
                f = [];
            c.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0);
            const d = wb(c);
            (c = fy(c, 1, d)),
                (f = fy(f, 1, d)),
                !r && c[0] === 0 && (c.push(s), f.push(f[0])),
                o.push(new bf('.morphTargetInfluences[' + t[a].name + ']', c, f).scale(1 / i));
        }
        return new this(e, -1, o);
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = (r.geometry && r.geometry.animations) || r.animations;
        }
        for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
        return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, c = e.length; a < c; a++) {
            const f = e[a],
                d = f.name.match(s);
            if (d && d.length > 1) {
                const h = d[1];
                let p = r[h];
                p || (r[h] = p = []), p.push(f);
            }
        }
        const o = [];
        for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o;
    }
    static parseAnimation(e, t) {
        if (!e) return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null;
        const i = function (h, p, v, _, w) {
                if (v.length !== 0) {
                    const x = [],
                        g = [];
                    Zx(v, x, g, _), x.length !== 0 && w.push(new h(p, x, g));
                }
            },
            r = [],
            s = e.name || 'default',
            o = e.fps || 30,
            a = e.blendMode;
        let c = e.length || -1;
        const f = e.hierarchy || [];
        for (let h = 0; h < f.length; h++) {
            const p = f[h].keys;
            if (!(!p || p.length === 0))
                if (p[0].morphTargets) {
                    const v = {};
                    let _;
                    for (_ = 0; _ < p.length; _++)
                        if (p[_].morphTargets)
                            for (let w = 0; w < p[_].morphTargets.length; w++)
                                v[p[_].morphTargets[w]] = -1;
                    for (const w in v) {
                        const x = [],
                            g = [];
                        for (let S = 0; S !== p[_].morphTargets.length; ++S) {
                            const M = p[_];
                            x.push(M.time), g.push(M.morphTarget === w ? 1 : 0);
                        }
                        r.push(new bf('.morphTargetInfluence[' + w + ']', x, g));
                    }
                    c = v.length * o;
                } else {
                    const v = '.bones[' + t[h].name + ']';
                    i(Rf, v + '.position', p, 'pos', r),
                        i(Iu, v + '.quaternion', p, 'rot', r),
                        i(Rf, v + '.scale', p, 'scl', r);
                }
        }
        return r.length === 0 ? null : new this(s, c, r, a);
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1]);
        }
        return (this.duration = t), this;
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this;
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e;
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
}
function q4(n) {
    switch (n.toLowerCase()) {
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return bf;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return Rf;
        case 'color':
            return Jx;
        case 'quaternion':
            return Iu;
        case 'bool':
        case 'boolean':
            return qa;
        case 'string':
            return Za;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + n);
}
function Z4(n) {
    if (n.type === void 0)
        throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const e = q4(n.type);
    if (n.times === void 0) {
        const t = [],
            i = [];
        Zx(n.keys, t, i, 'value'), (n.times = t), (n.values = i);
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const Us = {
    enabled: !1,
    files: {},
    add: function (n, e) {
        this.enabled !== !1 && (this.files[n] = e);
    },
    get: function (n) {
        if (this.enabled !== !1) return this.files[n];
    },
    remove: function (n) {
        delete this.files[n];
    },
    clear: function () {
        this.files = {};
    },
};
class Qx {
    constructor(e, t, i) {
        const r = this;
        let s = !1,
            o = 0,
            a = 0,
            c;
        const f = [];
        (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = i),
            (this.itemStart = function (d) {
                a++, s === !1 && r.onStart !== void 0 && r.onStart(d, o, a), (s = !0);
            }),
            (this.itemEnd = function (d) {
                o++,
                    r.onProgress !== void 0 && r.onProgress(d, o, a),
                    o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
            }),
            (this.itemError = function (d) {
                r.onError !== void 0 && r.onError(d);
            }),
            (this.resolveURL = function (d) {
                return c ? c(d) : d;
            }),
            (this.setURLModifier = function (d) {
                return (c = d), this;
            }),
            (this.addHandler = function (d, h) {
                return f.push(d, h), this;
            }),
            (this.removeHandler = function (d) {
                const h = f.indexOf(d);
                return h !== -1 && f.splice(h, 2), this;
            }),
            (this.getHandler = function (d) {
                for (let h = 0, p = f.length; h < p; h += 2) {
                    const v = f[h],
                        _ = f[h + 1];
                    if ((v.global && (v.lastIndex = 0), v.test(d))) return _;
                }
                return null;
            });
    }
}
const Cb = new Qx();
class Hi {
    constructor(e) {
        (this.manager = e !== void 0 ? e : Cb),
            (this.crossOrigin = 'anonymous'),
            (this.withCredentials = !1),
            (this.path = ''),
            (this.resourcePath = ''),
            (this.requestHeader = {});
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function (r, s) {
            i.load(e, r, t, s);
        });
    }
    parse() {}
    setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
    }
    setWithCredentials(e) {
        return (this.withCredentials = e), this;
    }
    setPath(e) {
        return (this.path = e), this;
    }
    setResourcePath(e) {
        return (this.resourcePath = e), this;
    }
    setRequestHeader(e) {
        return (this.requestHeader = e), this;
    }
}
Hi.DEFAULT_MATERIAL_NAME = '__DEFAULT';
const Cs = {};
class K4 extends Error {
    constructor(e, t) {
        super(e), (this.response = t);
    }
}
class js extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        e === void 0 && (e = ''),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
        const s = Us.get(e);
        if (s !== void 0)
            return (
                this.manager.itemStart(e),
                setTimeout(() => {
                    t && t(s), this.manager.itemEnd(e);
                }, 0),
                s
            );
        if (Cs[e] !== void 0) {
            Cs[e].push({ onLoad: t, onProgress: i, onError: r });
            return;
        }
        (Cs[e] = []), Cs[e].push({ onLoad: t, onProgress: i, onError: r });
        const o = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? 'include' : 'same-origin',
            }),
            a = this.mimeType,
            c = this.responseType;
        fetch(o)
            .then((f) => {
                if (f.status === 200 || f.status === 0) {
                    if (
                        (f.status === 0 &&
                            console.warn('THREE.FileLoader: HTTP Status 0 received.'),
                        typeof ReadableStream > 'u' ||
                            f.body === void 0 ||
                            f.body.getReader === void 0)
                    )
                        return f;
                    const d = Cs[e],
                        h = f.body.getReader(),
                        p = f.headers.get('Content-Length') || f.headers.get('X-File-Size'),
                        v = p ? parseInt(p) : 0,
                        _ = v !== 0;
                    let w = 0;
                    const x = new ReadableStream({
                        start(g) {
                            S();
                            function S() {
                                h.read().then(({ done: M, value: T }) => {
                                    if (M) g.close();
                                    else {
                                        w += T.byteLength;
                                        const P = new ProgressEvent('progress', {
                                            lengthComputable: _,
                                            loaded: w,
                                            total: v,
                                        });
                                        for (let A = 0, R = d.length; A < R; A++) {
                                            const D = d[A];
                                            D.onProgress && D.onProgress(P);
                                        }
                                        g.enqueue(T), S();
                                    }
                                });
                            }
                        },
                    });
                    return new Response(x);
                } else
                    throw new K4(
                        `fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,
                        f
                    );
            })
            .then((f) => {
                switch (c) {
                    case 'arraybuffer':
                        return f.arrayBuffer();
                    case 'blob':
                        return f.blob();
                    case 'document':
                        return f.text().then((d) => new DOMParser().parseFromString(d, a));
                    case 'json':
                        return f.json();
                    default:
                        if (a === void 0) return f.text();
                        {
                            const h = /charset="?([^;"\s]*)"?/i.exec(a),
                                p = h && h[1] ? h[1].toLowerCase() : void 0,
                                v = new TextDecoder(p);
                            return f.arrayBuffer().then((_) => v.decode(_));
                        }
                }
            })
            .then((f) => {
                Us.add(e, f);
                const d = Cs[e];
                delete Cs[e];
                for (let h = 0, p = d.length; h < p; h++) {
                    const v = d[h];
                    v.onLoad && v.onLoad(f);
                }
            })
            .catch((f) => {
                const d = Cs[e];
                if (d === void 0) throw (this.manager.itemError(e), f);
                delete Cs[e];
                for (let h = 0, p = d.length; h < p; h++) {
                    const v = d[h];
                    v.onError && v.onError(f);
                }
                this.manager.itemError(e);
            })
            .finally(() => {
                this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
    }
    setResponseType(e) {
        return (this.responseType = e), this;
    }
    setMimeType(e) {
        return (this.mimeType = e), this;
    }
}
class J4 extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = this,
            o = new js(this.manager);
        o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
                e,
                function (a) {
                    try {
                        t(s.parse(JSON.parse(a)));
                    } catch (c) {
                        r ? r(c) : console.error(c), s.manager.itemError(e);
                    }
                },
                i,
                r
            );
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = Pf.parse(e[i]);
            t.push(r);
        }
        return t;
    }
}
class Q4 extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = this,
            o = [],
            a = new Fm(),
            c = new js(this.manager);
        c.setPath(this.path),
            c.setResponseType('arraybuffer'),
            c.setRequestHeader(this.requestHeader),
            c.setWithCredentials(s.withCredentials);
        let f = 0;
        function d(h) {
            c.load(
                e[h],
                function (p) {
                    const v = s.parse(p, !0);
                    (o[h] = {
                        width: v.width,
                        height: v.height,
                        format: v.format,
                        mipmaps: v.mipmaps,
                    }),
                        (f += 1),
                        f === 6 &&
                            (v.mipmapCount === 1 && (a.minFilter = dn),
                            (a.image = o),
                            (a.format = v.format),
                            (a.needsUpdate = !0),
                            t && t(a));
                },
                i,
                r
            );
        }
        if (Array.isArray(e)) for (let h = 0, p = e.length; h < p; ++h) d(h);
        else
            c.load(
                e,
                function (h) {
                    const p = s.parse(h, !0);
                    if (p.isCubemap) {
                        const v = p.mipmaps.length / p.mipmapCount;
                        for (let _ = 0; _ < v; _++) {
                            o[_] = { mipmaps: [] };
                            for (let w = 0; w < p.mipmapCount; w++)
                                o[_].mipmaps.push(p.mipmaps[_ * p.mipmapCount + w]),
                                    (o[_].format = p.format),
                                    (o[_].width = p.width),
                                    (o[_].height = p.height);
                        }
                        a.image = o;
                    } else
                        (a.image.width = p.width),
                            (a.image.height = p.height),
                            (a.mipmaps = p.mipmaps);
                    p.mipmapCount === 1 && (a.minFilter = dn),
                        (a.format = p.format),
                        (a.needsUpdate = !0),
                        t && t(a);
                },
                i,
                r
            );
        return a;
    }
}
class Lf extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
        const s = this,
            o = Us.get(e);
        if (o !== void 0)
            return (
                s.manager.itemStart(e),
                setTimeout(function () {
                    t && t(o), s.manager.itemEnd(e);
                }, 0),
                o
            );
        const a = wf('img');
        function c() {
            d(), Us.add(e, this), t && t(this), s.manager.itemEnd(e);
        }
        function f(h) {
            d(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e);
        }
        function d() {
            a.removeEventListener('load', c, !1), a.removeEventListener('error', f, !1);
        }
        return (
            a.addEventListener('load', c, !1),
            a.addEventListener('error', f, !1),
            e.slice(0, 5) !== 'data:' &&
                this.crossOrigin !== void 0 &&
                (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(e),
            (a.src = e),
            a
        );
    }
}
class $4 extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = new Vf();
        s.colorSpace = _r;
        const o = new Lf(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;
        function c(f) {
            o.load(
                e[f],
                function (d) {
                    (s.images[f] = d), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
                },
                void 0,
                r
            );
        }
        for (let f = 0; f < e.length; ++f) c(f);
        return s;
    }
}
class ez extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = this,
            o = new Do(),
            a = new js(this.manager);
        return (
            a.setResponseType('arraybuffer'),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(s.withCredentials),
            a.load(
                e,
                function (c) {
                    let f;
                    try {
                        f = s.parse(c);
                    } catch (d) {
                        if (r !== void 0) r(d);
                        else {
                            console.error(d);
                            return;
                        }
                    }
                    f.image !== void 0
                        ? (o.image = f.image)
                        : f.data !== void 0 &&
                          ((o.image.width = f.width),
                          (o.image.height = f.height),
                          (o.image.data = f.data)),
                        (o.wrapS = f.wrapS !== void 0 ? f.wrapS : pi),
                        (o.wrapT = f.wrapT !== void 0 ? f.wrapT : pi),
                        (o.magFilter = f.magFilter !== void 0 ? f.magFilter : dn),
                        (o.minFilter = f.minFilter !== void 0 ? f.minFilter : dn),
                        (o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1),
                        f.colorSpace !== void 0 && (o.colorSpace = f.colorSpace),
                        f.flipY !== void 0 && (o.flipY = f.flipY),
                        f.format !== void 0 && (o.format = f.format),
                        f.type !== void 0 && (o.type = f.type),
                        f.mipmaps !== void 0 && ((o.mipmaps = f.mipmaps), (o.minFilter = as)),
                        f.mipmapCount === 1 && (o.minFilter = dn),
                        f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps),
                        (o.needsUpdate = !0),
                        t && t(o, f);
                },
                i,
                r
            ),
            o
        );
    }
}
class tz extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = new mn(),
            o = new Lf(this.manager);
        return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
                e,
                function (a) {
                    (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
                },
                i,
                r
            ),
            s
        );
    }
}
class jo extends Ht {
    constructor(e, t = 1) {
        super(),
            (this.isLight = !0),
            (this.type = 'Light'),
            (this.color = new je(e)),
            (this.intensity = t);
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
        );
    }
}
class bb extends jo {
    constructor(e, t, i) {
        super(e, i),
            (this.isHemisphereLight = !0),
            (this.type = 'HemisphereLight'),
            this.position.copy(Ht.DEFAULT_UP),
            this.updateMatrix(),
            (this.groundColor = new je(t));
    }
    copy(e, t) {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
    }
}
const m0 = new ft(),
    cE = new k(),
    fE = new k();
class $x {
    constructor(e) {
        (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new _e(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new ft()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Gf()),
            (this._frameExtents = new _e(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Wt(0, 0, 1, 1)]);
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(e) {
        const t = this.camera,
            i = this.matrix;
        cE.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(cE),
            fE.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(fE),
            t.updateMatrixWorld(),
            m0.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(m0),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(m0);
    }
    getViewport(e) {
        return this._viewports[e];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
        return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const e = {};
        return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
                (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
        );
    }
}
class nz extends $x {
    constructor() {
        super(new Zn(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1);
    }
    updateMatrices(e) {
        const t = this.camera,
            i = yu * 2 * e.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) &&
            ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
            super.updateMatrices(e);
    }
    copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
    }
}
class Rb extends jo {
    constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
        super(e, t),
            (this.isSpotLight = !0),
            (this.type = 'SpotLight'),
            this.position.copy(Ht.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Ht()),
            (this.distance = i),
            (this.angle = r),
            (this.penumbra = s),
            (this.decay = o),
            (this.map = null),
            (this.shadow = new nz());
    }
    get power() {
        return this.intensity * Math.PI;
    }
    set power(e) {
        this.intensity = e / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
}
const dE = new ft(),
    _c = new k(),
    g0 = new k();
class iz extends $x {
    constructor() {
        super(new Zn(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new _e(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
                new Wt(2, 1, 1, 1),
                new Wt(0, 1, 1, 1),
                new Wt(3, 1, 1, 1),
                new Wt(1, 1, 1, 1),
                new Wt(3, 0, 1, 1),
                new Wt(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
                new k(1, 0, 0),
                new k(-1, 0, 0),
                new k(0, 0, 1),
                new k(0, 0, -1),
                new k(0, 1, 0),
                new k(0, -1, 0),
            ]),
            (this._cubeUps = [
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 0, 1),
                new k(0, 0, -1),
            ]);
    }
    updateMatrices(e, t = 0) {
        const i = this.camera,
            r = this.matrix,
            s = e.distance || i.far;
        s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
            _c.setFromMatrixPosition(e.matrixWorld),
            i.position.copy(_c),
            g0.copy(i.position),
            g0.add(this._cubeDirections[t]),
            i.up.copy(this._cubeUps[t]),
            i.lookAt(g0),
            i.updateMatrixWorld(),
            r.makeTranslation(-_c.x, -_c.y, -_c.z),
            dE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(dE);
    }
}
class Pb extends jo {
    constructor(e, t, i = 0, r = 2) {
        super(e, t),
            (this.isPointLight = !0),
            (this.type = 'PointLight'),
            (this.distance = i),
            (this.decay = r),
            (this.shadow = new iz());
    }
    get power() {
        return this.intensity * 4 * Math.PI;
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
}
class rz extends $x {
    constructor() {
        super(new Wf(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
    }
}
class Lb extends jo {
    constructor(e, t) {
        super(e, t),
            (this.isDirectionalLight = !0),
            (this.type = 'DirectionalLight'),
            this.position.copy(Ht.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Ht()),
            (this.shadow = new rz());
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return (
            super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this
        );
    }
}
class Ib extends jo {
    constructor(e, t) {
        super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
    }
}
class Nb extends jo {
    constructor(e, t, i = 10, r = 10) {
        super(e, t),
            (this.isRectAreaLight = !0),
            (this.type = 'RectAreaLight'),
            (this.width = i),
            (this.height = r);
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
        return super.copy(e), (this.width = e.width), (this.height = e.height), this;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (t.object.width = this.width), (t.object.height = this.height), t;
    }
}
class Db {
    constructor() {
        (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
        for (let e = 0; e < 9; e++) this.coefficients.push(new k());
    }
    set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this;
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this;
    }
    getAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = this.coefficients;
        return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * r),
            t.addScaledVector(o[2], 0.488603 * s),
            t.addScaledVector(o[3], 0.488603 * i),
            t.addScaledVector(o[4], 1.092548 * (i * r)),
            t.addScaledVector(o[5], 1.092548 * (r * s)),
            t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
            t.addScaledVector(o[7], 1.092548 * (i * s)),
            t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
            t
        );
    }
    getIrradianceAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = this.coefficients;
        return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * r),
            t.addScaledVector(o[2], 2 * 0.511664 * s),
            t.addScaledVector(o[3], 2 * 0.511664 * i),
            t.addScaledVector(o[4], 2 * 0.429043 * i * r),
            t.addScaledVector(o[5], 2 * 0.429043 * r * s),
            t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * i * s),
            t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
            t
        );
    }
    add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this;
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this;
    }
    scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this;
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
        return this;
    }
    equals(e) {
        for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
    }
    copy(e) {
        return this.set(e.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
        return this;
    }
    toArray(e = [], t = 0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
        return e;
    }
    static getBasisAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z;
        (t[0] = 0.282095),
            (t[1] = 0.488603 * r),
            (t[2] = 0.488603 * s),
            (t[3] = 0.488603 * i),
            (t[4] = 1.092548 * i * r),
            (t[5] = 1.092548 * r * s),
            (t[6] = 0.315392 * (3 * s * s - 1)),
            (t[7] = 1.092548 * i * s),
            (t[8] = 0.546274 * (i * i - r * r));
    }
}
class Ub extends jo {
    constructor(e = new Db(), t = 1) {
        super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
        return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (t.object.sh = this.sh.toArray()), t;
    }
}
class Qm extends Hi {
    constructor(e) {
        super(e), (this.textures = {});
    }
    load(e, t, i, r) {
        const s = this,
            o = new js(s.manager);
        o.setPath(s.path),
            o.setRequestHeader(s.requestHeader),
            o.setWithCredentials(s.withCredentials),
            o.load(
                e,
                function (a) {
                    try {
                        t(s.parse(JSON.parse(a)));
                    } catch (c) {
                        r ? r(c) : console.error(c), s.manager.itemError(e);
                    }
                },
                i,
                r
            );
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return (
                t[s] === void 0 && console.warn('THREE.MaterialLoader: Undefined texture', s), t[s]
            );
        }
        const r = Qm.createMaterialFromType(e.type);
        if (
            (e.uuid !== void 0 && (r.uuid = e.uuid),
            e.name !== void 0 && (r.name = e.name),
            e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
            e.roughness !== void 0 && (r.roughness = e.roughness),
            e.metalness !== void 0 && (r.metalness = e.metalness),
            e.sheen !== void 0 && (r.sheen = e.sheen),
            e.sheenColor !== void 0 && (r.sheenColor = new je().setHex(e.sheenColor)),
            e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
            e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
            e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
            e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
            e.specularColor !== void 0 &&
                r.specularColor !== void 0 &&
                r.specularColor.setHex(e.specularColor),
            e.shininess !== void 0 && (r.shininess = e.shininess),
            e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
            e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
            e.iridescence !== void 0 && (r.iridescence = e.iridescence),
            e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
            e.iridescenceThicknessRange !== void 0 &&
                (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
            e.transmission !== void 0 && (r.transmission = e.transmission),
            e.thickness !== void 0 && (r.thickness = e.thickness),
            e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
            e.attenuationColor !== void 0 &&
                r.attenuationColor !== void 0 &&
                r.attenuationColor.setHex(e.attenuationColor),
            e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
            e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation),
            e.fog !== void 0 && (r.fog = e.fog),
            e.flatShading !== void 0 && (r.flatShading = e.flatShading),
            e.blending !== void 0 && (r.blending = e.blending),
            e.combine !== void 0 && (r.combine = e.combine),
            e.side !== void 0 && (r.side = e.side),
            e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
            e.opacity !== void 0 && (r.opacity = e.opacity),
            e.transparent !== void 0 && (r.transparent = e.transparent),
            e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
            e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
            e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
            e.depthTest !== void 0 && (r.depthTest = e.depthTest),
            e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
            e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
            e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
            e.blendDst !== void 0 && (r.blendDst = e.blendDst),
            e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
            e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
            e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
            e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha),
            e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor),
            e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
            e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
            e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
            e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
            e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
            e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
            e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
            e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
            e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
            e.wireframe !== void 0 && (r.wireframe = e.wireframe),
            e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
            e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
            e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
            e.rotation !== void 0 && (r.rotation = e.rotation),
            e.linewidth !== void 0 && (r.linewidth = e.linewidth),
            e.dashSize !== void 0 && (r.dashSize = e.dashSize),
            e.gapSize !== void 0 && (r.gapSize = e.gapSize),
            e.scale !== void 0 && (r.scale = e.scale),
            e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
            e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
            e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
            e.dithering !== void 0 && (r.dithering = e.dithering),
            e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
            e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
            e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
            e.visible !== void 0 && (r.visible = e.visible),
            e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
            e.userData !== void 0 && (r.userData = e.userData),
            e.vertexColors !== void 0 &&
                (typeof e.vertexColors == 'number'
                    ? (r.vertexColors = e.vertexColors > 0)
                    : (r.vertexColors = e.vertexColors)),
            e.uniforms !== void 0)
        )
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (((r.uniforms[s] = {}), o.type)) {
                    case 't':
                        r.uniforms[s].value = i(o.value);
                        break;
                    case 'c':
                        r.uniforms[s].value = new je().setHex(o.value);
                        break;
                    case 'v2':
                        r.uniforms[s].value = new _e().fromArray(o.value);
                        break;
                    case 'v3':
                        r.uniforms[s].value = new k().fromArray(o.value);
                        break;
                    case 'v4':
                        r.uniforms[s].value = new Wt().fromArray(o.value);
                        break;
                    case 'm3':
                        r.uniforms[s].value = new Et().fromArray(o.value);
                        break;
                    case 'm4':
                        r.uniforms[s].value = new ft().fromArray(o.value);
                        break;
                    default:
                        r.uniforms[s].value = o.value;
                }
            }
        if (
            (e.defines !== void 0 && (r.defines = e.defines),
            e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
            e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
            e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
            e.extensions !== void 0)
        )
            for (const s in e.extensions) r.extensions[s] = e.extensions[s];
        if (
            (e.lights !== void 0 && (r.lights = e.lights),
            e.clipping !== void 0 && (r.clipping = e.clipping),
            e.size !== void 0 && (r.size = e.size),
            e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
            e.map !== void 0 && (r.map = i(e.map)),
            e.matcap !== void 0 && (r.matcap = i(e.matcap)),
            e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
            e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
            e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
            e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
            e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
            e.normalScale !== void 0)
        ) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]), (r.normalScale = new _e().fromArray(s));
        }
        return (
            e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
            e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
            e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
            e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
            e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
            e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
            e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
            e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
            e.specularIntensityMap !== void 0 &&
                (r.specularIntensityMap = i(e.specularIntensityMap)),
            e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
            e.envMap !== void 0 && (r.envMap = i(e.envMap)),
            e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation),
            e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
            e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
            e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
            e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
            e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
            e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
            e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
            e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
            e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
            e.clearcoatRoughnessMap !== void 0 &&
                (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
            e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
            e.clearcoatNormalScale !== void 0 &&
                (r.clearcoatNormalScale = new _e().fromArray(e.clearcoatNormalScale)),
            e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
            e.iridescenceThicknessMap !== void 0 &&
                (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
            e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
            e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
            e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
            e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
            e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
            r
        );
    }
    setTextures(e) {
        return (this.textures = e), this;
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: hb,
            SpriteMaterial: zx,
            RawShaderMaterial: pb,
            ShaderMaterial: Gr,
            PointsMaterial: Hx,
            MeshPhysicalMaterial: mb,
            MeshStandardMaterial: qx,
            MeshPhongMaterial: gb,
            MeshToonMaterial: vb,
            MeshNormalMaterial: _b,
            MeshLambertMaterial: yb,
            MeshDepthMaterial: Ox,
            MeshDistanceMaterial: Fx,
            MeshBasicMaterial: Go,
            MeshMatcapMaterial: xb,
            LineDashedMaterial: Sb,
            LineBasicMaterial: Pi,
            Material: ii,
        };
        return new t[e]();
    }
}
class dy {
    static decodeText(e) {
        if (typeof TextDecoder < 'u') return new TextDecoder().decode(e);
        let t = '';
        for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t));
        } catch {
            return t;
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf('/');
        return t === -1 ? './' : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
        return typeof e != 'string' || e === ''
            ? ''
            : (/^https?:\/\//i.test(t) &&
                  /^\//.test(e) &&
                  (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
              /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e)
                  ? e
                  : t + e);
    }
}
class Ob extends bt {
    constructor() {
        super(),
            (this.isInstancedBufferGeometry = !0),
            (this.type = 'InstancedBufferGeometry'),
            (this.instanceCount = 1 / 0);
    }
    copy(e) {
        return super.copy(e), (this.instanceCount = e.instanceCount), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.instanceCount = this.instanceCount), (e.isInstancedBufferGeometry = !0), e;
    }
}
class Fb extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = this,
            o = new js(s.manager);
        o.setPath(s.path),
            o.setRequestHeader(s.requestHeader),
            o.setWithCredentials(s.withCredentials),
            o.load(
                e,
                function (a) {
                    try {
                        t(s.parse(JSON.parse(a)));
                    } catch (c) {
                        r ? r(c) : console.error(c), s.manager.itemError(e);
                    }
                },
                i,
                r
            );
    }
    parse(e) {
        const t = {},
            i = {};
        function r(v, _) {
            if (t[_] !== void 0) return t[_];
            const x = v.interleavedBuffers[_],
                g = s(v, x.buffer),
                S = Kl(x.type, g),
                M = new Um(S, x.stride);
            return (M.uuid = x.uuid), (t[_] = M), M;
        }
        function s(v, _) {
            if (i[_] !== void 0) return i[_];
            const x = v.arrayBuffers[_],
                g = new Uint32Array(x).buffer;
            return (i[_] = g), g;
        }
        const o = e.isInstancedBufferGeometry ? new Ob() : new bt(),
            a = e.data.index;
        if (a !== void 0) {
            const v = Kl(a.type, a.array);
            o.setIndex(new Yt(v, 1));
        }
        const c = e.data.attributes;
        for (const v in c) {
            const _ = c[v];
            let w;
            if (_.isInterleavedBufferAttribute) {
                const x = r(e.data, _.data);
                w = new Ga(x, _.itemSize, _.offset, _.normalized);
            } else {
                const x = Kl(_.type, _.array),
                    g = _.isInstancedBufferAttribute ? Su : Yt;
                w = new g(x, _.itemSize, _.normalized);
            }
            _.name !== void 0 && (w.name = _.name),
                _.usage !== void 0 && w.setUsage(_.usage),
                o.setAttribute(v, w);
        }
        const f = e.data.morphAttributes;
        if (f)
            for (const v in f) {
                const _ = f[v],
                    w = [];
                for (let x = 0, g = _.length; x < g; x++) {
                    const S = _[x];
                    let M;
                    if (S.isInterleavedBufferAttribute) {
                        const T = r(e.data, S.data);
                        M = new Ga(T, S.itemSize, S.offset, S.normalized);
                    } else {
                        const T = Kl(S.type, S.array);
                        M = new Yt(T, S.itemSize, S.normalized);
                    }
                    S.name !== void 0 && (M.name = S.name), w.push(M);
                }
                o.morphAttributes[v] = w;
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let v = 0, _ = h.length; v !== _; ++v) {
                const w = h[v];
                o.addGroup(w.start, w.count, w.materialIndex);
            }
        const p = e.data.boundingSphere;
        if (p !== void 0) {
            const v = new k();
            p.center !== void 0 && v.fromArray(p.center), (o.boundingSphere = new mi(v, p.radius));
        }
        return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
    }
}
class sz extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = this,
            o = this.path === '' ? dy.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new js(this.manager);
        a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
                e,
                function (c) {
                    let f = null;
                    try {
                        f = JSON.parse(c);
                    } catch (h) {
                        r !== void 0 && r(h),
                            console.error("THREE:ObjectLoader: Can't parse " + e + '.', h.message);
                        return;
                    }
                    const d = f.metadata;
                    if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === 'geometry') {
                        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                            console.error("THREE.ObjectLoader: Can't load " + e);
                        return;
                    }
                    s.parse(f, t);
                },
                i,
                r
            );
    }
    async loadAsync(e, t) {
        const i = this,
            r = this.path === '' ? dy.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new js(this.manager);
        s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t),
            a = JSON.parse(o),
            c = a.metadata;
        if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === 'geometry')
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a);
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, r),
            o = this.parseImages(e.images, function () {
                t !== void 0 && t(f);
            }),
            a = this.parseTextures(e.textures, o),
            c = this.parseMaterials(e.materials, a),
            f = this.parseObject(e.object, s, c, a, i),
            d = this.parseSkeletons(e.skeletons, f);
        if ((this.bindSkeletons(f, d), t !== void 0)) {
            let h = !1;
            for (const p in o)
                if (o[p].data instanceof HTMLImageElement) {
                    h = !0;
                    break;
                }
            h === !1 && t(f);
        }
        return f;
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            r = this.parseGeometries(e.geometries, i),
            s = await this.parseImagesAsync(e.images),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            c = this.parseObject(e.object, r, a, o, t),
            f = this.parseSkeletons(e.skeletons, c);
        return this.bindSkeletons(c, f), c;
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new Ua().fromJSON(e[i]);
                t[s.uuid] = s;
            }
        return t;
    }
    parseSkeletons(e, t) {
        const i = {},
            r = {};
        if (
            (t.traverse(function (s) {
                s.isBone && (r[s.uuid] = s);
            }),
            e !== void 0)
        )
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new Om().fromJSON(e[s], r);
                i[a.uuid] = a;
            }
        return i;
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new Fb();
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const c = e[s];
                switch (c.type) {
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        a = r.parse(c);
                        break;
                    default:
                        c.type in uE
                            ? (a = uE[c.type].fromJSON(c, t))
                            : console.warn(
                                  `THREE.ObjectLoader: Unsupported geometry type "${c.type}"`
                              );
                }
                (a.uuid = c.uuid),
                    c.name !== void 0 && (a.name = c.name),
                    c.userData !== void 0 && (a.userData = c.userData),
                    (i[c.uuid] = a);
            }
        }
        return i;
    }
    parseMaterials(e, t) {
        const i = {},
            r = {};
        if (e !== void 0) {
            const s = new Qm();
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const c = e[o];
                i[c.uuid] === void 0 && (i[c.uuid] = s.parse(c)), (r[c.uuid] = i[c.uuid]);
            }
        }
        return r;
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i],
                    s = Pf.parse(r);
                t[s.uuid] = s;
            }
        return t;
    }
    parseImages(e, t) {
        const i = this,
            r = {};
        let s;
        function o(c) {
            return (
                i.manager.itemStart(c),
                s.load(
                    c,
                    function () {
                        i.manager.itemEnd(c);
                    },
                    void 0,
                    function () {
                        i.manager.itemError(c), i.manager.itemEnd(c);
                    }
                )
            );
        }
        function a(c) {
            if (typeof c == 'string') {
                const f = c,
                    d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
                return o(d);
            } else
                return c.data
                    ? { data: Kl(c.type, c.data), width: c.width, height: c.height }
                    : null;
        }
        if (e !== void 0 && e.length > 0) {
            const c = new Qx(t);
            (s = new Lf(c)), s.setCrossOrigin(this.crossOrigin);
            for (let f = 0, d = e.length; f < d; f++) {
                const h = e[f],
                    p = h.url;
                if (Array.isArray(p)) {
                    const v = [];
                    for (let _ = 0, w = p.length; _ < w; _++) {
                        const x = p[_],
                            g = a(x);
                        g !== null &&
                            (g instanceof HTMLImageElement
                                ? v.push(g)
                                : v.push(new Do(g.data, g.width, g.height)));
                    }
                    r[h.uuid] = new Aa(v);
                } else {
                    const v = a(h.url);
                    r[h.uuid] = new Aa(v);
                }
            }
        }
        return r;
    }
    async parseImagesAsync(e) {
        const t = this,
            i = {};
        let r;
        async function s(o) {
            if (typeof o == 'string') {
                const a = o,
                    c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(c);
            } else
                return o.data
                    ? { data: Kl(o.type, o.data), width: o.width, height: o.height }
                    : null;
        }
        if (e !== void 0 && e.length > 0) {
            (r = new Lf(this.manager)), r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const c = e[o],
                    f = c.url;
                if (Array.isArray(f)) {
                    const d = [];
                    for (let h = 0, p = f.length; h < p; h++) {
                        const v = f[h],
                            _ = await s(v);
                        _ !== null &&
                            (_ instanceof HTMLImageElement
                                ? d.push(_)
                                : d.push(new Do(_.data, _.width, _.height)));
                    }
                    i[c.uuid] = new Aa(d);
                } else {
                    const d = await s(c.url);
                    i[c.uuid] = new Aa(d);
                }
            }
        }
        return i;
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == 'number'
                ? s
                : (console.warn(
                      'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
                      s
                  ),
                  o[s]);
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 &&
                    console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                    t[a.image] === void 0 &&
                        console.warn('THREE.ObjectLoader: Undefined image', a.image);
                const c = t[a.image],
                    f = c.data;
                let d;
                Array.isArray(f)
                    ? ((d = new Vf()), f.length === 6 && (d.needsUpdate = !0))
                    : (f && f.data ? (d = new Do()) : (d = new mn()), f && (d.needsUpdate = !0)),
                    (d.source = c),
                    (d.uuid = a.uuid),
                    a.name !== void 0 && (d.name = a.name),
                    a.mapping !== void 0 && (d.mapping = i(a.mapping, oz)),
                    a.channel !== void 0 && (d.channel = a.channel),
                    a.offset !== void 0 && d.offset.fromArray(a.offset),
                    a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
                    a.center !== void 0 && d.center.fromArray(a.center),
                    a.rotation !== void 0 && (d.rotation = a.rotation),
                    a.wrap !== void 0 &&
                        ((d.wrapS = i(a.wrap[0], hE)), (d.wrapT = i(a.wrap[1], hE))),
                    a.format !== void 0 && (d.format = a.format),
                    a.internalFormat !== void 0 && (d.internalFormat = a.internalFormat),
                    a.type !== void 0 && (d.type = a.type),
                    a.colorSpace !== void 0 && (d.colorSpace = a.colorSpace),
                    a.minFilter !== void 0 && (d.minFilter = i(a.minFilter, pE)),
                    a.magFilter !== void 0 && (d.magFilter = i(a.magFilter, pE)),
                    a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
                    a.flipY !== void 0 && (d.flipY = a.flipY),
                    a.generateMipmaps !== void 0 && (d.generateMipmaps = a.generateMipmaps),
                    a.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = a.premultiplyAlpha),
                    a.unpackAlignment !== void 0 && (d.unpackAlignment = a.unpackAlignment),
                    a.compareFunction !== void 0 && (d.compareFunction = a.compareFunction),
                    a.userData !== void 0 && (d.userData = a.userData),
                    (r[a.uuid] = d);
            }
        return r;
    }
    parseObject(e, t, i, r, s) {
        let o;
        function a(p) {
            return (
                t[p] === void 0 && console.warn('THREE.ObjectLoader: Undefined geometry', p), t[p]
            );
        }
        function c(p) {
            if (p !== void 0) {
                if (Array.isArray(p)) {
                    const v = [];
                    for (let _ = 0, w = p.length; _ < w; _++) {
                        const x = p[_];
                        i[x] === void 0 &&
                            console.warn('THREE.ObjectLoader: Undefined material', x),
                            v.push(i[x]);
                    }
                    return v;
                }
                return (
                    i[p] === void 0 && console.warn('THREE.ObjectLoader: Undefined material', p),
                    i[p]
                );
            }
        }
        function f(p) {
            return (
                r[p] === void 0 && console.warn('THREE.ObjectLoader: Undefined texture', p), r[p]
            );
        }
        let d, h;
        switch (e.type) {
            case 'Scene':
                (o = new nm()),
                    e.background !== void 0 &&
                        (Number.isInteger(e.background)
                            ? (o.background = new je(e.background))
                            : (o.background = f(e.background))),
                    e.environment !== void 0 && (o.environment = f(e.environment)),
                    e.fog !== void 0 &&
                        (e.fog.type === 'Fog'
                            ? (o.fog = new Dm(e.fog.color, e.fog.near, e.fog.far))
                            : e.fog.type === 'FogExp2' &&
                              (o.fog = new Nm(e.fog.color, e.fog.density)),
                        e.fog.name !== '' && (o.fog.name = e.fog.name)),
                    e.backgroundBlurriness !== void 0 &&
                        (o.backgroundBlurriness = e.backgroundBlurriness),
                    e.backgroundIntensity !== void 0 &&
                        (o.backgroundIntensity = e.backgroundIntensity),
                    e.backgroundRotation !== void 0 &&
                        o.backgroundRotation.fromArray(e.backgroundRotation),
                    e.environmentRotation !== void 0 &&
                        o.environmentRotation.fromArray(e.environmentRotation);
                break;
            case 'PerspectiveCamera':
                (o = new Zn(e.fov, e.aspect, e.near, e.far)),
                    e.focus !== void 0 && (o.focus = e.focus),
                    e.zoom !== void 0 && (o.zoom = e.zoom),
                    e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
                    e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
                    e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case 'OrthographicCamera':
                (o = new Wf(e.left, e.right, e.top, e.bottom, e.near, e.far)),
                    e.zoom !== void 0 && (o.zoom = e.zoom),
                    e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case 'AmbientLight':
                o = new Ib(e.color, e.intensity);
                break;
            case 'DirectionalLight':
                o = new Lb(e.color, e.intensity);
                break;
            case 'PointLight':
                o = new Pb(e.color, e.intensity, e.distance, e.decay);
                break;
            case 'RectAreaLight':
                o = new Nb(e.color, e.intensity, e.width, e.height);
                break;
            case 'SpotLight':
                o = new Rb(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                break;
            case 'HemisphereLight':
                o = new bb(e.color, e.groundColor, e.intensity);
                break;
            case 'LightProbe':
                o = new Ub().fromJSON(e);
                break;
            case 'SkinnedMesh':
                (d = a(e.geometry)),
                    (h = c(e.material)),
                    (o = new QC(d, h)),
                    e.bindMode !== void 0 && (o.bindMode = e.bindMode),
                    e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
                    e.skeleton !== void 0 && (o.skeleton = e.skeleton);
                break;
            case 'Mesh':
                (d = a(e.geometry)), (h = c(e.material)), (o = new On(d, h));
                break;
            case 'InstancedMesh':
                (d = a(e.geometry)), (h = c(e.material));
                const p = e.count,
                    v = e.instanceMatrix,
                    _ = e.instanceColor;
                (o = new $C(d, h, p)),
                    (o.instanceMatrix = new Su(new Float32Array(v.array), 16)),
                    _ !== void 0 &&
                        (o.instanceColor = new Su(new Float32Array(_.array), _.itemSize));
                break;
            case 'BatchedMesh':
                (d = a(e.geometry)),
                    (h = c(e.material)),
                    (o = new eb(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, h)),
                    (o.geometry = d),
                    (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
                    (o.sortObjects = e.sortObjects),
                    (o._drawRanges = e.drawRanges),
                    (o._reservedRanges = e.reservedRanges),
                    (o._visibility = e.visibility),
                    (o._active = e.active),
                    (o._bounds = e.bounds.map((w) => {
                        const x = new Ci();
                        x.min.fromArray(w.boxMin), x.max.fromArray(w.boxMax);
                        const g = new mi();
                        return (
                            (g.radius = w.sphereRadius),
                            g.center.fromArray(w.sphereCenter),
                            {
                                boxInitialized: w.boxInitialized,
                                box: x,
                                sphereInitialized: w.sphereInitialized,
                                sphere: g,
                            }
                        );
                    })),
                    (o._maxGeometryCount = e.maxGeometryCount),
                    (o._maxVertexCount = e.maxVertexCount),
                    (o._maxIndexCount = e.maxIndexCount),
                    (o._geometryInitialized = e.geometryInitialized),
                    (o._geometryCount = e.geometryCount),
                    (o._matricesTexture = f(e.matricesTexture.uuid));
                break;
            case 'LOD':
                o = new JC();
                break;
            case 'Line':
                o = new ko(a(e.geometry), c(e.material));
                break;
            case 'LineLoop':
                o = new tb(a(e.geometry), c(e.material));
                break;
            case 'LineSegments':
                o = new ps(a(e.geometry), c(e.material));
                break;
            case 'PointCloud':
            case 'Points':
                o = new nb(a(e.geometry), c(e.material));
                break;
            case 'Sprite':
                o = new KC(c(e.material));
                break;
            case 'Group':
                o = new $l();
                break;
            case 'Bone':
                o = new Bx();
                break;
            default:
                o = new Ht();
        }
        if (
            ((o.uuid = e.uuid),
            e.name !== void 0 && (o.name = e.name),
            e.matrix !== void 0
                ? (o.matrix.fromArray(e.matrix),
                  e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
                  o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale))
                : (e.position !== void 0 && o.position.fromArray(e.position),
                  e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
                  e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
                  e.scale !== void 0 && o.scale.fromArray(e.scale)),
            e.up !== void 0 && o.up.fromArray(e.up),
            e.castShadow !== void 0 && (o.castShadow = e.castShadow),
            e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
            e.shadow &&
                (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
                e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
                e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
                e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
                e.shadow.camera !== void 0 &&
                    (o.shadow.camera = this.parseObject(e.shadow.camera))),
            e.visible !== void 0 && (o.visible = e.visible),
            e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
            e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
            e.userData !== void 0 && (o.userData = e.userData),
            e.layers !== void 0 && (o.layers.mask = e.layers),
            e.children !== void 0)
        ) {
            const p = e.children;
            for (let v = 0; v < p.length; v++) o.add(this.parseObject(p[v], t, i, r, s));
        }
        if (e.animations !== void 0) {
            const p = e.animations;
            for (let v = 0; v < p.length; v++) {
                const _ = p[v];
                o.animations.push(s[_]);
            }
        }
        if (e.type === 'LOD') {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let v = 0; v < p.length; v++) {
                const _ = p[v],
                    w = o.getObjectByProperty('uuid', _.object);
                w !== void 0 && o.addLevel(w, _.distance, _.hysteresis);
            }
        }
        return o;
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 &&
            e.traverse(function (i) {
                if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                    const r = t[i.skeleton];
                    r === void 0
                        ? console.warn(
                              'THREE.ObjectLoader: No skeleton found with UUID:',
                              i.skeleton
                          )
                        : i.bind(r, i.bindMatrix);
                }
            });
    }
}
const oz = {
        UVMapping: Cm,
        CubeReflectionMapping: Ws,
        CubeRefractionMapping: Fo,
        EquirectangularReflectionMapping: ff,
        EquirectangularRefractionMapping: df,
        CubeUVReflectionMapping: Cu,
    },
    hE = { RepeatWrapping: hf, ClampToEdgeWrapping: pi, MirroredRepeatWrapping: pf },
    pE = {
        NearestFilter: bn,
        NearestMipmapNearestFilter: $p,
        NearestMipmapLinearFilter: ya,
        LinearFilter: dn,
        LinearMipmapNearestFilter: Hc,
        LinearMipmapLinearFilter: as,
    };
class az extends Hi {
    constructor(e) {
        super(e),
            (this.isImageBitmapLoader = !0),
            typeof createImageBitmap > 'u' &&
                console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
            typeof fetch > 'u' && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
            (this.options = { premultiplyAlpha: 'none' });
    }
    setOptions(e) {
        return (this.options = e), this;
    }
    load(e, t, i, r) {
        e === void 0 && (e = ''),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
        const s = this,
            o = Us.get(e);
        if (o !== void 0) {
            if ((s.manager.itemStart(e), o.then)) {
                o.then((f) => {
                    t && t(f), s.manager.itemEnd(e);
                }).catch((f) => {
                    r && r(f);
                });
                return;
            }
            return (
                setTimeout(function () {
                    t && t(o), s.manager.itemEnd(e);
                }, 0),
                o
            );
        }
        const a = {};
        (a.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
            (a.headers = this.requestHeader);
        const c = fetch(e, a)
            .then(function (f) {
                return f.blob();
            })
            .then(function (f) {
                return createImageBitmap(
                    f,
                    Object.assign(s.options, { colorSpaceConversion: 'none' })
                );
            })
            .then(function (f) {
                return Us.add(e, f), t && t(f), s.manager.itemEnd(e), f;
            })
            .catch(function (f) {
                r && r(f), Us.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
            });
        Us.add(e, c), s.manager.itemStart(e);
    }
}
let Kh;
class e1 {
    static getContext() {
        return Kh === void 0 && (Kh = new (window.AudioContext || window.webkitAudioContext)()), Kh;
    }
    static setContext(e) {
        Kh = e;
    }
}
class lz extends Hi {
    constructor(e) {
        super(e);
    }
    load(e, t, i, r) {
        const s = this,
            o = new js(this.manager);
        o.setResponseType('arraybuffer'),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
                e,
                function (c) {
                    try {
                        const f = c.slice(0);
                        e1.getContext()
                            .decodeAudioData(f, function (h) {
                                t(h);
                            })
                            .catch(a);
                    } catch (f) {
                        a(f);
                    }
                },
                i,
                r
            );
        function a(c) {
            r ? r(c) : console.error(c), s.manager.itemError(e);
        }
    }
}
const mE = new ft(),
    gE = new ft(),
    ca = new ft();
class uz {
    constructor() {
        (this.type = 'StereoCamera'),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new Zn()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new Zn()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null,
            });
    }
    update(e) {
        const t = this._cache;
        if (
            t.focus !== e.focus ||
            t.fov !== e.fov ||
            t.aspect !== e.aspect * this.aspect ||
            t.near !== e.near ||
            t.far !== e.far ||
            t.zoom !== e.zoom ||
            t.eyeSep !== this.eyeSep
        ) {
            (t.focus = e.focus),
                (t.fov = e.fov),
                (t.aspect = e.aspect * this.aspect),
                (t.near = e.near),
                (t.far = e.far),
                (t.zoom = e.zoom),
                (t.eyeSep = this.eyeSep),
                ca.copy(e.projectionMatrix);
            const r = t.eyeSep / 2,
                s = (r * t.near) / t.focus,
                o = (t.near * Math.tan(Na * t.fov * 0.5)) / t.zoom;
            let a, c;
            (gE.elements[12] = -r),
                (mE.elements[12] = r),
                (a = -o * t.aspect + s),
                (c = o * t.aspect + s),
                (ca.elements[0] = (2 * t.near) / (c - a)),
                (ca.elements[8] = (c + a) / (c - a)),
                this.cameraL.projectionMatrix.copy(ca),
                (a = -o * t.aspect - s),
                (c = o * t.aspect - s),
                (ca.elements[0] = (2 * t.near) / (c - a)),
                (ca.elements[8] = (c + a) / (c - a)),
                this.cameraR.projectionMatrix.copy(ca);
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(gE),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(mE);
    }
}
class t1 {
    constructor(e = !0) {
        (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
    }
    start() {
        (this.startTime = vE()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
    }
    stop() {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const t = vE();
            (e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e);
        }
        return e;
    }
}
function vE() {
    return (typeof performance > 'u' ? Date : performance).now();
}
const fa = new k(),
    _E = new Bi(),
    cz = new k(),
    da = new k();
class fz extends Ht {
    constructor() {
        super(),
            (this.type = 'AudioListener'),
            (this.context = e1.getContext()),
            (this.gain = this.context.createGain()),
            this.gain.connect(this.context.destination),
            (this.filter = null),
            (this.timeDelta = 0),
            (this._clock = new t1());
    }
    getInput() {
        return this.gain;
    }
    removeFilter() {
        return (
            this.filter !== null &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
            this
        );
    }
    getFilter() {
        return this.filter;
    }
    setFilter(e) {
        return (
            this.filter !== null
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
            (this.filter = e),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        );
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
            i = this.up;
        if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose(fa, _E, cz),
            da.set(0, 0, -1).applyQuaternion(_E),
            t.positionX)
        ) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(fa.x, r),
                t.positionY.linearRampToValueAtTime(fa.y, r),
                t.positionZ.linearRampToValueAtTime(fa.z, r),
                t.forwardX.linearRampToValueAtTime(da.x, r),
                t.forwardY.linearRampToValueAtTime(da.y, r),
                t.forwardZ.linearRampToValueAtTime(da.z, r),
                t.upX.linearRampToValueAtTime(i.x, r),
                t.upY.linearRampToValueAtTime(i.y, r),
                t.upZ.linearRampToValueAtTime(i.z, r);
        } else t.setPosition(fa.x, fa.y, fa.z), t.setOrientation(da.x, da.y, da.z, i.x, i.y, i.z);
    }
}
class kb extends Ht {
    constructor(e) {
        super(),
            (this.type = 'Audio'),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = 'empty'),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(e) {
        return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = 'audioNode'),
            (this.source = e),
            this.connect(),
            this
        );
    }
    setMediaElementSource(e) {
        return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = 'mediaNode'),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
        );
    }
    setMediaStreamSource(e) {
        return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = 'mediaStreamNode'),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
        );
    }
    setBuffer(e) {
        return (this.buffer = e), (this.sourceType = 'buffer'), this.autoplay && this.play(), this;
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(this._startedAt, this._progress + this.offset, this.duration),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
        );
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            this.isPlaying === !0 &&
                ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
                this.loop === !0 &&
                    (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
            this
        );
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            (this._progress = 0),
            this.source !== null && (this.source.stop(), (this.source.onended = null)),
            (this.isPlaying = !1),
            this
        );
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return (this._connected = !0), this;
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
        }
    }
    getFilters() {
        return this.filters;
    }
    setFilters(e) {
        return (
            e || (e = []),
            this._connected === !0
                ? (this.disconnect(), (this.filters = e.slice()), this.connect())
                : (this.filters = e.slice()),
            this
        );
    }
    setDetune(e) {
        return (
            (this.detune = e),
            this.isPlaying === !0 &&
                this.source.detune !== void 0 &&
                this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
            this
        );
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : []);
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
                this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01
                ),
            this
        );
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = !1;
    }
    getLoop() {
        return this.hasPlaybackControl === !1
            ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
            : this.loop;
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (this.loop = e), this.isPlaying === !0 && (this.source.loop = this.loop), this;
    }
    setLoopStart(e) {
        return (this.loopStart = e), this;
    }
    setLoopEnd(e) {
        return (this.loopEnd = e), this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
    }
}
const ha = new k(),
    yE = new Bi(),
    dz = new k(),
    pa = new k();
class hz extends kb {
    constructor(e) {
        super(e),
            (this.panner = this.context.createPanner()),
            (this.panner.panningModel = 'HRTF'),
            this.panner.connect(this.gain);
    }
    connect() {
        super.connect(), this.panner.connect(this.gain);
    }
    disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(e) {
        return (this.panner.refDistance = e), this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(e) {
        return (this.panner.rolloffFactor = e), this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(e) {
        return (this.panner.distanceModel = e), this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(e) {
        return (this.panner.maxDistance = e), this;
    }
    setDirectionalCone(e, t, i) {
        return (
            (this.panner.coneInnerAngle = e),
            (this.panner.coneOuterAngle = t),
            (this.panner.coneOuterGain = i),
            this
        );
    }
    updateMatrixWorld(e) {
        if ((super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1))
            return;
        this.matrixWorld.decompose(ha, yE, dz), pa.set(0, 0, 1).applyQuaternion(yE);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(ha.x, i),
                t.positionY.linearRampToValueAtTime(ha.y, i),
                t.positionZ.linearRampToValueAtTime(ha.z, i),
                t.orientationX.linearRampToValueAtTime(pa.x, i),
                t.orientationY.linearRampToValueAtTime(pa.y, i),
                t.orientationZ.linearRampToValueAtTime(pa.z, i);
        } else t.setPosition(ha.x, ha.y, ha.z), t.setOrientation(pa.x, pa.y, pa.z);
    }
}
class pz {
    constructor(e, t = 2048) {
        (this.analyser = e.context.createAnalyser()),
            (this.analyser.fftSize = t),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            e.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++) e += t[i];
        return e / t.length;
    }
}
class zb {
    constructor(e, t, i) {
        (this.binding = e), (this.valueSize = i);
        let r, s, o;
        switch (t) {
            case 'quaternion':
                (r = this._slerp),
                    (s = this._slerpAdditive),
                    (o = this._setAdditiveIdentityQuaternion),
                    (this.buffer = new Float64Array(i * 6)),
                    (this._workIndex = 5);
                break;
            case 'string':
            case 'bool':
                (r = this._select),
                    (s = this._select),
                    (o = this._setAdditiveIdentityOther),
                    (this.buffer = new Array(i * 5));
                break;
            default:
                (r = this._lerp),
                    (s = this._lerpAdditive),
                    (o = this._setAdditiveIdentityNumeric),
                    (this.buffer = new Float64Array(i * 5));
        }
        (this._mixBufferRegion = r),
            (this._mixBufferRegionAdditive = s),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
    }
    accumulate(e, t) {
        const i = this.buffer,
            r = this.valueSize,
            s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a) i[s + a] = i[a];
            o = t;
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r);
        }
        this.cumulativeWeight = o;
    }
    accumulateAdditive(e) {
        const t = this.buffer,
            i = this.valueSize,
            r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, r, 0, e, i),
            (this.cumulativeWeightAdditive += e);
    }
    apply(e) {
        const t = this.valueSize,
            i = this.buffer,
            r = e * t + t,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
        if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)) {
            const c = t * this._origIndex;
            this._mixBufferRegion(i, r, c, 1 - s, t);
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let c = t, f = t + t; c !== f; ++c)
            if (i[c] !== i[c + t]) {
                a.setValue(i, r);
                break;
            }
    }
    saveOriginalState() {
        const e = this.binding,
            t = this.buffer,
            i = this.valueSize,
            r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
        this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
        for (let i = e; i < t; i++) this.buffer[i] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1);
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i];
    }
    _select(e, t, i, r, s) {
        if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
    }
    _slerp(e, t, i, r) {
        Bi.slerpFlat(e, t, e, t, e, i, r);
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        Bi.multiplyQuaternionsFlat(e, o, e, t, e, i), Bi.slerpFlat(e, t, e, t, e, o, r);
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const c = t + a;
            e[c] = e[c] * o + e[i + a] * r;
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r;
        }
    }
}
const n1 = '\\[\\]\\.:\\/',
    mz = new RegExp('[' + n1 + ']', 'g'),
    i1 = '[^' + n1 + ']',
    gz = '[^' + n1.replace('\\.', '') + ']',
    vz = /((?:WC+[\/:])*)/.source.replace('WC', i1),
    _z = /(WCOD+)?/.source.replace('WCOD', gz),
    yz = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', i1),
    xz = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', i1),
    Sz = new RegExp('^' + vz + _z + yz + xz + '$'),
    Mz = ['material', 'materials', 'bones', 'map'];
class wz {
    constructor(e, t, i) {
        const r = i || Ut.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
            r = this._bindings[i];
        r !== void 0 && r.getValue(e, t);
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t);
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
    }
}
class Ut {
    constructor(e, t, i) {
        (this.path = t),
            (this.parsedPath = i || Ut.parseTrackName(t)),
            (this.node = Ut.findNode(e, this.parsedPath.nodeName)),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Ut.Composite(e, t, i) : new Ut(e, t, i);
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, '_').replace(mz, '');
    }
    static parseTrackName(e) {
        const t = Sz.exec(e);
        if (t === null) throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
        const i = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6],
            },
            r = i.nodeName && i.nodeName.lastIndexOf('.');
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            Mz.indexOf(s) !== -1 && ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + e);
        return i;
    }
    static findNode(e, t) {
        if (t === void 0 || t === '' || t === '.' || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i;
        }
        if (e.children) {
            const i = function (s) {
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (a.name === t || a.uuid === t) return a;
                        const c = i(a.children);
                        if (c) return c;
                    }
                    return null;
                },
                r = i(e.children);
            if (r) return r;
        }
        return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath,
            i = t.objectName,
            r = t.propertyName;
        let s = t.propertyIndex;
        if (
            (e || ((e = Ut.findNode(this.rootNode, t.nodeName)), (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
        ) {
            console.warn(
                'THREE.PropertyBinding: No target node found for track: ' + this.path + '.'
            );
            return;
        }
        if (i) {
            let f = t.objectIndex;
            switch (i) {
                case 'materials':
                    if (!e.material) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                            this
                        );
                        return;
                    }
                    if (!e.material.materials) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                            this
                        );
                        return;
                    }
                    e = e.material.materials;
                    break;
                case 'bones':
                    if (!e.skeleton) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                            this
                        );
                        return;
                    }
                    e = e.skeleton.bones;
                    for (let d = 0; d < e.length; d++)
                        if (e[d].name === f) {
                            f = d;
                            break;
                        }
                    break;
                case 'map':
                    if ('map' in e) {
                        e = e.map;
                        break;
                    }
                    if (!e.material) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                            this
                        );
                        return;
                    }
                    if (!e.material.map) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
                            this
                        );
                        return;
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[i] === void 0) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                            this
                        );
                        return;
                    }
                    e = e[i];
            }
            if (f !== void 0) {
                if (e[f] === void 0) {
                    console.error(
                        'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                        this,
                        e
                    );
                    return;
                }
                e = e[f];
            }
        }
        const o = e[r];
        if (o === void 0) {
            const f = t.nodeName;
            console.error(
                'THREE.PropertyBinding: Trying to update property for track: ' +
                    f +
                    '.' +
                    r +
                    " but it wasn't found.",
                e
            );
            return;
        }
        let a = this.Versioning.None;
        (this.targetObject = e),
            e.needsUpdate !== void 0
                ? (a = this.Versioning.NeedsUpdate)
                : e.matrixWorldNeedsUpdate !== void 0 &&
                  (a = this.Versioning.MatrixWorldNeedsUpdate);
        let c = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === 'morphTargetInfluences') {
                if (!e.geometry) {
                    console.error(
                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                        this
                    );
                    return;
                }
                if (!e.geometry.morphAttributes) {
                    console.error(
                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                        this
                    );
                    return;
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
            }
            (c = this.BindingType.ArrayElement),
                (this.resolvedProperty = o),
                (this.propertyIndex = s);
        } else
            o.fromArray !== void 0 && o.toArray !== void 0
                ? ((c = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
                : Array.isArray(o)
                ? ((c = this.BindingType.EntireArray), (this.resolvedProperty = o))
                : (this.propertyName = r);
        (this.getValue = this.GetterByBindingType[c]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[c][a]);
    }
    unbind() {
        (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
    }
}
Ut.Composite = wz;
Ut.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
Ut.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
Ut.prototype.GetterByBindingType = [
    Ut.prototype._getValue_direct,
    Ut.prototype._getValue_array,
    Ut.prototype._getValue_arrayElement,
    Ut.prototype._getValue_toArray,
];
Ut.prototype.SetterByBindingTypeAndVersioning = [
    [
        Ut.prototype._setValue_direct,
        Ut.prototype._setValue_direct_setNeedsUpdate,
        Ut.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
        Ut.prototype._setValue_array,
        Ut.prototype._setValue_array_setNeedsUpdate,
        Ut.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
        Ut.prototype._setValue_arrayElement,
        Ut.prototype._setValue_arrayElement_setNeedsUpdate,
        Ut.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
        Ut.prototype._setValue_fromArray,
        Ut.prototype._setValue_fromArray_setNeedsUpdate,
        Ut.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
];
class Ez {
    constructor() {
        (this.isAnimationObjectGroup = !0),
            (this.uuid = er()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i) e[arguments[i].uuid] = i;
        (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length;
                },
                get inUse() {
                    return this.total - t.nCachedObjects_;
                },
            },
            get bindingsPerObject() {
                return t._bindings.length;
            },
        };
    }
    add() {
        const e = this._objects,
            t = this._indicesByUUID,
            i = this._paths,
            r = this._parsedPaths,
            s = this._bindings,
            o = s.length;
        let a,
            c = e.length,
            f = this.nCachedObjects_;
        for (let d = 0, h = arguments.length; d !== h; ++d) {
            const p = arguments[d],
                v = p.uuid;
            let _ = t[v];
            if (_ === void 0) {
                (_ = c++), (t[v] = _), e.push(p);
                for (let w = 0, x = o; w !== x; ++w) s[w].push(new Ut(p, i[w], r[w]));
            } else if (_ < f) {
                a = e[_];
                const w = --f,
                    x = e[w];
                (t[x.uuid] = _), (e[_] = x), (t[v] = w), (e[w] = p);
                for (let g = 0, S = o; g !== S; ++g) {
                    const M = s[g],
                        T = M[w];
                    let P = M[_];
                    (M[_] = T), P === void 0 && (P = new Ut(p, i[g], r[g])), (M[w] = P);
                }
            } else
                e[_] !== a &&
                    console.error(
                        'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
                    );
        }
        this.nCachedObjects_ = f;
    }
    remove() {
        const e = this._objects,
            t = this._indicesByUUID,
            i = this._bindings,
            r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const c = arguments[o],
                f = c.uuid,
                d = t[f];
            if (d !== void 0 && d >= s) {
                const h = s++,
                    p = e[h];
                (t[p.uuid] = d), (e[d] = p), (t[f] = h), (e[h] = c);
                for (let v = 0, _ = r; v !== _; ++v) {
                    const w = i[v],
                        x = w[h],
                        g = w[d];
                    (w[d] = x), (w[h] = g);
                }
            }
        }
        this.nCachedObjects_ = s;
    }
    uncache() {
        const e = this._objects,
            t = this._indicesByUUID,
            i = this._bindings,
            r = i.length;
        let s = this.nCachedObjects_,
            o = e.length;
        for (let a = 0, c = arguments.length; a !== c; ++a) {
            const f = arguments[a],
                d = f.uuid,
                h = t[d];
            if (h !== void 0)
                if ((delete t[d], h < s)) {
                    const p = --s,
                        v = e[p],
                        _ = --o,
                        w = e[_];
                    (t[v.uuid] = h), (e[h] = v), (t[w.uuid] = p), (e[p] = w), e.pop();
                    for (let x = 0, g = r; x !== g; ++x) {
                        const S = i[x],
                            M = S[p],
                            T = S[_];
                        (S[h] = M), (S[p] = T), S.pop();
                    }
                } else {
                    const p = --o,
                        v = e[p];
                    p > 0 && (t[v.uuid] = h), (e[h] = v), e.pop();
                    for (let _ = 0, w = r; _ !== w; ++_) {
                        const x = i[_];
                        (x[h] = x[p]), x.pop();
                    }
                }
        }
        this.nCachedObjects_ = s;
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0) return s[r];
        const o = this._paths,
            a = this._parsedPaths,
            c = this._objects,
            f = c.length,
            d = this.nCachedObjects_,
            h = new Array(f);
        (r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(h);
        for (let p = d, v = c.length; p !== v; ++p) {
            const _ = c[p];
            h[p] = new Ut(_, e, t);
        }
        return h;
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
            i = t[e];
        if (i !== void 0) {
            const r = this._paths,
                s = this._parsedPaths,
                o = this._bindings,
                a = o.length - 1,
                c = o[a],
                f = e[a];
            (t[f] = i), (o[i] = c), o.pop(), (s[i] = s[a]), s.pop(), (r[i] = r[a]), r.pop();
        }
    }
}
class Bb {
    constructor(e, t, i = null, r = t.blendMode) {
        (this._mixer = e), (this._clip = t), (this._localRoot = i), (this.blendMode = r);
        const s = t.tracks,
            o = s.length,
            a = new Array(o),
            c = { endingStart: Ea, endingEnd: Ea };
        for (let f = 0; f !== o; ++f) {
            const d = s[f].createInterpolant(null);
            (a[f] = d), (d.settings = c);
        }
        (this._interpolantSettings = c),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = yC),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
    }
    play() {
        return this._mixer._activateAction(this), this;
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
        return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
        );
    }
    isRunning() {
        return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
        );
    }
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(e) {
        return (this._startTime = e), this;
    }
    setLoop(e, t) {
        return (this.loop = e), (this.repetitions = t), this;
    }
    setEffectiveWeight(e) {
        return (this.weight = e), (this._effectiveWeight = this.enabled ? e : 0), this.stopFading();
    }
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, i) {
        if ((e.fadeOut(t), this.fadeIn(t), i)) {
            const r = this._clip.duration,
                s = e._clip.duration,
                o = s / r,
                a = r / s;
            e.warp(1, o, t), this.warp(a, 1, t);
        }
        return this;
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i);
    }
    stopFading() {
        const e = this._weightInterpolant;
        return (
            e !== null &&
                ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
            this
        );
    }
    setEffectiveTimeScale(e) {
        return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
        );
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(e) {
        return (this.timeScale = this._clip.duration / e), this.stopWarping();
    }
    syncWith(e) {
        return (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping();
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, i) {
        const r = this._mixer,
            s = r.time,
            o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        const c = a.parameterPositions,
            f = a.sampleValues;
        return (c[0] = s), (c[1] = s + i), (f[0] = e / o), (f[1] = t / o), this;
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return (
            e !== null &&
                ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
            this
        );
    }
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return;
        }
        const s = this._startTime;
        if (s !== null) {
            const c = (e - s) * i;
            c < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * c));
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t),
            a = this._updateWeight(e);
        if (a > 0) {
            const c = this._interpolants,
                f = this._propertyBindings;
            switch (this.blendMode) {
                case Cx:
                    for (let d = 0, h = c.length; d !== h; ++d)
                        c[d].evaluate(o), f[d].accumulateAdditive(a);
                    break;
                case Rm:
                default:
                    for (let d = 0, h = c.length; d !== h; ++d)
                        c[d].evaluate(o), f[d].accumulate(r, a);
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                (t *= r),
                    e > i.parameterPositions[1] &&
                        (this.stopFading(), r === 0 && (this.enabled = !1));
            }
        }
        return (this._effectiveWeight = t), t;
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                (t *= r),
                    e > i.parameterPositions[1] &&
                        (this.stopWarping(), t === 0 ? (this.paused = !0) : (this.timeScale = t));
            }
        }
        return (this._effectiveTimeScale = t), t;
    }
    _updateTime(e) {
        const t = this._clip.duration,
            i = this.loop;
        let r = this.time + e,
            s = this._loopCount;
        const o = i === xC;
        if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === _C) {
            s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
                if (r >= t) r = t;
                else if (r < 0) r = 0;
                else {
                    this.time = r;
                    break e;
                }
                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                    (this.time = r),
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: e < 0 ? -1 : 1,
                    });
            }
        } else {
            if (
                (s === -1 &&
                    (e >= 0
                        ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
                        : this._setEndings(this.repetitions === 0, !0, o)),
                r >= t || r < 0)
            ) {
                const a = Math.floor(r / t);
                (r -= t * a), (s += Math.abs(a));
                const c = this.repetitions - s;
                if (c <= 0)
                    this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                        (r = e > 0 ? t : 0),
                        (this.time = r),
                        this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: e > 0 ? 1 : -1,
                        });
                else {
                    if (c === 1) {
                        const f = e < 0;
                        this._setEndings(f, !f, o);
                    } else this._setEndings(!1, !1, o);
                    (this._loopCount = s),
                        (this.time = r),
                        this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: a });
                }
            } else this.time = r;
            if (o && (s & 1) === 1) return t - r;
        }
        return r;
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i
            ? ((r.endingStart = Ta), (r.endingEnd = Ta))
            : (e ? (r.endingStart = this.zeroSlopeAtStart ? Ta : Ea) : (r.endingStart = vf),
              t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ta : Ea) : (r.endingEnd = vf));
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer,
            s = r.time;
        let o = this._weightInterpolant;
        o === null && ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
        const a = o.parameterPositions,
            c = o.sampleValues;
        return (a[0] = s), (c[0] = t), (a[1] = s + e), (c[1] = i), this;
    }
}
const Tz = new Float32Array(1);
class Az extends qs {
    constructor(e) {
        super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root,
            r = e._clip.tracks,
            s = r.length,
            o = e._propertyBindings,
            a = e._interpolants,
            c = i.uuid,
            f = this._bindingsByRootAndName;
        let d = f[c];
        d === void 0 && ((d = {}), (f[c] = d));
        for (let h = 0; h !== s; ++h) {
            const p = r[h],
                v = p.name;
            let _ = d[v];
            if (_ !== void 0) ++_.referenceCount, (o[h] = _);
            else {
                if (((_ = o[h]), _ !== void 0)) {
                    _._cacheIndex === null &&
                        (++_.referenceCount, this._addInactiveBinding(_, c, v));
                    continue;
                }
                const w = t && t._propertyBindings[h].binding.parsedPath;
                (_ = new zb(Ut.create(i, v, w), p.ValueTypeName, p.getValueSize())),
                    ++_.referenceCount,
                    this._addInactiveBinding(_, c, v),
                    (o[h] = _);
            }
            a[h].resultBuffer = _.buffer;
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid,
                    r = e._clip.uuid,
                    s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i);
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(e);
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
            }
            this._takeBackAction(e);
        }
    }
    _initMemoryManager() {
        (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length;
                },
                get inUse() {
                    return e._nActiveActions;
                },
            },
            bindings: {
                get total() {
                    return e._bindings.length;
                },
                get inUse() {
                    return e._nActiveBindings;
                },
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length;
                },
                get inUse() {
                    return e._nActiveControlInterpolants;
                },
            },
        };
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions,
            s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            (o = { knownActions: [e], actionByRoot: {} }), (e._byClipCacheIndex = 0), (s[t] = o);
        else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
        }
        (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
    }
    _removeInactiveAction(e) {
        const t = this._actions,
            i = t[t.length - 1],
            r = e._cacheIndex;
        (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
        const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            c = a.knownActions,
            f = c[c.length - 1],
            d = e._byClipCacheIndex;
        (f._byClipCacheIndex = d), (c[d] = f), c.pop(), (e._byClipCacheIndex = null);
        const h = a.actionByRoot,
            p = (e._localRoot || this._root).uuid;
        delete h[p], c.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s);
        }
    }
    _lendAction(e) {
        const t = this._actions,
            i = e._cacheIndex,
            r = this._nActiveActions++,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _takeBackAction(e) {
        const t = this._actions,
            i = e._cacheIndex,
            r = --this._nActiveActions,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName,
            s = this._bindings;
        let o = r[t];
        o === void 0 && ((o = {}), (r[t] = o)), (o[i] = e), (e._cacheIndex = s.length), s.push(e);
    }
    _removeInactiveBinding(e) {
        const t = this._bindings,
            i = e.binding,
            r = i.rootNode.uuid,
            s = i.path,
            o = this._bindingsByRootAndName,
            a = o[r],
            c = t[t.length - 1],
            f = e._cacheIndex;
        (c._cacheIndex = f),
            (t[f] = c),
            t.pop(),
            delete a[s],
            Object.keys(a).length === 0 && delete o[r];
    }
    _lendBinding(e) {
        const t = this._bindings,
            i = e._cacheIndex,
            r = this._nActiveBindings++,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _takeBackBinding(e) {
        const t = this._bindings,
            i = e._cacheIndex,
            r = --this._nActiveBindings,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
        let i = e[t];
        return (
            i === void 0 &&
                ((i = new Kx(new Float32Array(2), new Float32Array(2), 1, Tz)),
                (i.__cacheIndex = t),
                (e[t] = i)),
            i
        );
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
            i = e.__cacheIndex,
            r = --this._nActiveControlInterpolants,
            s = t[r];
        (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
    }
    clipAction(e, t, i) {
        const r = t || this._root,
            s = r.uuid;
        let o = typeof e == 'string' ? Pf.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e,
            c = this._actionsByClip[a];
        let f = null;
        if ((i === void 0 && (o !== null ? (i = o.blendMode) : (i = Rm)), c !== void 0)) {
            const h = c.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i) return h;
            (f = c.knownActions[0]), o === null && (o = f._clip);
        }
        if (o === null) return null;
        const d = new Bb(this, o, t, i);
        return this._bindAction(d, f), this._addInactiveAction(d, a, s), d;
    }
    existingAction(e, t) {
        const i = t || this._root,
            r = i.uuid,
            s = typeof e == 'string' ? Pf.findByName(i, e) : e,
            o = s ? s.uuid : e,
            a = this._actionsByClip[o];
        return (a !== void 0 && a.actionByRoot[r]) || null;
    }
    stopAllAction() {
        const e = this._actions,
            t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i) e[i].stop();
        return this;
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions,
            i = this._nActiveActions,
            r = (this.time += e),
            s = Math.sign(e),
            o = (this._accuIndex ^= 1);
        for (let f = 0; f !== i; ++f) t[f]._update(r, e, s, o);
        const a = this._bindings,
            c = this._nActiveBindings;
        for (let f = 0; f !== c; ++f) a[f].apply(o);
        return this;
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(e);
    }
    getRoot() {
        return this._root;
    }
    uncacheClip(e) {
        const t = this._actions,
            i = e.uuid,
            r = this._actionsByClip,
            s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, c = o.length; a !== c; ++a) {
                const f = o[a];
                this._deactivateAction(f);
                const d = f._cacheIndex,
                    h = t[t.length - 1];
                (f._cacheIndex = null),
                    (f._byClipCacheIndex = null),
                    (h._cacheIndex = d),
                    (t[d] = h),
                    t.pop(),
                    this._removeInactiveBindingsForAction(f);
            }
            delete r[i];
        }
    }
    uncacheRoot(e) {
        const t = e.uuid,
            i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot,
                c = a[t];
            c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
        }
        const r = this._bindingsByRootAndName,
            s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
    }
}
class r1 {
    constructor(e) {
        this.value = e;
    }
    clone() {
        return new r1(this.value.clone === void 0 ? this.value : this.value.clone());
    }
}
let Cz = 0;
class bz extends qs {
    constructor() {
        super(),
            (this.isUniformsGroup = !0),
            Object.defineProperty(this, 'id', { value: Cz++ }),
            (this.name = ''),
            (this.usage = Sf),
            (this.uniforms = []);
    }
    add(e) {
        return this.uniforms.push(e), this;
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1), this;
    }
    setName(e) {
        return (this.name = e), this;
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    dispose() {
        return this.dispatchEvent({ type: 'dispose' }), this;
    }
    copy(e) {
        (this.name = e.name), (this.usage = e.usage);
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = Array.isArray(t[i]) ? t[i] : [t[i]];
            for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
        }
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class Rz extends Um {
    constructor(e, t, i = 1) {
        super(e, t), (this.isInstancedInterleavedBuffer = !0), (this.meshPerAttribute = i);
    }
    copy(e) {
        return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
    }
    clone(e) {
        const t = super.clone(e);
        return (t.meshPerAttribute = this.meshPerAttribute), t;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.isInstancedInterleavedBuffer = !0), (t.meshPerAttribute = this.meshPerAttribute), t
        );
    }
}
class Pz {
    constructor(e, t, i, r, s) {
        (this.isGLBufferAttribute = !0),
            (this.name = ''),
            (this.buffer = e),
            (this.type = t),
            (this.itemSize = i),
            (this.elementSize = r),
            (this.count = s),
            (this.version = 0);
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setBuffer(e) {
        return (this.buffer = e), this;
    }
    setType(e, t) {
        return (this.type = e), (this.elementSize = t), this;
    }
    setItemSize(e) {
        return (this.itemSize = e), this;
    }
    setCount(e) {
        return (this.count = e), this;
    }
}
const xE = new ft();
class Hb {
    constructor(e, t, i = 0, r = 1 / 0) {
        (this.ray = new bu(e, t)),
            (this.near = i),
            (this.far = r),
            (this.camera = null),
            (this.layers = new Da()),
            (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
            });
    }
    set(e, t) {
        this.ray.set(e, t);
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(),
              (this.camera = t))
            : t.isOrthographicCamera
            ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
              this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
              (this.camera = t))
            : console.error('THREE.Raycaster: Unsupported camera type: ' + t.type);
    }
    setFromXRController(e) {
        return (
            xE.identity().extractRotation(e.matrixWorld),
            this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(0, 0, -1).applyMatrix4(xE),
            this
        );
    }
    intersectObject(e, t = !0, i = []) {
        return hy(e, this, i, t), i.sort(SE), i;
    }
    intersectObjects(e, t = !0, i = []) {
        for (let r = 0, s = e.length; r < s; r++) hy(e[r], this, i, t);
        return i.sort(SE), i;
    }
}
function SE(n, e) {
    return n.distance - e.distance;
}
function hy(n, e, t, i) {
    if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++) hy(r[s], e, t, !0);
    }
}
class Lz {
    constructor(e = 1, t = 0, i = 0) {
        return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    set(e, t, i) {
        return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    copy(e) {
        return (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this;
    }
    makeSafe() {
        return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this;
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, i) {
        return (
            (this.radius = Math.sqrt(e * e + t * t + i * i)),
            this.radius === 0
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(e, i)),
                  (this.phi = Math.acos(wn(t / this.radius, -1, 1)))),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class Iz {
    constructor(e = 1, t = 0, i = 0) {
        return (this.radius = e), (this.theta = t), (this.y = i), this;
    }
    set(e, t, i) {
        return (this.radius = e), (this.theta = t), (this.y = i), this;
    }
    copy(e) {
        return (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this;
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, i) {
        return (
            (this.radius = Math.sqrt(e * e + i * i)),
            (this.theta = Math.atan2(e, i)),
            (this.y = t),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const ME = new _e();
class Nz {
    constructor(e = new _e(1 / 0, 1 / 0), t = new _e(-1 / 0, -1 / 0)) {
        (this.isBox2 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this;
    }
    setFromCenterAndSize(e, t) {
        const i = ME.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
        return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
    }
    containsBox(e) {
        return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
        );
    }
    getParameter(e, t) {
        return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y)
        );
    }
    intersectsBox(e) {
        return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y
        );
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
        return this.clampPoint(e, ME).distanceTo(e);
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
    }
}
const wE = new k(),
    Jh = new k();
class Dz {
    constructor(e = new k(), t = new k()) {
        (this.start = e), (this.end = t);
    }
    set(e, t) {
        return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e) {
        return e.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
        wE.subVectors(e, this.start), Jh.subVectors(this.end, this.start);
        const i = Jh.dot(Jh);
        let s = Jh.dot(wE) / i;
        return t && (s = wn(s, 0, 1)), s;
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start);
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const EE = new k();
class Uz extends Ht {
    constructor(e, t) {
        super(),
            (this.light = e),
            (this.matrixAutoUpdate = !1),
            (this.color = t),
            (this.type = 'SpotLightHelper');
        const i = new bt(),
            r = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
                -1, 1,
            ];
        for (let o = 0, a = 1, c = 32; o < c; o++, a++) {
            const f = (o / c) * Math.PI * 2,
                d = (a / c) * Math.PI * 2;
            r.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1);
        }
        i.setAttribute('position', new nt(r, 3));
        const s = new Pi({ fog: !1, toneMapped: !1 });
        (this.cone = new ps(i, s)), this.add(this.cone), this.update();
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
            this.light.target.updateWorldMatrix(!0, !1),
            this.parent
                ? (this.parent.updateWorldMatrix(!0),
                  this.matrix
                      .copy(this.parent.matrixWorld)
                      .invert()
                      .multiply(this.light.matrixWorld))
                : this.matrix.copy(this.light.matrixWorld),
            this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
            EE.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(EE),
            this.color !== void 0
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
    }
}
const po = new k(),
    Qh = new ft(),
    v0 = new ft();
class Oz extends ps {
    constructor(e) {
        const t = Vb(e),
            i = new bt(),
            r = [],
            s = [],
            o = new je(0, 0, 1),
            a = new je(0, 1, 0);
        for (let f = 0; f < t.length; f++) {
            const d = t[f];
            d.parent &&
                d.parent.isBone &&
                (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b));
        }
        i.setAttribute('position', new nt(r, 3)), i.setAttribute('color', new nt(s, 3));
        const c = new Pi({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
        });
        super(i, c),
            (this.isSkeletonHelper = !0),
            (this.type = 'SkeletonHelper'),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
    }
    updateMatrixWorld(e) {
        const t = this.bones,
            i = this.geometry,
            r = i.getAttribute('position');
        v0.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent &&
                a.parent.isBone &&
                (Qh.multiplyMatrices(v0, a.matrixWorld),
                po.setFromMatrixPosition(Qh),
                r.setXYZ(o, po.x, po.y, po.z),
                Qh.multiplyMatrices(v0, a.parent.matrixWorld),
                po.setFromMatrixPosition(Qh),
                r.setXYZ(o + 1, po.x, po.y, po.z),
                (o += 2));
        }
        (i.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(e);
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
function Vb(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++) e.push.apply(e, Vb(n.children[t]));
    return e;
}
class Fz extends On {
    constructor(e, t, i) {
        const r = new Yf(t, 4, 2),
            s = new Go({ wireframe: !0, fog: !1, toneMapped: !1 });
        super(r, s),
            (this.light = e),
            (this.color = i),
            (this.type = 'PointLightHelper'),
            (this.matrix = this.light.matrixWorld),
            (this.matrixAutoUpdate = !1),
            this.update();
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
            this.color !== void 0
                ? this.material.color.set(this.color)
                : this.material.color.copy(this.light.color);
    }
}
const kz = new k(),
    TE = new je(),
    AE = new je();
class zz extends Ht {
    constructor(e, t, i) {
        super(),
            (this.light = e),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = i),
            (this.type = 'HemisphereLightHelper');
        const r = new Xf(t);
        r.rotateY(Math.PI * 0.5),
            (this.material = new Go({ wireframe: !0, fog: !1, toneMapped: !1 })),
            this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute('position'),
            o = new Float32Array(s.count * 3);
        r.setAttribute('color', new Yt(o, 3)), this.add(new On(r, this.material)), this.update();
    }
    dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0) this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute('color');
            TE.copy(this.light.color), AE.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? TE : AE;
                t.setXYZ(i, s.r, s.g, s.b);
            }
            t.needsUpdate = !0;
        }
        this.light.updateWorldMatrix(!0, !1),
            e.lookAt(kz.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
}
class Bz extends ps {
    constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
        (i = new je(i)), (r = new je(r));
        const s = t / 2,
            o = e / t,
            a = e / 2,
            c = [],
            f = [];
        for (let p = 0, v = 0, _ = -a; p <= t; p++, _ += o) {
            c.push(-a, 0, _, a, 0, _), c.push(_, 0, -a, _, 0, a);
            const w = p === s ? i : r;
            w.toArray(f, v),
                (v += 3),
                w.toArray(f, v),
                (v += 3),
                w.toArray(f, v),
                (v += 3),
                w.toArray(f, v),
                (v += 3);
        }
        const d = new bt();
        d.setAttribute('position', new nt(c, 3)), d.setAttribute('color', new nt(f, 3));
        const h = new Pi({ vertexColors: !0, toneMapped: !1 });
        super(d, h), (this.type = 'GridHelper');
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class Hz extends ps {
    constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
        (s = new je(s)), (o = new je(o));
        const a = [],
            c = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const p = (h / t) * (Math.PI * 2),
                    v = Math.sin(p) * e,
                    _ = Math.cos(p) * e;
                a.push(0, 0, 0), a.push(v, 0, _);
                const w = h & 1 ? s : o;
                c.push(w.r, w.g, w.b), c.push(w.r, w.g, w.b);
            }
        for (let h = 0; h < i; h++) {
            const p = h & 1 ? s : o,
                v = e - (e / i) * h;
            for (let _ = 0; _ < r; _++) {
                let w = (_ / r) * (Math.PI * 2),
                    x = Math.sin(w) * v,
                    g = Math.cos(w) * v;
                a.push(x, 0, g),
                    c.push(p.r, p.g, p.b),
                    (w = ((_ + 1) / r) * (Math.PI * 2)),
                    (x = Math.sin(w) * v),
                    (g = Math.cos(w) * v),
                    a.push(x, 0, g),
                    c.push(p.r, p.g, p.b);
            }
        }
        const f = new bt();
        f.setAttribute('position', new nt(a, 3)), f.setAttribute('color', new nt(c, 3));
        const d = new Pi({ vertexColors: !0, toneMapped: !1 });
        super(f, d), (this.type = 'PolarGridHelper');
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
const CE = new k(),
    $h = new k(),
    bE = new k();
class Vz extends Ht {
    constructor(e, t, i) {
        super(),
            (this.light = e),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = i),
            (this.type = 'DirectionalLightHelper'),
            t === void 0 && (t = 1);
        let r = new bt();
        r.setAttribute('position', new nt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        const s = new Pi({ fog: !1, toneMapped: !1 });
        (this.lightPlane = new ko(r, s)),
            this.add(this.lightPlane),
            (r = new bt()),
            r.setAttribute('position', new nt([0, 0, 0, 0, 0, 1], 3)),
            (this.targetLine = new ko(r, s)),
            this.add(this.targetLine),
            this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
            this.light.target.updateWorldMatrix(!0, !1),
            CE.setFromMatrixPosition(this.light.matrixWorld),
            $h.setFromMatrixPosition(this.light.target.matrixWorld),
            bE.subVectors($h, CE),
            this.lightPlane.lookAt($h),
            this.color !== void 0
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt($h),
            (this.targetLine.scale.z = bE.length());
    }
}
const ep = new k(),
    yn = new Hf();
class Gz extends ps {
    constructor(e) {
        const t = new bt(),
            i = new Pi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
            r = [],
            s = [],
            o = {};
        a('n1', 'n2'),
            a('n2', 'n4'),
            a('n4', 'n3'),
            a('n3', 'n1'),
            a('f1', 'f2'),
            a('f2', 'f4'),
            a('f4', 'f3'),
            a('f3', 'f1'),
            a('n1', 'f1'),
            a('n2', 'f2'),
            a('n3', 'f3'),
            a('n4', 'f4'),
            a('p', 'n1'),
            a('p', 'n2'),
            a('p', 'n3'),
            a('p', 'n4'),
            a('u1', 'u2'),
            a('u2', 'u3'),
            a('u3', 'u1'),
            a('c', 't'),
            a('p', 'c'),
            a('cn1', 'cn2'),
            a('cn3', 'cn4'),
            a('cf1', 'cf2'),
            a('cf3', 'cf4');
        function a(_, w) {
            c(_), c(w);
        }
        function c(_) {
            r.push(0, 0, 0),
                s.push(0, 0, 0),
                o[_] === void 0 && (o[_] = []),
                o[_].push(r.length / 3 - 1);
        }
        t.setAttribute('position', new nt(r, 3)),
            t.setAttribute('color', new nt(s, 3)),
            super(t, i),
            (this.type = 'CameraHelper'),
            (this.camera = e),
            this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.pointMap = o),
            this.update();
        const f = new je(16755200),
            d = new je(16711680),
            h = new je(43775),
            p = new je(16777215),
            v = new je(3355443);
        this.setColors(f, d, h, p, v);
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute('color');
        a.setXYZ(0, e.r, e.g, e.b),
            a.setXYZ(1, e.r, e.g, e.b),
            a.setXYZ(2, e.r, e.g, e.b),
            a.setXYZ(3, e.r, e.g, e.b),
            a.setXYZ(4, e.r, e.g, e.b),
            a.setXYZ(5, e.r, e.g, e.b),
            a.setXYZ(6, e.r, e.g, e.b),
            a.setXYZ(7, e.r, e.g, e.b),
            a.setXYZ(8, e.r, e.g, e.b),
            a.setXYZ(9, e.r, e.g, e.b),
            a.setXYZ(10, e.r, e.g, e.b),
            a.setXYZ(11, e.r, e.g, e.b),
            a.setXYZ(12, e.r, e.g, e.b),
            a.setXYZ(13, e.r, e.g, e.b),
            a.setXYZ(14, e.r, e.g, e.b),
            a.setXYZ(15, e.r, e.g, e.b),
            a.setXYZ(16, e.r, e.g, e.b),
            a.setXYZ(17, e.r, e.g, e.b),
            a.setXYZ(18, e.r, e.g, e.b),
            a.setXYZ(19, e.r, e.g, e.b),
            a.setXYZ(20, e.r, e.g, e.b),
            a.setXYZ(21, e.r, e.g, e.b),
            a.setXYZ(22, e.r, e.g, e.b),
            a.setXYZ(23, e.r, e.g, e.b),
            a.setXYZ(24, t.r, t.g, t.b),
            a.setXYZ(25, t.r, t.g, t.b),
            a.setXYZ(26, t.r, t.g, t.b),
            a.setXYZ(27, t.r, t.g, t.b),
            a.setXYZ(28, t.r, t.g, t.b),
            a.setXYZ(29, t.r, t.g, t.b),
            a.setXYZ(30, t.r, t.g, t.b),
            a.setXYZ(31, t.r, t.g, t.b),
            a.setXYZ(32, i.r, i.g, i.b),
            a.setXYZ(33, i.r, i.g, i.b),
            a.setXYZ(34, i.r, i.g, i.b),
            a.setXYZ(35, i.r, i.g, i.b),
            a.setXYZ(36, i.r, i.g, i.b),
            a.setXYZ(37, i.r, i.g, i.b),
            a.setXYZ(38, r.r, r.g, r.b),
            a.setXYZ(39, r.r, r.g, r.b),
            a.setXYZ(40, s.r, s.g, s.b),
            a.setXYZ(41, s.r, s.g, s.b),
            a.setXYZ(42, s.r, s.g, s.b),
            a.setXYZ(43, s.r, s.g, s.b),
            a.setXYZ(44, s.r, s.g, s.b),
            a.setXYZ(45, s.r, s.g, s.b),
            a.setXYZ(46, s.r, s.g, s.b),
            a.setXYZ(47, s.r, s.g, s.b),
            a.setXYZ(48, s.r, s.g, s.b),
            a.setXYZ(49, s.r, s.g, s.b),
            (a.needsUpdate = !0);
    }
    update() {
        const e = this.geometry,
            t = this.pointMap,
            i = 1,
            r = 1;
        yn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            An('c', t, e, yn, 0, 0, -1),
            An('t', t, e, yn, 0, 0, 1),
            An('n1', t, e, yn, -i, -r, -1),
            An('n2', t, e, yn, i, -r, -1),
            An('n3', t, e, yn, -i, r, -1),
            An('n4', t, e, yn, i, r, -1),
            An('f1', t, e, yn, -i, -r, 1),
            An('f2', t, e, yn, i, -r, 1),
            An('f3', t, e, yn, -i, r, 1),
            An('f4', t, e, yn, i, r, 1),
            An('u1', t, e, yn, i * 0.7, r * 1.1, -1),
            An('u2', t, e, yn, -i * 0.7, r * 1.1, -1),
            An('u3', t, e, yn, 0, r * 2, -1),
            An('cf1', t, e, yn, -i, 0, 1),
            An('cf2', t, e, yn, i, 0, 1),
            An('cf3', t, e, yn, 0, -r, 1),
            An('cf4', t, e, yn, 0, r, 1),
            An('cn1', t, e, yn, -i, 0, -1),
            An('cn2', t, e, yn, i, 0, -1),
            An('cn3', t, e, yn, 0, -r, -1),
            An('cn4', t, e, yn, 0, r, -1),
            (e.getAttribute('position').needsUpdate = !0);
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
function An(n, e, t, i, r, s, o) {
    ep.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const c = t.getAttribute('position');
        for (let f = 0, d = a.length; f < d; f++) c.setXYZ(a[f], ep.x, ep.y, ep.z);
    }
}
const tp = new Ci();
class Wz extends ps {
    constructor(e, t = 16776960) {
        const i = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
            ]),
            r = new Float32Array(8 * 3),
            s = new bt();
        s.setIndex(new Yt(i, 1)),
            s.setAttribute('position', new Yt(r, 3)),
            super(s, new Pi({ color: t, toneMapped: !1 })),
            (this.object = e),
            (this.type = 'BoxHelper'),
            (this.matrixAutoUpdate = !1),
            this.update();
    }
    update(e) {
        if (
            (e !== void 0 && console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
            this.object !== void 0 && tp.setFromObject(this.object),
            tp.isEmpty())
        )
            return;
        const t = tp.min,
            i = tp.max,
            r = this.geometry.attributes.position,
            s = r.array;
        (s[0] = i.x),
            (s[1] = i.y),
            (s[2] = i.z),
            (s[3] = t.x),
            (s[4] = i.y),
            (s[5] = i.z),
            (s[6] = t.x),
            (s[7] = t.y),
            (s[8] = i.z),
            (s[9] = i.x),
            (s[10] = t.y),
            (s[11] = i.z),
            (s[12] = i.x),
            (s[13] = i.y),
            (s[14] = t.z),
            (s[15] = t.x),
            (s[16] = i.y),
            (s[17] = t.z),
            (s[18] = t.x),
            (s[19] = t.y),
            (s[20] = t.z),
            (s[21] = i.x),
            (s[22] = t.y),
            (s[23] = t.z),
            (r.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
    }
    setFromObject(e) {
        return (this.object = e), this.update(), this;
    }
    copy(e, t) {
        return super.copy(e, t), (this.object = e.object), this;
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class jz extends ps {
    constructor(e, t = 16776960) {
        const i = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
            ]),
            r = [
                1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,
            ],
            s = new bt();
        s.setIndex(new Yt(i, 1)),
            s.setAttribute('position', new nt(r, 3)),
            super(s, new Pi({ color: t, toneMapped: !1 })),
            (this.box = e),
            (this.type = 'Box3Helper'),
            this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() ||
            (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            super.updateMatrixWorld(e));
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class Xz extends ko {
    constructor(e, t = 1, i = 16776960) {
        const r = i,
            s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
            o = new bt();
        o.setAttribute('position', new nt(s, 3)),
            o.computeBoundingSphere(),
            super(o, new Pi({ color: r, toneMapped: !1 })),
            (this.type = 'PlaneHelper'),
            (this.plane = e),
            (this.size = t);
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            c = new bt();
        c.setAttribute('position', new nt(a, 3)),
            c.computeBoundingSphere(),
            this.add(
                new On(
                    c,
                    new Go({
                        color: r,
                        opacity: 0.2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1,
                    })
                )
            );
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
            this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
            this.lookAt(this.plane.normal),
            this.translateZ(-this.plane.constant),
            super.updateMatrixWorld(e);
    }
    dispose() {
        this.geometry.dispose(),
            this.material.dispose(),
            this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
    }
}
const RE = new k();
let np, _0;
class Yz extends Ht {
    constructor(
        e = new k(0, 0, 1),
        t = new k(0, 0, 0),
        i = 1,
        r = 16776960,
        s = i * 0.2,
        o = s * 0.2
    ) {
        super(),
            (this.type = 'ArrowHelper'),
            np === void 0 &&
                ((np = new bt()),
                np.setAttribute('position', new nt([0, 0, 0, 0, 1, 0], 3)),
                (_0 = new Lu(0, 0.5, 1, 5, 1)),
                _0.translate(0, -0.5, 0)),
            this.position.copy(t),
            (this.line = new ko(np, new Pi({ color: r, toneMapped: !1 }))),
            (this.line.matrixAutoUpdate = !1),
            this.add(this.line),
            (this.cone = new On(_0, new Go({ color: r, toneMapped: !1 }))),
            (this.cone.matrixAutoUpdate = !1),
            this.add(this.cone),
            this.setDirection(e),
            this.setLength(i, s, o);
    }
    setDirection(e) {
        if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            RE.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(RE, t);
        }
    }
    setLength(e, t = e * 0.2, i = t * 0.2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(i, t, i),
            (this.cone.position.y = e),
            this.cone.updateMatrix();
    }
    setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e);
    }
    copy(e) {
        return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
    }
    dispose() {
        this.line.geometry.dispose(),
            this.line.material.dispose(),
            this.cone.geometry.dispose(),
            this.cone.material.dispose();
    }
}
class qz extends ps {
    constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            r = new bt();
        r.setAttribute('position', new nt(t, 3)), r.setAttribute('color', new nt(i, 3));
        const s = new Pi({ vertexColors: !0, toneMapped: !1 });
        super(r, s), (this.type = 'AxesHelper');
    }
    setColors(e, t, i) {
        const r = new je(),
            s = this.geometry.attributes.color.array;
        return (
            r.set(e),
            r.toArray(s, 0),
            r.toArray(s, 3),
            r.set(t),
            r.toArray(s, 6),
            r.toArray(s, 9),
            r.set(i),
            r.toArray(s, 12),
            r.toArray(s, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
        );
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class Zz {
    constructor() {
        (this.type = 'ShapePath'),
            (this.color = new je()),
            (this.subPaths = []),
            (this.currentPath = null);
    }
    moveTo(e, t) {
        return (
            (this.currentPath = new Ef()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t),
            this
        );
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r), this;
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this;
    }
    toShapes(e) {
        function t(g) {
            const S = [];
            for (let M = 0, T = g.length; M < T; M++) {
                const P = g[M],
                    A = new Ua();
                (A.curves = P.curves), S.push(A);
            }
            return S;
        }
        function i(g, S) {
            const M = S.length;
            let T = !1;
            for (let P = M - 1, A = 0; A < M; P = A++) {
                let R = S[P],
                    D = S[A],
                    G = D.x - R.x,
                    b = D.y - R.y;
                if (Math.abs(b) > Number.EPSILON) {
                    if (
                        (b < 0 && ((R = S[A]), (G = -G), (D = S[P]), (b = -b)),
                        g.y < R.y || g.y > D.y)
                    )
                        continue;
                    if (g.y === R.y) {
                        if (g.x === R.x) return !0;
                    } else {
                        const L = b * (g.x - R.x) - G * (g.y - R.y);
                        if (L === 0) return !0;
                        if (L < 0) continue;
                        T = !T;
                    }
                } else {
                    if (g.y !== R.y) continue;
                    if ((D.x <= g.x && g.x <= R.x) || (R.x <= g.x && g.x <= D.x)) return !0;
                }
            }
            return T;
        }
        const r = hs.isClockWise,
            s = this.subPaths;
        if (s.length === 0) return [];
        let o, a, c;
        const f = [];
        if (s.length === 1) return (a = s[0]), (c = new Ua()), (c.curves = a.curves), f.push(c), f;
        let d = !r(s[0].getPoints());
        d = e ? !d : d;
        const h = [],
            p = [];
        let v = [],
            _ = 0,
            w;
        (p[_] = void 0), (v[_] = []);
        for (let g = 0, S = s.length; g < S; g++)
            (a = s[g]),
                (w = a.getPoints()),
                (o = r(w)),
                (o = e ? !o : o),
                o
                    ? (!d && p[_] && _++,
                      (p[_] = { s: new Ua(), p: w }),
                      (p[_].s.curves = a.curves),
                      d && _++,
                      (v[_] = []))
                    : v[_].push({ h: a, p: w[0] });
        if (!p[0]) return t(s);
        if (p.length > 1) {
            let g = !1,
                S = 0;
            for (let M = 0, T = p.length; M < T; M++) h[M] = [];
            for (let M = 0, T = p.length; M < T; M++) {
                const P = v[M];
                for (let A = 0; A < P.length; A++) {
                    const R = P[A];
                    let D = !0;
                    for (let G = 0; G < p.length; G++)
                        i(R.p, p[G].p) && (M !== G && S++, D ? ((D = !1), h[G].push(R)) : (g = !0));
                    D && h[M].push(R);
                }
            }
            S > 0 && g === !1 && (v = h);
        }
        let x;
        for (let g = 0, S = p.length; g < S; g++) {
            (c = p[g].s), f.push(c), (x = v[g]);
            for (let M = 0, T = x.length; M < T; M++) c.holes.push(x[M].h);
        }
        return f;
    }
}
class Kz extends Vr {
    constructor(e = 1, t = 1, i = 1, r = {}) {
        console.warn(
            'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
        ),
            super(e, t, { ...r, count: i }),
            (this.isWebGLMultipleRenderTargets = !0);
    }
    get texture() {
        return this.textures;
    }
}
typeof __THREE_DEVTOOLS__ < 'u' &&
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: Tm } }));
typeof window < 'u' &&
    (window.__THREE__
        ? console.warn('WARNING: Multiple instances of Three.js being imported.')
        : (window.__THREE__ = Tm));
const Jz = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            ACESFilmicToneMapping: _x,
            AddEquation: So,
            AddOperation: iC,
            AdditiveAnimationBlendMode: Cx,
            AdditiveBlending: A_,
            AgXToneMapping: lC,
            AlphaFormat: hC,
            AlwaysCompare: PC,
            AlwaysDepth: K2,
            AlwaysStencilFunc: iy,
            AmbientLight: Ib,
            AnimationAction: Bb,
            AnimationClip: Pf,
            AnimationLoader: J4,
            AnimationMixer: Az,
            AnimationObjectGroup: Ez,
            AnimationUtils: Y4,
            ArcCurve: ib,
            ArrayCamera: YC,
            ArrowHelper: Yz,
            AttachedBindMode: L_,
            Audio: kb,
            AudioAnalyser: pz,
            AudioContext: e1,
            AudioListener: fz,
            AudioLoader: lz,
            AxesHelper: qz,
            BackSide: Ai,
            BasicDepthPacking: SC,
            BasicShadowMap: I2,
            BatchedMesh: eb,
            Bone: Bx,
            BooleanKeyframeTrack: qa,
            Box2: Nz,
            Box3: Ci,
            Box3Helper: jz,
            BoxGeometry: Ya,
            BoxHelper: Wz,
            BufferAttribute: Yt,
            BufferGeometry: bt,
            BufferGeometryLoader: Fb,
            ByteType: fC,
            Cache: Us,
            Camera: Hf,
            CameraHelper: Gz,
            CanvasTexture: v4,
            CapsuleGeometry: zm,
            CatmullRomCurve3: rb,
            CineonToneMapping: oC,
            CircleGeometry: Bm,
            ClampToEdgeWrapping: pi,
            Clock: t1,
            Color: je,
            ColorKeyframeTrack: Jx,
            ColorManagement: Gt,
            CompressedArrayTexture: m4,
            CompressedCubeTexture: g4,
            CompressedTexture: Fm,
            CompressedTextureLoader: Q4,
            ConeGeometry: Hm,
            ConstantAlphaFactor: Y2,
            ConstantColorFactor: j2,
            CubeCamera: kC,
            CubeReflectionMapping: Ws,
            CubeRefractionMapping: Fo,
            CubeTexture: Vf,
            CubeTextureLoader: $4,
            CubeUVReflectionMapping: Cu,
            CubicBezierCurve: Gx,
            CubicBezierCurve3: sb,
            CubicInterpolant: Eb,
            CullFaceBack: T_,
            CullFaceFront: L2,
            CullFaceFrontBack: tN,
            CullFaceNone: P2,
            Curve: jr,
            CurvePath: ab,
            CustomBlending: N2,
            CustomToneMapping: aC,
            CylinderGeometry: Lu,
            Cylindrical: Iz,
            Data3DTexture: Lx,
            DataArrayTexture: Lm,
            DataTexture: Do,
            DataTextureLoader: ez,
            DataUtils: uD,
            DecrementStencilOp: dN,
            DecrementWrapStencilOp: pN,
            DefaultLoadingManager: Cb,
            DepthFormat: No,
            DepthStencilFormat: Va,
            DepthTexture: Ux,
            DetachedBindMode: cC,
            DirectionalLight: Lb,
            DirectionalLightHelper: Vz,
            DiscreteInterpolant: Tb,
            DisplayP3ColorSpace: Pm,
            DodecahedronGeometry: Vm,
            DoubleSide: os,
            DstAlphaFactor: B2,
            DstColorFactor: V2,
            DynamicCopyUsage: RN,
            DynamicDrawUsage: wN,
            DynamicReadUsage: AN,
            EdgesGeometry: lb,
            EllipseCurve: km,
            EqualCompare: AC,
            EqualDepth: Q2,
            EqualStencilFunc: _N,
            EquirectangularReflectionMapping: ff,
            EquirectangularRefractionMapping: df,
            Euler: nr,
            EventDispatcher: qs,
            ExtrudeGeometry: Wm,
            FileLoader: js,
            Float16BufferAttribute: mD,
            Float32BufferAttribute: nt,
            FloatType: Ki,
            Fog: Dm,
            FogExp2: Nm,
            FramebufferTexture: p4,
            FrontSide: Gs,
            Frustum: Gf,
            GLBufferAttribute: Pz,
            GLSL1: LN,
            GLSL3: ry,
            GreaterCompare: CC,
            GreaterDepth: eC,
            GreaterEqualCompare: RC,
            GreaterEqualDepth: $2,
            GreaterEqualStencilFunc: MN,
            GreaterStencilFunc: xN,
            GridHelper: Bz,
            Group: $l,
            HalfFloatType: _u,
            HemisphereLight: bb,
            HemisphereLightHelper: zz,
            IcosahedronGeometry: jm,
            ImageBitmapLoader: az,
            ImageLoader: Lf,
            ImageUtils: Px,
            IncrementStencilOp: fN,
            IncrementWrapStencilOp: hN,
            InstancedBufferAttribute: Su,
            InstancedBufferGeometry: Ob,
            InstancedInterleavedBuffer: Rz,
            InstancedMesh: $C,
            Int16BufferAttribute: hD,
            Int32BufferAttribute: pD,
            Int8BufferAttribute: cD,
            IntType: yx,
            InterleavedBuffer: Um,
            InterleavedBufferAttribute: Ga,
            Interpolant: qf,
            InterpolateDiscrete: mf,
            InterpolateLinear: gf,
            InterpolateSmooth: Mp,
            InvertStencilOp: mN,
            KeepStencilOp: va,
            KeyframeTrack: Xr,
            LOD: JC,
            LatheGeometry: jf,
            Layers: Da,
            LessCompare: TC,
            LessDepth: J2,
            LessEqualCompare: bx,
            LessEqualDepth: cf,
            LessEqualStencilFunc: yN,
            LessStencilFunc: vN,
            Light: jo,
            LightProbe: Ub,
            Line: ko,
            Line3: Dz,
            LineBasicMaterial: Pi,
            LineCurve: Wx,
            LineCurve3: ob,
            LineDashedMaterial: Sb,
            LineLoop: tb,
            LineSegments: ps,
            LinearDisplayP3ColorSpace: Bf,
            LinearFilter: dn,
            LinearInterpolant: Kx,
            LinearMipMapLinearFilter: sN,
            LinearMipMapNearestFilter: rN,
            LinearMipmapLinearFilter: as,
            LinearMipmapNearestFilter: Hc,
            LinearSRGBColorSpace: Ys,
            LinearToneMapping: rC,
            LinearTransfer: _f,
            Loader: Hi,
            LoaderUtils: dy,
            LoadingManager: Qx,
            LoopOnce: _C,
            LoopPingPong: xC,
            LoopRepeat: yC,
            LuminanceAlphaFormat: mC,
            LuminanceFormat: pC,
            MOUSE: $I,
            Material: ii,
            MaterialLoader: Qm,
            MathUtils: XN,
            Matrix3: Et,
            Matrix4: ft,
            MaxEquation: P_,
            Mesh: On,
            MeshBasicMaterial: Go,
            MeshDepthMaterial: Ox,
            MeshDistanceMaterial: Fx,
            MeshLambertMaterial: yb,
            MeshMatcapMaterial: xb,
            MeshNormalMaterial: _b,
            MeshPhongMaterial: gb,
            MeshPhysicalMaterial: mb,
            MeshStandardMaterial: qx,
            MeshToonMaterial: vb,
            MinEquation: R_,
            MirroredRepeatWrapping: pf,
            MixOperation: nC,
            MultiplyBlending: b_,
            MultiplyOperation: zf,
            NearestFilter: bn,
            NearestMipMapLinearFilter: iN,
            NearestMipMapNearestFilter: nN,
            NearestMipmapLinearFilter: ya,
            NearestMipmapNearestFilter: $p,
            NeutralToneMapping: uC,
            NeverCompare: EC,
            NeverDepth: Z2,
            NeverStencilFunc: gN,
            NoBlending: ks,
            NoColorSpace: Ps,
            NoToneMapping: fs,
            NormalAnimationBlendMode: Rm,
            NormalBlending: Ia,
            NotEqualCompare: bC,
            NotEqualDepth: tC,
            NotEqualStencilFunc: SN,
            NumberKeyframeTrack: bf,
            Object3D: Ht,
            ObjectLoader: sz,
            ObjectSpaceNormalMap: wC,
            OctahedronGeometry: Xf,
            OneFactor: F2,
            OneMinusConstantAlphaFactor: q2,
            OneMinusConstantColorFactor: X2,
            OneMinusDstAlphaFactor: H2,
            OneMinusDstColorFactor: G2,
            OneMinusSrcAlphaFactor: Qp,
            OneMinusSrcColorFactor: z2,
            OrthographicCamera: Wf,
            P3Primaries: xf,
            PCFShadowMap: Am,
            PCFSoftShadowMap: Bc,
            PMREMGenerator: oy,
            Path: Ef,
            PerspectiveCamera: Zn,
            Plane: _o,
            PlaneGeometry: Ru,
            PlaneHelper: Xz,
            PointLight: Pb,
            PointLightHelper: Fz,
            Points: nb,
            PointsMaterial: Hx,
            PolarGridHelper: Hz,
            PolyhedronGeometry: Wo,
            PositionalAudio: hz,
            PropertyBinding: Ut,
            PropertyMixer: zb,
            QuadraticBezierCurve: jx,
            QuadraticBezierCurve3: Xx,
            Quaternion: Bi,
            QuaternionKeyframeTrack: Iu,
            QuaternionLinearInterpolant: Ab,
            RED_GREEN_RGTC2_Format: ty,
            RED_RGTC1_Format: vC,
            REVISION: Tm,
            RGBADepthPacking: MC,
            RGBAFormat: wi,
            RGBAIntegerFormat: Tx,
            RGBA_ASTC_10x10_Format: Z_,
            RGBA_ASTC_10x5_Format: X_,
            RGBA_ASTC_10x6_Format: Y_,
            RGBA_ASTC_10x8_Format: q_,
            RGBA_ASTC_12x10_Format: K_,
            RGBA_ASTC_12x12_Format: J_,
            RGBA_ASTC_4x4_Format: k_,
            RGBA_ASTC_5x4_Format: z_,
            RGBA_ASTC_5x5_Format: B_,
            RGBA_ASTC_6x5_Format: H_,
            RGBA_ASTC_6x6_Format: V_,
            RGBA_ASTC_8x5_Format: G_,
            RGBA_ASTC_8x6_Format: W_,
            RGBA_ASTC_8x8_Format: j_,
            RGBA_BPTC_Format: Sp,
            RGBA_ETC2_EAC_Format: F_,
            RGBA_PVRTC_2BPPV1_Format: U_,
            RGBA_PVRTC_4BPPV1_Format: D_,
            RGBA_S3TC_DXT1_Format: _p,
            RGBA_S3TC_DXT3_Format: yp,
            RGBA_S3TC_DXT5_Format: xp,
            RGB_BPTC_SIGNED_Format: Q_,
            RGB_BPTC_UNSIGNED_Format: $_,
            RGB_ETC1_Format: Ax,
            RGB_ETC2_Format: O_,
            RGB_PVRTC_2BPPV1_Format: N_,
            RGB_PVRTC_4BPPV1_Format: I_,
            RGB_S3TC_DXT1_Format: vp,
            RGFormat: gC,
            RGIntegerFormat: Ex,
            RawShaderMaterial: pb,
            Ray: bu,
            Raycaster: Hb,
            Rec709Primaries: yf,
            RectAreaLight: Nb,
            RedFormat: Mx,
            RedIntegerFormat: wx,
            ReinhardToneMapping: sC,
            RenderTarget: DC,
            RepeatWrapping: hf,
            ReplaceStencilOp: cN,
            ReverseSubtractEquation: U2,
            RingGeometry: Xm,
            SIGNED_RED_GREEN_RGTC2_Format: ny,
            SIGNED_RED_RGTC1_Format: ey,
            SRGBColorSpace: _r,
            SRGBTransfer: Jt,
            Scene: nm,
            ShaderChunk: Ct,
            ShaderLib: kr,
            ShaderMaterial: Gr,
            ShadowMaterial: hb,
            Shape: Ua,
            ShapeGeometry: Ym,
            ShapePath: Zz,
            ShapeUtils: hs,
            ShortType: dC,
            Skeleton: Om,
            SkeletonHelper: Oz,
            SkinnedMesh: QC,
            Source: Aa,
            Sphere: mi,
            SphereGeometry: Yf,
            Spherical: Lz,
            SphericalHarmonics3: Db,
            SplineCurve: Yx,
            SpotLight: Rb,
            SpotLightHelper: Uz,
            Sprite: KC,
            SpriteMaterial: zx,
            SrcAlphaFactor: Jp,
            SrcAlphaSaturateFactor: W2,
            SrcColorFactor: k2,
            StaticCopyUsage: bN,
            StaticDrawUsage: Sf,
            StaticReadUsage: TN,
            StereoCamera: uz,
            StreamCopyUsage: PN,
            StreamDrawUsage: EN,
            StreamReadUsage: CN,
            StringKeyframeTrack: Za,
            SubtractEquation: D2,
            SubtractiveBlending: C_,
            TOUCH: eN,
            TangentSpaceNormalMap: Vo,
            TetrahedronGeometry: qm,
            Texture: mn,
            TextureLoader: tz,
            TorusGeometry: Zm,
            TorusKnotGeometry: Km,
            Triangle: Ji,
            TriangleFanDrawMode: lN,
            TriangleStripDrawMode: aN,
            TrianglesDrawMode: oN,
            TubeGeometry: Jm,
            UVMapping: Cm,
            Uint16BufferAttribute: Ix,
            Uint32BufferAttribute: Nx,
            Uint8BufferAttribute: fD,
            Uint8ClampedBufferAttribute: dD,
            Uniform: r1,
            UniformsGroup: bz,
            UniformsLib: Ne,
            UniformsUtils: FC,
            UnsignedByteType: ds,
            UnsignedInt248Type: Io,
            UnsignedIntType: Ds,
            UnsignedShort4444Type: xx,
            UnsignedShort5551Type: Sx,
            UnsignedShortType: bm,
            VSMShadowMap: Dr,
            Vector2: _e,
            Vector3: k,
            Vector4: Wt,
            VectorKeyframeTrack: Rf,
            VideoTexture: h4,
            WebGL1Renderer: qC,
            WebGL3DRenderTarget: QN,
            WebGLArrayRenderTarget: JN,
            WebGLCoordinateSystem: ls,
            WebGLCubeRenderTarget: zC,
            WebGLMultipleRenderTargets: Kz,
            WebGLRenderTarget: Vr,
            WebGLRenderer: kx,
            WebGLUtils: XC,
            WebGPUCoordinateSystem: Mf,
            WireframeGeometry: db,
            WrapAroundEnding: vf,
            ZeroCurvatureEnding: Ea,
            ZeroFactor: O2,
            ZeroSlopeEnding: Ta,
            ZeroStencilOp: uN,
            _SRGBAFormat: em,
            createCanvasElement: IC,
        },
        Symbol.toStringTag,
        { value: 'Module' }
    )
);
var Gb = { exports: {} },
    Ka = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Ka.ConcurrentRoot = 1;
Ka.ContinuousEventPriority = 4;
Ka.DefaultEventPriority = 16;
Ka.DiscreteEventPriority = 1;
Ka.IdleEventPriority = 536870912;
Ka.LegacyRoot = 0;
Gb.exports = Ka;
var tu = Gb.exports;
function Qz(n) {
    let e;
    const t = new Set(),
        i = (f, d) => {
            const h = typeof f == 'function' ? f(e) : f;
            if (h !== e) {
                const p = e;
                (e = d ? h : Object.assign({}, e, h)), t.forEach((v) => v(e, p));
            }
        },
        r = () => e,
        s = (f, d = r, h = Object.is) => {
            console.warn('[DEPRECATED] Please use `subscribeWithSelector` middleware');
            let p = d(e);
            function v() {
                const _ = d(e);
                if (!h(p, _)) {
                    const w = p;
                    f((p = _), w);
                }
            }
            return t.add(v), () => t.delete(v);
        },
        c = {
            setState: i,
            getState: r,
            subscribe: (f, d, h) => (d || h ? s(f, d, h) : (t.add(f), () => t.delete(f))),
            destroy: () => t.clear(),
        };
    return (e = n(i, r, c)), c;
}
const $z =
        typeof window > 'u' ||
        !window.navigator ||
        /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    PE = $z ? pe.useEffect : pe.useLayoutEffect;
function eB(n) {
    const e = typeof n == 'function' ? Qz(n) : n,
        t = (i = e.getState, r = Object.is) => {
            const [, s] = pe.useReducer((x) => x + 1, 0),
                o = e.getState(),
                a = pe.useRef(o),
                c = pe.useRef(i),
                f = pe.useRef(r),
                d = pe.useRef(!1),
                h = pe.useRef();
            h.current === void 0 && (h.current = i(o));
            let p,
                v = !1;
            (a.current !== o || c.current !== i || f.current !== r || d.current) &&
                ((p = i(o)), (v = !r(h.current, p))),
                PE(() => {
                    v && (h.current = p),
                        (a.current = o),
                        (c.current = i),
                        (f.current = r),
                        (d.current = !1);
                });
            const _ = pe.useRef(o);
            PE(() => {
                const x = () => {
                        try {
                            const S = e.getState(),
                                M = c.current(S);
                            f.current(h.current, M) || ((a.current = S), (h.current = M), s());
                        } catch {
                            (d.current = !0), s();
                        }
                    },
                    g = e.subscribe(x);
                return e.getState() !== _.current && x(), g;
            }, []);
            const w = v ? p : h.current;
            return pe.useDebugValue(w), w;
        };
    return (
        Object.assign(t, e),
        (t[Symbol.iterator] = function () {
            console.warn('[useStore, api] = create() is deprecated and will be removed in v4');
            const i = [t, e];
            return {
                next() {
                    const r = i.length <= 0;
                    return { value: i.shift(), done: r };
                },
            };
        }),
        t
    );
}
var Wb = { exports: {} },
    y0 = { exports: {} },
    x0 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var LE;
function tB() {
    return (
        LE ||
            ((LE = 1),
            (function (n) {
                function e(N, B) {
                    var H = N.length;
                    N.push(B);
                    e: for (; 0 < H; ) {
                        var K = (H - 1) >>> 1,
                            le = N[K];
                        if (0 < r(le, B)) (N[K] = B), (N[H] = le), (H = K);
                        else break e;
                    }
                }
                function t(N) {
                    return N.length === 0 ? null : N[0];
                }
                function i(N) {
                    if (N.length === 0) return null;
                    var B = N[0],
                        H = N.pop();
                    if (H !== B) {
                        N[0] = H;
                        e: for (var K = 0, le = N.length, be = le >>> 1; K < be; ) {
                            var Q = 2 * (K + 1) - 1,
                                me = N[Q],
                                Se = Q + 1,
                                ke = N[Se];
                            if (0 > r(me, H))
                                Se < le && 0 > r(ke, me)
                                    ? ((N[K] = ke), (N[Se] = H), (K = Se))
                                    : ((N[K] = me), (N[Q] = H), (K = Q));
                            else if (Se < le && 0 > r(ke, H)) (N[K] = ke), (N[Se] = H), (K = Se);
                            else break e;
                        }
                    }
                    return B;
                }
                function r(N, B) {
                    var H = N.sortIndex - B.sortIndex;
                    return H !== 0 ? H : N.id - B.id;
                }
                if (typeof performance == 'object' && typeof performance.now == 'function') {
                    var s = performance;
                    n.unstable_now = function () {
                        return s.now();
                    };
                } else {
                    var o = Date,
                        a = o.now();
                    n.unstable_now = function () {
                        return o.now() - a;
                    };
                }
                var c = [],
                    f = [],
                    d = 1,
                    h = null,
                    p = 3,
                    v = !1,
                    _ = !1,
                    w = !1,
                    x = typeof setTimeout == 'function' ? setTimeout : null,
                    g = typeof clearTimeout == 'function' ? clearTimeout : null,
                    S = typeof setImmediate < 'u' ? setImmediate : null;
                typeof navigator < 'u' &&
                    navigator.scheduling !== void 0 &&
                    navigator.scheduling.isInputPending !== void 0 &&
                    navigator.scheduling.isInputPending.bind(navigator.scheduling);
                function M(N) {
                    for (var B = t(f); B !== null; ) {
                        if (B.callback === null) i(f);
                        else if (B.startTime <= N) i(f), (B.sortIndex = B.expirationTime), e(c, B);
                        else break;
                        B = t(f);
                    }
                }
                function T(N) {
                    if (((w = !1), M(N), !_))
                        if (t(c) !== null) (_ = !0), te(P);
                        else {
                            var B = t(f);
                            B !== null && ae(T, B.startTime - N);
                        }
                }
                function P(N, B) {
                    (_ = !1), w && ((w = !1), g(D), (D = -1)), (v = !0);
                    var H = p;
                    try {
                        for (
                            M(B), h = t(c);
                            h !== null && (!(h.expirationTime > B) || (N && !L()));

                        ) {
                            var K = h.callback;
                            if (typeof K == 'function') {
                                (h.callback = null), (p = h.priorityLevel);
                                var le = K(h.expirationTime <= B);
                                (B = n.unstable_now()),
                                    typeof le == 'function'
                                        ? (h.callback = le)
                                        : h === t(c) && i(c),
                                    M(B);
                            } else i(c);
                            h = t(c);
                        }
                        if (h !== null) var be = !0;
                        else {
                            var Q = t(f);
                            Q !== null && ae(T, Q.startTime - B), (be = !1);
                        }
                        return be;
                    } finally {
                        (h = null), (p = H), (v = !1);
                    }
                }
                var A = !1,
                    R = null,
                    D = -1,
                    G = 5,
                    b = -1;
                function L() {
                    return !(n.unstable_now() - b < G);
                }
                function ee() {
                    if (R !== null) {
                        var N = n.unstable_now();
                        b = N;
                        var B = !0;
                        try {
                            B = R(!0, N);
                        } finally {
                            B ? ie() : ((A = !1), (R = null));
                        }
                    } else A = !1;
                }
                var ie;
                if (typeof S == 'function')
                    ie = function () {
                        S(ee);
                    };
                else if (typeof MessageChannel < 'u') {
                    var j = new MessageChannel(),
                        oe = j.port2;
                    (j.port1.onmessage = ee),
                        (ie = function () {
                            oe.postMessage(null);
                        });
                } else
                    ie = function () {
                        x(ee, 0);
                    };
                function te(N) {
                    (R = N), A || ((A = !0), ie());
                }
                function ae(N, B) {
                    D = x(function () {
                        N(n.unstable_now());
                    }, B);
                }
                (n.unstable_IdlePriority = 5),
                    (n.unstable_ImmediatePriority = 1),
                    (n.unstable_LowPriority = 4),
                    (n.unstable_NormalPriority = 3),
                    (n.unstable_Profiling = null),
                    (n.unstable_UserBlockingPriority = 2),
                    (n.unstable_cancelCallback = function (N) {
                        N.callback = null;
                    }),
                    (n.unstable_continueExecution = function () {
                        _ || v || ((_ = !0), te(P));
                    }),
                    (n.unstable_forceFrameRate = function (N) {
                        0 > N || 125 < N
                            ? console.error(
                                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                              )
                            : (G = 0 < N ? Math.floor(1e3 / N) : 5);
                    }),
                    (n.unstable_getCurrentPriorityLevel = function () {
                        return p;
                    }),
                    (n.unstable_getFirstCallbackNode = function () {
                        return t(c);
                    }),
                    (n.unstable_next = function (N) {
                        switch (p) {
                            case 1:
                            case 2:
                            case 3:
                                var B = 3;
                                break;
                            default:
                                B = p;
                        }
                        var H = p;
                        p = B;
                        try {
                            return N();
                        } finally {
                            p = H;
                        }
                    }),
                    (n.unstable_pauseExecution = function () {}),
                    (n.unstable_requestPaint = function () {}),
                    (n.unstable_runWithPriority = function (N, B) {
                        switch (N) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                N = 3;
                        }
                        var H = p;
                        p = N;
                        try {
                            return B();
                        } finally {
                            p = H;
                        }
                    }),
                    (n.unstable_scheduleCallback = function (N, B, H) {
                        var K = n.unstable_now();
                        switch (
                            (typeof H == 'object' && H !== null
                                ? ((H = H.delay), (H = typeof H == 'number' && 0 < H ? K + H : K))
                                : (H = K),
                            N)
                        ) {
                            case 1:
                                var le = -1;
                                break;
                            case 2:
                                le = 250;
                                break;
                            case 5:
                                le = 1073741823;
                                break;
                            case 4:
                                le = 1e4;
                                break;
                            default:
                                le = 5e3;
                        }
                        return (
                            (le = H + le),
                            (N = {
                                id: d++,
                                callback: B,
                                priorityLevel: N,
                                startTime: H,
                                expirationTime: le,
                                sortIndex: -1,
                            }),
                            H > K
                                ? ((N.sortIndex = H),
                                  e(f, N),
                                  t(c) === null &&
                                      N === t(f) &&
                                      (w ? (g(D), (D = -1)) : (w = !0), ae(T, H - K)))
                                : ((N.sortIndex = le), e(c, N), _ || v || ((_ = !0), te(P))),
                            N
                        );
                    }),
                    (n.unstable_shouldYield = L),
                    (n.unstable_wrapCallback = function (N) {
                        var B = p;
                        return function () {
                            var H = p;
                            p = B;
                            try {
                                return N.apply(this, arguments);
                            } finally {
                                p = H;
                            }
                        };
                    });
            })(x0)),
        x0
    );
}
var IE;
function nB() {
    return IE || ((IE = 1), (y0.exports = tB())), y0.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var iB = function (e) {
    var t = {},
        i = pe,
        r = nB(),
        s = Object.assign;
    function o(l) {
        for (
            var u = 'https://reactjs.org/docs/error-decoder.html?invariant=' + l, m = 1;
            m < arguments.length;
            m++
        )
            u += '&args[]=' + encodeURIComponent(arguments[m]);
        return (
            'Minified React error #' +
            l +
            '; visit ' +
            u +
            ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
        );
    }
    var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        c = Symbol.for('react.element'),
        f = Symbol.for('react.portal'),
        d = Symbol.for('react.fragment'),
        h = Symbol.for('react.strict_mode'),
        p = Symbol.for('react.profiler'),
        v = Symbol.for('react.provider'),
        _ = Symbol.for('react.context'),
        w = Symbol.for('react.forward_ref'),
        x = Symbol.for('react.suspense'),
        g = Symbol.for('react.suspense_list'),
        S = Symbol.for('react.memo'),
        M = Symbol.for('react.lazy'),
        T = Symbol.for('react.offscreen'),
        P = Symbol.iterator;
    function A(l) {
        return l === null || typeof l != 'object'
            ? null
            : ((l = (P && l[P]) || l['@@iterator']), typeof l == 'function' ? l : null);
    }
    function R(l) {
        if (l == null) return null;
        if (typeof l == 'function') return l.displayName || l.name || null;
        if (typeof l == 'string') return l;
        switch (l) {
            case d:
                return 'Fragment';
            case f:
                return 'Portal';
            case p:
                return 'Profiler';
            case h:
                return 'StrictMode';
            case x:
                return 'Suspense';
            case g:
                return 'SuspenseList';
        }
        if (typeof l == 'object')
            switch (l.$$typeof) {
                case _:
                    return (l.displayName || 'Context') + '.Consumer';
                case v:
                    return (l._context.displayName || 'Context') + '.Provider';
                case w:
                    var u = l.render;
                    return (
                        (l = l.displayName),
                        l ||
                            ((l = u.displayName || u.name || ''),
                            (l = l !== '' ? 'ForwardRef(' + l + ')' : 'ForwardRef')),
                        l
                    );
                case S:
                    return (u = l.displayName || null), u !== null ? u : R(l.type) || 'Memo';
                case M:
                    (u = l._payload), (l = l._init);
                    try {
                        return R(l(u));
                    } catch {}
            }
        return null;
    }
    function D(l) {
        var u = l.type;
        switch (l.tag) {
            case 24:
                return 'Cache';
            case 9:
                return (u.displayName || 'Context') + '.Consumer';
            case 10:
                return (u._context.displayName || 'Context') + '.Provider';
            case 18:
                return 'DehydratedFragment';
            case 11:
                return (
                    (l = u.render),
                    (l = l.displayName || l.name || ''),
                    u.displayName || (l !== '' ? 'ForwardRef(' + l + ')' : 'ForwardRef')
                );
            case 7:
                return 'Fragment';
            case 5:
                return u;
            case 4:
                return 'Portal';
            case 3:
                return 'Root';
            case 6:
                return 'Text';
            case 16:
                return R(u);
            case 8:
                return u === h ? 'StrictMode' : 'Mode';
            case 22:
                return 'Offscreen';
            case 12:
                return 'Profiler';
            case 21:
                return 'Scope';
            case 13:
                return 'Suspense';
            case 19:
                return 'SuspenseList';
            case 25:
                return 'TracingMarker';
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof u == 'function') return u.displayName || u.name || null;
                if (typeof u == 'string') return u;
        }
        return null;
    }
    function G(l) {
        var u = l,
            m = l;
        if (l.alternate) for (; u.return; ) u = u.return;
        else {
            l = u;
            do (u = l), u.flags & 4098 && (m = u.return), (l = u.return);
            while (l);
        }
        return u.tag === 3 ? m : null;
    }
    function b(l) {
        if (G(l) !== l) throw Error(o(188));
    }
    function L(l) {
        var u = l.alternate;
        if (!u) {
            if (((u = G(l)), u === null)) throw Error(o(188));
            return u !== l ? null : l;
        }
        for (var m = l, y = u; ; ) {
            var E = m.return;
            if (E === null) break;
            var C = E.alternate;
            if (C === null) {
                if (((y = E.return), y !== null)) {
                    m = y;
                    continue;
                }
                break;
            }
            if (E.child === C.child) {
                for (C = E.child; C; ) {
                    if (C === m) return b(E), l;
                    if (C === y) return b(E), u;
                    C = C.sibling;
                }
                throw Error(o(188));
            }
            if (m.return !== y.return) (m = E), (y = C);
            else {
                for (var z = !1, Z = E.child; Z; ) {
                    if (Z === m) {
                        (z = !0), (m = E), (y = C);
                        break;
                    }
                    if (Z === y) {
                        (z = !0), (y = E), (m = C);
                        break;
                    }
                    Z = Z.sibling;
                }
                if (!z) {
                    for (Z = C.child; Z; ) {
                        if (Z === m) {
                            (z = !0), (m = C), (y = E);
                            break;
                        }
                        if (Z === y) {
                            (z = !0), (y = C), (m = E);
                            break;
                        }
                        Z = Z.sibling;
                    }
                    if (!z) throw Error(o(189));
                }
            }
            if (m.alternate !== y) throw Error(o(190));
        }
        if (m.tag !== 3) throw Error(o(188));
        return m.stateNode.current === m ? l : u;
    }
    function ee(l) {
        return (l = L(l)), l !== null ? ie(l) : null;
    }
    function ie(l) {
        if (l.tag === 5 || l.tag === 6) return l;
        for (l = l.child; l !== null; ) {
            var u = ie(l);
            if (u !== null) return u;
            l = l.sibling;
        }
        return null;
    }
    function j(l) {
        if (l.tag === 5 || l.tag === 6) return l;
        for (l = l.child; l !== null; ) {
            if (l.tag !== 4) {
                var u = j(l);
                if (u !== null) return u;
            }
            l = l.sibling;
        }
        return null;
    }
    var oe = Array.isArray,
        te = e.getPublicInstance,
        ae = e.getRootHostContext,
        N = e.getChildHostContext,
        B = e.prepareForCommit,
        H = e.resetAfterCommit,
        K = e.createInstance,
        le = e.appendInitialChild,
        be = e.finalizeInitialChildren,
        Q = e.prepareUpdate,
        me = e.shouldSetTextContent,
        Se = e.createTextInstance,
        ke = e.scheduleTimeout,
        et = e.cancelTimeout,
        Xe = e.noTimeout,
        gt = e.isPrimaryRenderer,
        De = e.supportsMutation,
        V = e.supportsPersistence,
        we = e.supportsHydration,
        ve = e.getInstanceFromNode,
        Ee = e.preparePortalMount,
        ye = e.getCurrentEventPriority,
        We = e.detachDeletedInstance,
        He = e.supportsMicrotasks,
        Ke = e.scheduleMicrotask,
        yt = e.supportsTestSelectors,
        F = e.findFiberRoot,
        I = e.getBoundingRect,
        ce = e.getTextContent,
        de = e.isHiddenSubtree,
        Me = e.matchAccessibilityRole,
        xe = e.setFocusIfFocusable,
        ut = e.setupIntersectionObserver,
        at = e.appendChild,
        Ae = e.appendChildToContainer,
        Ie = e.commitTextUpdate,
        ht = e.commitMount,
        Pe = e.commitUpdate,
        nn = e.insertBefore,
        wt = e.insertInContainerBefore,
        rt = e.removeChild,
        tt = e.removeChildFromContainer,
        Qe = e.resetTextContent,
        Lt = e.hideInstance,
        vt = e.hideTextInstance,
        Xt = e.unhideInstance,
        q = e.unhideTextInstance,
        Fe = e.clearContainer,
        U = e.cloneInstance,
        W = e.createContainerChildSet,
        Y = e.appendChildToContainerChildSet,
        ge = e.finalizeContainerChildren,
        Ce = e.replaceContainerChildren,
        it = e.cloneHiddenInstance,
        $e = e.cloneHiddenTextInstance,
        Oe = e.canHydrateInstance,
        Ge = e.canHydrateTextInstance,
        pt = e.canHydrateSuspenseInstance,
        rn = e.isSuspenseInstancePending,
        _t = e.isSuspenseInstanceFallback,
        Dt = e.registerSuspenseInstanceRetry,
        Kt = e.getNextHydratableSibling,
        Pn = e.getFirstHydratableChild,
        ln = e.getFirstHydratableChildWithinContainer,
        Ar = e.getFirstHydratableChildWithinSuspenseInstance,
        Xo = e.hydrateInstance,
        Yr = e.hydrateTextInstance,
        sr = e.hydrateSuspenseInstance,
        O = e.getNextHydratableInstanceAfterSuspenseInstance,
        $ = e.commitHydratedContainer,
        se = e.commitHydratedSuspenseInstance,
        ue = e.clearSuspenseBoundary,
        ne = e.clearSuspenseBoundaryFromContainer,
        ze = e.shouldDeleteUnhydratedTailInstances,
        Re = e.didNotMatchHydratedContainerTextInstance,
        Ue = e.didNotMatchHydratedTextInstance,
        Je;
    function ct(l) {
        if (Je === void 0)
            try {
                throw Error();
            } catch (m) {
                var u = m.stack.trim().match(/\n( *(at )?)/);
                Je = (u && u[1]) || '';
            }
        return (
            `
` +
            Je +
            l
        );
    }
    var mt = !1;
    function xt(l, u) {
        if (!l || mt) return '';
        mt = !0;
        var m = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (u)
                if (
                    ((u = function () {
                        throw Error();
                    }),
                    Object.defineProperty(u.prototype, 'props', {
                        set: function () {
                            throw Error();
                        },
                    }),
                    typeof Reflect == 'object' && Reflect.construct)
                ) {
                    try {
                        Reflect.construct(u, []);
                    } catch (Le) {
                        var y = Le;
                    }
                    Reflect.construct(l, [], u);
                } else {
                    try {
                        u.call();
                    } catch (Le) {
                        y = Le;
                    }
                    l.call(u.prototype);
                }
            else {
                try {
                    throw Error();
                } catch (Le) {
                    y = Le;
                }
                l();
            }
        } catch (Le) {
            if (Le && y && typeof Le.stack == 'string') {
                for (
                    var E = Le.stack.split(`
`),
                        C = y.stack.split(`
`),
                        z = E.length - 1,
                        Z = C.length - 1;
                    1 <= z && 0 <= Z && E[z] !== C[Z];

                )
                    Z--;
                for (; 1 <= z && 0 <= Z; z--, Z--)
                    if (E[z] !== C[Z]) {
                        if (z !== 1 || Z !== 1)
                            do
                                if ((z--, Z--, 0 > Z || E[z] !== C[Z])) {
                                    var he =
                                        `
` + E[z].replace(' at new ', ' at ');
                                    return (
                                        l.displayName &&
                                            he.includes('<anonymous>') &&
                                            (he = he.replace('<anonymous>', l.displayName)),
                                        he
                                    );
                                }
                            while (1 <= z && 0 <= Z);
                        break;
                    }
            }
        } finally {
            (mt = !1), (Error.prepareStackTrace = m);
        }
        return (l = l ? l.displayName || l.name : '') ? ct(l) : '';
    }
    var un = Object.prototype.hasOwnProperty,
        Jn = [],
        $t = -1;
    function Vn(l) {
        return { current: l };
    }
    function dt(l) {
        0 > $t || ((l.current = Jn[$t]), (Jn[$t] = null), $t--);
    }
    function Ye(l, u) {
        $t++, (Jn[$t] = l.current), (l.current = u);
    }
    var or = {},
        At = Vn(or),
        vn = Vn(!1),
        qr = or;
    function ar(l, u) {
        var m = l.type.contextTypes;
        if (!m) return or;
        var y = l.stateNode;
        if (y && y.__reactInternalMemoizedUnmaskedChildContext === u)
            return y.__reactInternalMemoizedMaskedChildContext;
        var E = {},
            C;
        for (C in m) E[C] = u[C];
        return (
            y &&
                ((l = l.stateNode),
                (l.__reactInternalMemoizedUnmaskedChildContext = u),
                (l.__reactInternalMemoizedMaskedChildContext = E)),
            E
        );
    }
    function Gn(l) {
        return (l = l.childContextTypes), l != null;
    }
    function En() {
        dt(vn), dt(At);
    }
    function Zr(l, u, m) {
        if (At.current !== or) throw Error(o(168));
        Ye(At, u), Ye(vn, m);
    }
    function Ja(l, u, m) {
        var y = l.stateNode;
        if (((u = u.childContextTypes), typeof y.getChildContext != 'function')) return m;
        y = y.getChildContext();
        for (var E in y) if (!(E in u)) throw Error(o(108, D(l) || 'Unknown', E));
        return s({}, m, y);
    }
    function Qn(l) {
        return (
            (l = ((l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext) || or),
            (qr = At.current),
            Ye(At, l),
            Ye(vn, vn.current),
            !0
        );
    }
    function Qa(l, u, m) {
        var y = l.stateNode;
        if (!y) throw Error(o(169));
        m
            ? ((l = Ja(l, u, qr)),
              (y.__reactInternalMemoizedMergedChildContext = l),
              dt(vn),
              dt(At),
              Ye(At, l))
            : dt(vn),
            Ye(vn, m);
    }
    var Vi = Math.clz32 ? Math.clz32 : SR,
        Jf = Math.log,
        xR = Math.LN2;
    function SR(l) {
        return (l >>>= 0), l === 0 ? 32 : (31 - ((Jf(l) / xR) | 0)) | 0;
    }
    var Qf = 64,
        $f = 4194304;
    function Nu(l) {
        switch (l & -l) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return l & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return l & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return l;
        }
    }
    function ed(l, u) {
        var m = l.pendingLanes;
        if (m === 0) return 0;
        var y = 0,
            E = l.suspendedLanes,
            C = l.pingedLanes,
            z = m & 268435455;
        if (z !== 0) {
            var Z = z & ~E;
            Z !== 0 ? (y = Nu(Z)) : ((C &= z), C !== 0 && (y = Nu(C)));
        } else (z = m & ~E), z !== 0 ? (y = Nu(z)) : C !== 0 && (y = Nu(C));
        if (y === 0) return 0;
        if (
            u !== 0 &&
            u !== y &&
            !(u & E) &&
            ((E = y & -y), (C = u & -u), E >= C || (E === 16 && (C & 4194240) !== 0))
        )
            return u;
        if ((y & 4 && (y |= m & 16), (u = l.entangledLanes), u !== 0))
            for (l = l.entanglements, u &= y; 0 < u; )
                (m = 31 - Vi(u)), (E = 1 << m), (y |= l[m]), (u &= ~E);
        return y;
    }
    function MR(l, u) {
        switch (l) {
            case 1:
            case 2:
            case 4:
                return u + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return u + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1;
        }
    }
    function wR(l, u) {
        for (
            var m = l.suspendedLanes, y = l.pingedLanes, E = l.expirationTimes, C = l.pendingLanes;
            0 < C;

        ) {
            var z = 31 - Vi(C),
                Z = 1 << z,
                he = E[z];
            he === -1 ? (!(Z & m) || Z & y) && (E[z] = MR(Z, u)) : he <= u && (l.expiredLanes |= Z),
                (C &= ~Z);
        }
    }
    function ng(l) {
        return (l = l.pendingLanes & -1073741825), l !== 0 ? l : l & 1073741824 ? 1073741824 : 0;
    }
    function ig(l) {
        for (var u = [], m = 0; 31 > m; m++) u.push(l);
        return u;
    }
    function Du(l, u, m) {
        (l.pendingLanes |= u),
            u !== 536870912 && ((l.suspendedLanes = 0), (l.pingedLanes = 0)),
            (l = l.eventTimes),
            (u = 31 - Vi(u)),
            (l[u] = m);
    }
    function ER(l, u) {
        var m = l.pendingLanes & ~u;
        (l.pendingLanes = u),
            (l.suspendedLanes = 0),
            (l.pingedLanes = 0),
            (l.expiredLanes &= u),
            (l.mutableReadLanes &= u),
            (l.entangledLanes &= u),
            (u = l.entanglements);
        var y = l.eventTimes;
        for (l = l.expirationTimes; 0 < m; ) {
            var E = 31 - Vi(m),
                C = 1 << E;
            (u[E] = 0), (y[E] = -1), (l[E] = -1), (m &= ~C);
        }
    }
    function rg(l, u) {
        var m = (l.entangledLanes |= u);
        for (l = l.entanglements; m; ) {
            var y = 31 - Vi(m),
                E = 1 << y;
            (E & u) | (l[y] & u) && (l[y] |= u), (m &= ~E);
        }
    }
    var Ft = 0;
    function c1(l) {
        return (l &= -l), 1 < l ? (4 < l ? (l & 268435455 ? 16 : 536870912) : 4) : 1;
    }
    var sg = r.unstable_scheduleCallback,
        f1 = r.unstable_cancelCallback,
        TR = r.unstable_shouldYield,
        AR = r.unstable_requestPaint,
        Wn = r.unstable_now,
        og = r.unstable_ImmediatePriority,
        CR = r.unstable_UserBlockingPriority,
        ag = r.unstable_NormalPriority,
        bR = r.unstable_IdlePriority,
        td = null,
        Kr = null;
    function RR(l) {
        if (Kr && typeof Kr.onCommitFiberRoot == 'function')
            try {
                Kr.onCommitFiberRoot(td, l, void 0, (l.current.flags & 128) === 128);
            } catch {}
    }
    function PR(l, u) {
        return (l === u && (l !== 0 || 1 / l === 1 / u)) || (l !== l && u !== u);
    }
    var Jr = typeof Object.is == 'function' ? Object.is : PR,
        ms = null,
        nd = !1,
        lg = !1;
    function d1(l) {
        ms === null ? (ms = [l]) : ms.push(l);
    }
    function LR(l) {
        (nd = !0), d1(l);
    }
    function Qr() {
        if (!lg && ms !== null) {
            lg = !0;
            var l = 0,
                u = Ft;
            try {
                var m = ms;
                for (Ft = 1; l < m.length; l++) {
                    var y = m[l];
                    do y = y(!0);
                    while (y !== null);
                }
                (ms = null), (nd = !1);
            } catch (E) {
                throw (ms !== null && (ms = ms.slice(l + 1)), sg(og, Qr), E);
            } finally {
                (Ft = u), (lg = !1);
            }
        }
        return null;
    }
    var IR = a.ReactCurrentBatchConfig;
    function id(l, u) {
        if (Jr(l, u)) return !0;
        if (typeof l != 'object' || l === null || typeof u != 'object' || u === null) return !1;
        var m = Object.keys(l),
            y = Object.keys(u);
        if (m.length !== y.length) return !1;
        for (y = 0; y < m.length; y++) {
            var E = m[y];
            if (!un.call(u, E) || !Jr(l[E], u[E])) return !1;
        }
        return !0;
    }
    function NR(l) {
        switch (l.tag) {
            case 5:
                return ct(l.type);
            case 16:
                return ct('Lazy');
            case 13:
                return ct('Suspense');
            case 19:
                return ct('SuspenseList');
            case 0:
            case 2:
            case 15:
                return (l = xt(l.type, !1)), l;
            case 11:
                return (l = xt(l.type.render, !1)), l;
            case 1:
                return (l = xt(l.type, !0)), l;
            default:
                return '';
        }
    }
    function Cr(l, u) {
        if (l && l.defaultProps) {
            (u = s({}, u)), (l = l.defaultProps);
            for (var m in l) u[m] === void 0 && (u[m] = l[m]);
            return u;
        }
        return u;
    }
    var rd = Vn(null),
        sd = null,
        $a = null,
        ug = null;
    function cg() {
        ug = $a = sd = null;
    }
    function h1(l, u, m) {
        gt
            ? (Ye(rd, u._currentValue), (u._currentValue = m))
            : (Ye(rd, u._currentValue2), (u._currentValue2 = m));
    }
    function fg(l) {
        var u = rd.current;
        dt(rd), gt ? (l._currentValue = u) : (l._currentValue2 = u);
    }
    function dg(l, u, m) {
        for (; l !== null; ) {
            var y = l.alternate;
            if (
                ((l.childLanes & u) !== u
                    ? ((l.childLanes |= u), y !== null && (y.childLanes |= u))
                    : y !== null && (y.childLanes & u) !== u && (y.childLanes |= u),
                l === m)
            )
                break;
            l = l.return;
        }
    }
    function el(l, u) {
        (sd = l),
            (ug = $a = null),
            (l = l.dependencies),
            l !== null &&
                l.firstContext !== null &&
                (l.lanes & u && (ji = !0), (l.firstContext = null));
    }
    function lr(l) {
        var u = gt ? l._currentValue : l._currentValue2;
        if (ug !== l)
            if (((l = { context: l, memoizedValue: u, next: null }), $a === null)) {
                if (sd === null) throw Error(o(308));
                ($a = l), (sd.dependencies = { lanes: 0, firstContext: l });
            } else $a = $a.next = l;
        return u;
    }
    var $r = null,
        Ks = !1;
    function hg(l) {
        l.updateQueue = {
            baseState: l.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
        };
    }
    function p1(l, u) {
        (l = l.updateQueue),
            u.updateQueue === l &&
                (u.updateQueue = {
                    baseState: l.baseState,
                    firstBaseUpdate: l.firstBaseUpdate,
                    lastBaseUpdate: l.lastBaseUpdate,
                    shared: l.shared,
                    effects: l.effects,
                });
    }
    function gs(l, u) {
        return { eventTime: l, lane: u, tag: 0, payload: null, callback: null, next: null };
    }
    function Js(l, u) {
        var m = l.updateQueue;
        m !== null &&
            ((m = m.shared),
            Ln !== null && l.mode & 1 && !(Pt & 2)
                ? ((l = m.interleaved),
                  l === null
                      ? ((u.next = u), $r === null ? ($r = [m]) : $r.push(m))
                      : ((u.next = l.next), (l.next = u)),
                  (m.interleaved = u))
                : ((l = m.pending),
                  l === null ? (u.next = u) : ((u.next = l.next), (l.next = u)),
                  (m.pending = u)));
    }
    function od(l, u, m) {
        if (((u = u.updateQueue), u !== null && ((u = u.shared), (m & 4194240) !== 0))) {
            var y = u.lanes;
            (y &= l.pendingLanes), (m |= y), (u.lanes = m), rg(l, m);
        }
    }
    function m1(l, u) {
        var m = l.updateQueue,
            y = l.alternate;
        if (y !== null && ((y = y.updateQueue), m === y)) {
            var E = null,
                C = null;
            if (((m = m.firstBaseUpdate), m !== null)) {
                do {
                    var z = {
                        eventTime: m.eventTime,
                        lane: m.lane,
                        tag: m.tag,
                        payload: m.payload,
                        callback: m.callback,
                        next: null,
                    };
                    C === null ? (E = C = z) : (C = C.next = z), (m = m.next);
                } while (m !== null);
                C === null ? (E = C = u) : (C = C.next = u);
            } else E = C = u;
            (m = {
                baseState: y.baseState,
                firstBaseUpdate: E,
                lastBaseUpdate: C,
                shared: y.shared,
                effects: y.effects,
            }),
                (l.updateQueue = m);
            return;
        }
        (l = m.lastBaseUpdate),
            l === null ? (m.firstBaseUpdate = u) : (l.next = u),
            (m.lastBaseUpdate = u);
    }
    function ad(l, u, m, y) {
        var E = l.updateQueue;
        Ks = !1;
        var C = E.firstBaseUpdate,
            z = E.lastBaseUpdate,
            Z = E.shared.pending;
        if (Z !== null) {
            E.shared.pending = null;
            var he = Z,
                Le = he.next;
            (he.next = null), z === null ? (C = Le) : (z.next = Le), (z = he);
            var Ze = l.alternate;
            Ze !== null &&
                ((Ze = Ze.updateQueue),
                (Z = Ze.lastBaseUpdate),
                Z !== z &&
                    (Z === null ? (Ze.firstBaseUpdate = Le) : (Z.next = Le),
                    (Ze.lastBaseUpdate = he)));
        }
        if (C !== null) {
            var St = E.baseState;
            (z = 0), (Ze = Le = he = null), (Z = C);
            do {
                var lt = Z.lane,
                    qt = Z.eventTime;
                if ((y & lt) === lt) {
                    Ze !== null &&
                        (Ze = Ze.next =
                            {
                                eventTime: qt,
                                lane: 0,
                                tag: Z.tag,
                                payload: Z.payload,
                                callback: Z.callback,
                                next: null,
                            });
                    e: {
                        var ot = l,
                            ai = Z;
                        switch (((lt = u), (qt = m), ai.tag)) {
                            case 1:
                                if (((ot = ai.payload), typeof ot == 'function')) {
                                    St = ot.call(qt, St, lt);
                                    break e;
                                }
                                St = ot;
                                break e;
                            case 3:
                                ot.flags = (ot.flags & -65537) | 128;
                            case 0:
                                if (
                                    ((ot = ai.payload),
                                    (lt = typeof ot == 'function' ? ot.call(qt, St, lt) : ot),
                                    lt == null)
                                )
                                    break e;
                                St = s({}, St, lt);
                                break e;
                            case 2:
                                Ks = !0;
                        }
                    }
                    Z.callback !== null &&
                        Z.lane !== 0 &&
                        ((l.flags |= 64),
                        (lt = E.effects),
                        lt === null ? (E.effects = [Z]) : lt.push(Z));
                } else
                    (qt = {
                        eventTime: qt,
                        lane: lt,
                        tag: Z.tag,
                        payload: Z.payload,
                        callback: Z.callback,
                        next: null,
                    }),
                        Ze === null ? ((Le = Ze = qt), (he = St)) : (Ze = Ze.next = qt),
                        (z |= lt);
                if (((Z = Z.next), Z === null)) {
                    if (((Z = E.shared.pending), Z === null)) break;
                    (lt = Z),
                        (Z = lt.next),
                        (lt.next = null),
                        (E.lastBaseUpdate = lt),
                        (E.shared.pending = null);
                }
            } while (1);
            if (
                (Ze === null && (he = St),
                (E.baseState = he),
                (E.firstBaseUpdate = Le),
                (E.lastBaseUpdate = Ze),
                (u = E.shared.interleaved),
                u !== null)
            ) {
                E = u;
                do (z |= E.lane), (E = E.next);
                while (E !== u);
            } else C === null && (E.shared.lanes = 0);
            (ul |= z), (l.lanes = z), (l.memoizedState = St);
        }
    }
    function g1(l, u, m) {
        if (((l = u.effects), (u.effects = null), l !== null))
            for (u = 0; u < l.length; u++) {
                var y = l[u],
                    E = y.callback;
                if (E !== null) {
                    if (((y.callback = null), (y = m), typeof E != 'function'))
                        throw Error(o(191, E));
                    E.call(y);
                }
            }
    }
    var v1 = new i.Component().refs;
    function pg(l, u, m, y) {
        (u = l.memoizedState),
            (m = m(y, u)),
            (m = m == null ? u : s({}, u, m)),
            (l.memoizedState = m),
            l.lanes === 0 && (l.updateQueue.baseState = m);
    }
    var ld = {
        isMounted: function (l) {
            return (l = l._reactInternals) ? G(l) === l : !1;
        },
        enqueueSetState: function (l, u, m) {
            l = l._reactInternals;
            var y = _i(),
                E = eo(l),
                C = gs(y, E);
            (C.payload = u),
                m != null && (C.callback = m),
                Js(l, C),
                (u = hr(l, E, y)),
                u !== null && od(u, l, E);
        },
        enqueueReplaceState: function (l, u, m) {
            l = l._reactInternals;
            var y = _i(),
                E = eo(l),
                C = gs(y, E);
            (C.tag = 1),
                (C.payload = u),
                m != null && (C.callback = m),
                Js(l, C),
                (u = hr(l, E, y)),
                u !== null && od(u, l, E);
        },
        enqueueForceUpdate: function (l, u) {
            l = l._reactInternals;
            var m = _i(),
                y = eo(l),
                E = gs(m, y);
            (E.tag = 2),
                u != null && (E.callback = u),
                Js(l, E),
                (u = hr(l, y, m)),
                u !== null && od(u, l, y);
        },
    };
    function _1(l, u, m, y, E, C, z) {
        return (
            (l = l.stateNode),
            typeof l.shouldComponentUpdate == 'function'
                ? l.shouldComponentUpdate(y, C, z)
                : u.prototype && u.prototype.isPureReactComponent
                ? !id(m, y) || !id(E, C)
                : !0
        );
    }
    function y1(l, u, m) {
        var y = !1,
            E = or,
            C = u.contextType;
        return (
            typeof C == 'object' && C !== null
                ? (C = lr(C))
                : ((E = Gn(u) ? qr : At.current),
                  (y = u.contextTypes),
                  (C = (y = y != null) ? ar(l, E) : or)),
            (u = new u(m, C)),
            (l.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null),
            (u.updater = ld),
            (l.stateNode = u),
            (u._reactInternals = l),
            y &&
                ((l = l.stateNode),
                (l.__reactInternalMemoizedUnmaskedChildContext = E),
                (l.__reactInternalMemoizedMaskedChildContext = C)),
            u
        );
    }
    function x1(l, u, m, y) {
        (l = u.state),
            typeof u.componentWillReceiveProps == 'function' && u.componentWillReceiveProps(m, y),
            typeof u.UNSAFE_componentWillReceiveProps == 'function' &&
                u.UNSAFE_componentWillReceiveProps(m, y),
            u.state !== l && ld.enqueueReplaceState(u, u.state, null);
    }
    function mg(l, u, m, y) {
        var E = l.stateNode;
        (E.props = m), (E.state = l.memoizedState), (E.refs = v1), hg(l);
        var C = u.contextType;
        typeof C == 'object' && C !== null
            ? (E.context = lr(C))
            : ((C = Gn(u) ? qr : At.current), (E.context = ar(l, C))),
            (E.state = l.memoizedState),
            (C = u.getDerivedStateFromProps),
            typeof C == 'function' && (pg(l, u, C, m), (E.state = l.memoizedState)),
            typeof u.getDerivedStateFromProps == 'function' ||
                typeof E.getSnapshotBeforeUpdate == 'function' ||
                (typeof E.UNSAFE_componentWillMount != 'function' &&
                    typeof E.componentWillMount != 'function') ||
                ((u = E.state),
                typeof E.componentWillMount == 'function' && E.componentWillMount(),
                typeof E.UNSAFE_componentWillMount == 'function' && E.UNSAFE_componentWillMount(),
                u !== E.state && ld.enqueueReplaceState(E, E.state, null),
                ad(l, m, E, y),
                (E.state = l.memoizedState)),
            typeof E.componentDidMount == 'function' && (l.flags |= 4194308);
    }
    var tl = [],
        nl = 0,
        ud = null,
        cd = 0,
        ur = [],
        cr = 0,
        Yo = null,
        vs = 1,
        _s = '';
    function qo(l, u) {
        (tl[nl++] = cd), (tl[nl++] = ud), (ud = l), (cd = u);
    }
    function S1(l, u, m) {
        (ur[cr++] = vs), (ur[cr++] = _s), (ur[cr++] = Yo), (Yo = l);
        var y = vs;
        l = _s;
        var E = 32 - Vi(y) - 1;
        (y &= ~(1 << E)), (m += 1);
        var C = 32 - Vi(u) + E;
        if (30 < C) {
            var z = E - (E % 5);
            (C = (y & ((1 << z) - 1)).toString(32)),
                (y >>= z),
                (E -= z),
                (vs = (1 << (32 - Vi(u) + E)) | (m << E) | y),
                (_s = C + l);
        } else (vs = (1 << C) | (m << E) | y), (_s = l);
    }
    function gg(l) {
        l.return !== null && (qo(l, 1), S1(l, 1, 0));
    }
    function vg(l) {
        for (; l === ud; ) (ud = tl[--nl]), (tl[nl] = null), (cd = tl[--nl]), (tl[nl] = null);
        for (; l === Yo; )
            (Yo = ur[--cr]),
                (ur[cr] = null),
                (_s = ur[--cr]),
                (ur[cr] = null),
                (vs = ur[--cr]),
                (ur[cr] = null);
    }
    var Gi = null,
        Wi = null,
        sn = !1,
        Uu = !1,
        br = null;
    function M1(l, u) {
        var m = pr(5, null, null, 0);
        (m.elementType = 'DELETED'),
            (m.stateNode = u),
            (m.return = l),
            (u = l.deletions),
            u === null ? ((l.deletions = [m]), (l.flags |= 16)) : u.push(m);
    }
    function w1(l, u) {
        switch (l.tag) {
            case 5:
                return (
                    (u = Oe(u, l.type, l.pendingProps)),
                    u !== null ? ((l.stateNode = u), (Gi = l), (Wi = Pn(u)), !0) : !1
                );
            case 6:
                return (
                    (u = Ge(u, l.pendingProps)),
                    u !== null ? ((l.stateNode = u), (Gi = l), (Wi = null), !0) : !1
                );
            case 13:
                if (((u = pt(u)), u !== null)) {
                    var m = Yo !== null ? { id: vs, overflow: _s } : null;
                    return (
                        (l.memoizedState = {
                            dehydrated: u,
                            treeContext: m,
                            retryLane: 1073741824,
                        }),
                        (m = pr(18, null, null, 0)),
                        (m.stateNode = u),
                        (m.return = l),
                        (l.child = m),
                        (Gi = l),
                        (Wi = null),
                        !0
                    );
                }
                return !1;
            default:
                return !1;
        }
    }
    function _g(l) {
        return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
    }
    function yg(l) {
        if (sn) {
            var u = Wi;
            if (u) {
                var m = u;
                if (!w1(l, u)) {
                    if (_g(l)) throw Error(o(418));
                    u = Kt(m);
                    var y = Gi;
                    u && w1(l, u)
                        ? M1(y, m)
                        : ((l.flags = (l.flags & -4097) | 2), (sn = !1), (Gi = l));
                }
            } else {
                if (_g(l)) throw Error(o(418));
                (l.flags = (l.flags & -4097) | 2), (sn = !1), (Gi = l);
            }
        }
    }
    function E1(l) {
        for (l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13; ) l = l.return;
        Gi = l;
    }
    function Ou(l) {
        if (!we || l !== Gi) return !1;
        if (!sn) return E1(l), (sn = !0), !1;
        if (l.tag !== 3 && (l.tag !== 5 || (ze(l.type) && !me(l.type, l.memoizedProps)))) {
            var u = Wi;
            if (u) {
                if (_g(l)) {
                    for (l = Wi; l; ) l = Kt(l);
                    throw Error(o(418));
                }
                for (; u; ) M1(l, u), (u = Kt(u));
            }
        }
        if ((E1(l), l.tag === 13)) {
            if (!we) throw Error(o(316));
            if (((l = l.memoizedState), (l = l !== null ? l.dehydrated : null), !l))
                throw Error(o(317));
            Wi = O(l);
        } else Wi = Gi ? Kt(l.stateNode) : null;
        return !0;
    }
    function il() {
        we && ((Wi = Gi = null), (Uu = sn = !1));
    }
    function xg(l) {
        br === null ? (br = [l]) : br.push(l);
    }
    function Fu(l, u, m) {
        if (((l = m.ref), l !== null && typeof l != 'function' && typeof l != 'object')) {
            if (m._owner) {
                if (((m = m._owner), m)) {
                    if (m.tag !== 1) throw Error(o(309));
                    var y = m.stateNode;
                }
                if (!y) throw Error(o(147, l));
                var E = y,
                    C = '' + l;
                return u !== null &&
                    u.ref !== null &&
                    typeof u.ref == 'function' &&
                    u.ref._stringRef === C
                    ? u.ref
                    : ((u = function (z) {
                          var Z = E.refs;
                          Z === v1 && (Z = E.refs = {}), z === null ? delete Z[C] : (Z[C] = z);
                      }),
                      (u._stringRef = C),
                      u);
            }
            if (typeof l != 'string') throw Error(o(284));
            if (!m._owner) throw Error(o(290, l));
        }
        return l;
    }
    function fd(l, u) {
        throw (
            ((l = Object.prototype.toString.call(u)),
            Error(
                o(
                    31,
                    l === '[object Object]'
                        ? 'object with keys {' + Object.keys(u).join(', ') + '}'
                        : l
                )
            ))
        );
    }
    function T1(l) {
        var u = l._init;
        return u(l._payload);
    }
    function A1(l) {
        function u(re, J) {
            if (l) {
                var fe = re.deletions;
                fe === null ? ((re.deletions = [J]), (re.flags |= 16)) : fe.push(J);
            }
        }
        function m(re, J) {
            if (!l) return null;
            for (; J !== null; ) u(re, J), (J = J.sibling);
            return null;
        }
        function y(re, J) {
            for (re = new Map(); J !== null; )
                J.key !== null ? re.set(J.key, J) : re.set(J.index, J), (J = J.sibling);
            return re;
        }
        function E(re, J) {
            return (re = no(re, J)), (re.index = 0), (re.sibling = null), re;
        }
        function C(re, J, fe) {
            return (
                (re.index = fe),
                l
                    ? ((fe = re.alternate),
                      fe !== null
                          ? ((fe = fe.index), fe < J ? ((re.flags |= 2), J) : fe)
                          : ((re.flags |= 2), J))
                    : ((re.flags |= 1048576), J)
            );
        }
        function z(re) {
            return l && re.alternate === null && (re.flags |= 2), re;
        }
        function Z(re, J, fe, Ve) {
            return J === null || J.tag !== 6
                ? ((J = iv(fe, re.mode, Ve)), (J.return = re), J)
                : ((J = E(J, fe)), (J.return = re), J);
        }
        function he(re, J, fe, Ve) {
            var st = fe.type;
            return st === d
                ? Ze(re, J, fe.props.children, Ve, fe.key)
                : J !== null &&
                  (J.elementType === st ||
                      (typeof st == 'object' &&
                          st !== null &&
                          st.$$typeof === M &&
                          T1(st) === J.type))
                ? ((Ve = E(J, fe.props)), (Ve.ref = Fu(re, J, fe)), (Ve.return = re), Ve)
                : ((Ve = Vd(fe.type, fe.key, fe.props, null, re.mode, Ve)),
                  (Ve.ref = Fu(re, J, fe)),
                  (Ve.return = re),
                  Ve);
        }
        function Le(re, J, fe, Ve) {
            return J === null ||
                J.tag !== 4 ||
                J.stateNode.containerInfo !== fe.containerInfo ||
                J.stateNode.implementation !== fe.implementation
                ? ((J = rv(fe, re.mode, Ve)), (J.return = re), J)
                : ((J = E(J, fe.children || [])), (J.return = re), J);
        }
        function Ze(re, J, fe, Ve, st) {
            return J === null || J.tag !== 7
                ? ((J = ta(fe, re.mode, Ve, st)), (J.return = re), J)
                : ((J = E(J, fe)), (J.return = re), J);
        }
        function St(re, J, fe) {
            if ((typeof J == 'string' && J !== '') || typeof J == 'number')
                return (J = iv('' + J, re.mode, fe)), (J.return = re), J;
            if (typeof J == 'object' && J !== null) {
                switch (J.$$typeof) {
                    case c:
                        return (
                            (fe = Vd(J.type, J.key, J.props, null, re.mode, fe)),
                            (fe.ref = Fu(re, null, J)),
                            (fe.return = re),
                            fe
                        );
                    case f:
                        return (J = rv(J, re.mode, fe)), (J.return = re), J;
                    case M:
                        var Ve = J._init;
                        return St(re, Ve(J._payload), fe);
                }
                if (oe(J) || A(J)) return (J = ta(J, re.mode, fe, null)), (J.return = re), J;
                fd(re, J);
            }
            return null;
        }
        function lt(re, J, fe, Ve) {
            var st = J !== null ? J.key : null;
            if ((typeof fe == 'string' && fe !== '') || typeof fe == 'number')
                return st !== null ? null : Z(re, J, '' + fe, Ve);
            if (typeof fe == 'object' && fe !== null) {
                switch (fe.$$typeof) {
                    case c:
                        return fe.key === st ? he(re, J, fe, Ve) : null;
                    case f:
                        return fe.key === st ? Le(re, J, fe, Ve) : null;
                    case M:
                        return (st = fe._init), lt(re, J, st(fe._payload), Ve);
                }
                if (oe(fe) || A(fe)) return st !== null ? null : Ze(re, J, fe, Ve, null);
                fd(re, fe);
            }
            return null;
        }
        function qt(re, J, fe, Ve, st) {
            if ((typeof Ve == 'string' && Ve !== '') || typeof Ve == 'number')
                return (re = re.get(fe) || null), Z(J, re, '' + Ve, st);
            if (typeof Ve == 'object' && Ve !== null) {
                switch (Ve.$$typeof) {
                    case c:
                        return (
                            (re = re.get(Ve.key === null ? fe : Ve.key) || null), he(J, re, Ve, st)
                        );
                    case f:
                        return (
                            (re = re.get(Ve.key === null ? fe : Ve.key) || null), Le(J, re, Ve, st)
                        );
                    case M:
                        var Rt = Ve._init;
                        return qt(re, J, fe, Rt(Ve._payload), st);
                }
                if (oe(Ve) || A(Ve)) return (re = re.get(fe) || null), Ze(J, re, Ve, st, null);
                fd(J, Ve);
            }
            return null;
        }
        function ot(re, J, fe, Ve) {
            for (
                var st = null, Rt = null, Mt = J, kt = (J = 0), Xn = null;
                Mt !== null && kt < fe.length;
                kt++
            ) {
                Mt.index > kt ? ((Xn = Mt), (Mt = null)) : (Xn = Mt.sibling);
                var zt = lt(re, Mt, fe[kt], Ve);
                if (zt === null) {
                    Mt === null && (Mt = Xn);
                    break;
                }
                l && Mt && zt.alternate === null && u(re, Mt),
                    (J = C(zt, J, kt)),
                    Rt === null ? (st = zt) : (Rt.sibling = zt),
                    (Rt = zt),
                    (Mt = Xn);
            }
            if (kt === fe.length) return m(re, Mt), sn && qo(re, kt), st;
            if (Mt === null) {
                for (; kt < fe.length; kt++)
                    (Mt = St(re, fe[kt], Ve)),
                        Mt !== null &&
                            ((J = C(Mt, J, kt)),
                            Rt === null ? (st = Mt) : (Rt.sibling = Mt),
                            (Rt = Mt));
                return sn && qo(re, kt), st;
            }
            for (Mt = y(re, Mt); kt < fe.length; kt++)
                (Xn = qt(Mt, re, kt, fe[kt], Ve)),
                    Xn !== null &&
                        (l && Xn.alternate !== null && Mt.delete(Xn.key === null ? kt : Xn.key),
                        (J = C(Xn, J, kt)),
                        Rt === null ? (st = Xn) : (Rt.sibling = Xn),
                        (Rt = Xn));
            return (
                l &&
                    Mt.forEach(function (io) {
                        return u(re, io);
                    }),
                sn && qo(re, kt),
                st
            );
        }
        function ai(re, J, fe, Ve) {
            var st = A(fe);
            if (typeof st != 'function') throw Error(o(150));
            if (((fe = st.call(fe)), fe == null)) throw Error(o(151));
            for (
                var Rt = (st = null), Mt = J, kt = (J = 0), Xn = null, zt = fe.next();
                Mt !== null && !zt.done;
                kt++, zt = fe.next()
            ) {
                Mt.index > kt ? ((Xn = Mt), (Mt = null)) : (Xn = Mt.sibling);
                var io = lt(re, Mt, zt.value, Ve);
                if (io === null) {
                    Mt === null && (Mt = Xn);
                    break;
                }
                l && Mt && io.alternate === null && u(re, Mt),
                    (J = C(io, J, kt)),
                    Rt === null ? (st = io) : (Rt.sibling = io),
                    (Rt = io),
                    (Mt = Xn);
            }
            if (zt.done) return m(re, Mt), sn && qo(re, kt), st;
            if (Mt === null) {
                for (; !zt.done; kt++, zt = fe.next())
                    (zt = St(re, zt.value, Ve)),
                        zt !== null &&
                            ((J = C(zt, J, kt)),
                            Rt === null ? (st = zt) : (Rt.sibling = zt),
                            (Rt = zt));
                return sn && qo(re, kt), st;
            }
            for (Mt = y(re, Mt); !zt.done; kt++, zt = fe.next())
                (zt = qt(Mt, re, kt, zt.value, Ve)),
                    zt !== null &&
                        (l && zt.alternate !== null && Mt.delete(zt.key === null ? kt : zt.key),
                        (J = C(zt, J, kt)),
                        Rt === null ? (st = zt) : (Rt.sibling = zt),
                        (Rt = zt));
            return (
                l &&
                    Mt.forEach(function (uP) {
                        return u(re, uP);
                    }),
                sn && qo(re, kt),
                st
            );
        }
        function mr(re, J, fe, Ve) {
            if (
                (typeof fe == 'object' &&
                    fe !== null &&
                    fe.type === d &&
                    fe.key === null &&
                    (fe = fe.props.children),
                typeof fe == 'object' && fe !== null)
            ) {
                switch (fe.$$typeof) {
                    case c:
                        e: {
                            for (var st = fe.key, Rt = J; Rt !== null; ) {
                                if (Rt.key === st) {
                                    if (((st = fe.type), st === d)) {
                                        if (Rt.tag === 7) {
                                            m(re, Rt.sibling),
                                                (J = E(Rt, fe.props.children)),
                                                (J.return = re),
                                                (re = J);
                                            break e;
                                        }
                                    } else if (
                                        Rt.elementType === st ||
                                        (typeof st == 'object' &&
                                            st !== null &&
                                            st.$$typeof === M &&
                                            T1(st) === Rt.type)
                                    ) {
                                        m(re, Rt.sibling),
                                            (J = E(Rt, fe.props)),
                                            (J.ref = Fu(re, Rt, fe)),
                                            (J.return = re),
                                            (re = J);
                                        break e;
                                    }
                                    m(re, Rt);
                                    break;
                                } else u(re, Rt);
                                Rt = Rt.sibling;
                            }
                            fe.type === d
                                ? ((J = ta(fe.props.children, re.mode, Ve, fe.key)),
                                  (J.return = re),
                                  (re = J))
                                : ((Ve = Vd(fe.type, fe.key, fe.props, null, re.mode, Ve)),
                                  (Ve.ref = Fu(re, J, fe)),
                                  (Ve.return = re),
                                  (re = Ve));
                        }
                        return z(re);
                    case f:
                        e: {
                            for (Rt = fe.key; J !== null; ) {
                                if (J.key === Rt)
                                    if (
                                        J.tag === 4 &&
                                        J.stateNode.containerInfo === fe.containerInfo &&
                                        J.stateNode.implementation === fe.implementation
                                    ) {
                                        m(re, J.sibling),
                                            (J = E(J, fe.children || [])),
                                            (J.return = re),
                                            (re = J);
                                        break e;
                                    } else {
                                        m(re, J);
                                        break;
                                    }
                                else u(re, J);
                                J = J.sibling;
                            }
                            (J = rv(fe, re.mode, Ve)), (J.return = re), (re = J);
                        }
                        return z(re);
                    case M:
                        return (Rt = fe._init), mr(re, J, Rt(fe._payload), Ve);
                }
                if (oe(fe)) return ot(re, J, fe, Ve);
                if (A(fe)) return ai(re, J, fe, Ve);
                fd(re, fe);
            }
            return (typeof fe == 'string' && fe !== '') || typeof fe == 'number'
                ? ((fe = '' + fe),
                  J !== null && J.tag === 6
                      ? (m(re, J.sibling), (J = E(J, fe)), (J.return = re), (re = J))
                      : (m(re, J), (J = iv(fe, re.mode, Ve)), (J.return = re), (re = J)),
                  z(re))
                : m(re, J);
        }
        return mr;
    }
    var rl = A1(!0),
        C1 = A1(!1),
        ku = {},
        fr = Vn(ku),
        zu = Vn(ku),
        sl = Vn(ku);
    function es(l) {
        if (l === ku) throw Error(o(174));
        return l;
    }
    function Sg(l, u) {
        Ye(sl, u), Ye(zu, l), Ye(fr, ku), (l = ae(u)), dt(fr), Ye(fr, l);
    }
    function ol() {
        dt(fr), dt(zu), dt(sl);
    }
    function b1(l) {
        var u = es(sl.current),
            m = es(fr.current);
        (u = N(m, l.type, u)), m !== u && (Ye(zu, l), Ye(fr, u));
    }
    function Mg(l) {
        zu.current === l && (dt(fr), dt(zu));
    }
    var cn = Vn(0);
    function dd(l) {
        for (var u = l; u !== null; ) {
            if (u.tag === 13) {
                var m = u.memoizedState;
                if (m !== null && ((m = m.dehydrated), m === null || rn(m) || _t(m))) return u;
            } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                if (u.flags & 128) return u;
            } else if (u.child !== null) {
                (u.child.return = u), (u = u.child);
                continue;
            }
            if (u === l) break;
            for (; u.sibling === null; ) {
                if (u.return === null || u.return === l) return null;
                u = u.return;
            }
            (u.sibling.return = u.return), (u = u.sibling);
        }
        return null;
    }
    var wg = [];
    function Eg() {
        for (var l = 0; l < wg.length; l++) {
            var u = wg[l];
            gt
                ? (u._workInProgressVersionPrimary = null)
                : (u._workInProgressVersionSecondary = null);
        }
        wg.length = 0;
    }
    var hd = a.ReactCurrentDispatcher,
        dr = a.ReactCurrentBatchConfig,
        al = 0,
        _n = null,
        ri = null,
        jn = null,
        pd = !1,
        Bu = !1,
        Hu = 0,
        DR = 0;
    function si() {
        throw Error(o(321));
    }
    function Tg(l, u) {
        if (u === null) return !1;
        for (var m = 0; m < u.length && m < l.length; m++) if (!Jr(l[m], u[m])) return !1;
        return !0;
    }
    function Ag(l, u, m, y, E, C) {
        if (
            ((al = C),
            (_n = u),
            (u.memoizedState = null),
            (u.updateQueue = null),
            (u.lanes = 0),
            (hd.current = l === null || l.memoizedState === null ? kR : zR),
            (l = m(y, E)),
            Bu)
        ) {
            C = 0;
            do {
                if (((Bu = !1), (Hu = 0), 25 <= C)) throw Error(o(301));
                (C += 1),
                    (jn = ri = null),
                    (u.updateQueue = null),
                    (hd.current = BR),
                    (l = m(y, E));
            } while (Bu);
        }
        if (
            ((hd.current = yd),
            (u = ri !== null && ri.next !== null),
            (al = 0),
            (jn = ri = _n = null),
            (pd = !1),
            u)
        )
            throw Error(o(300));
        return l;
    }
    function Cg() {
        var l = Hu !== 0;
        return (Hu = 0), l;
    }
    function ys() {
        var l = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        return jn === null ? (_n.memoizedState = jn = l) : (jn = jn.next = l), jn;
    }
    function ts() {
        if (ri === null) {
            var l = _n.alternate;
            l = l !== null ? l.memoizedState : null;
        } else l = ri.next;
        var u = jn === null ? _n.memoizedState : jn.next;
        if (u !== null) (jn = u), (ri = l);
        else {
            if (l === null) throw Error(o(310));
            (ri = l),
                (l = {
                    memoizedState: ri.memoizedState,
                    baseState: ri.baseState,
                    baseQueue: ri.baseQueue,
                    queue: ri.queue,
                    next: null,
                }),
                jn === null ? (_n.memoizedState = jn = l) : (jn = jn.next = l);
        }
        return jn;
    }
    function Zo(l, u) {
        return typeof u == 'function' ? u(l) : u;
    }
    function md(l) {
        var u = ts(),
            m = u.queue;
        if (m === null) throw Error(o(311));
        m.lastRenderedReducer = l;
        var y = ri,
            E = y.baseQueue,
            C = m.pending;
        if (C !== null) {
            if (E !== null) {
                var z = E.next;
                (E.next = C.next), (C.next = z);
            }
            (y.baseQueue = E = C), (m.pending = null);
        }
        if (E !== null) {
            (C = E.next), (y = y.baseState);
            var Z = (z = null),
                he = null,
                Le = C;
            do {
                var Ze = Le.lane;
                if ((al & Ze) === Ze)
                    he !== null &&
                        (he = he.next =
                            {
                                lane: 0,
                                action: Le.action,
                                hasEagerState: Le.hasEagerState,
                                eagerState: Le.eagerState,
                                next: null,
                            }),
                        (y = Le.hasEagerState ? Le.eagerState : l(y, Le.action));
                else {
                    var St = {
                        lane: Ze,
                        action: Le.action,
                        hasEagerState: Le.hasEagerState,
                        eagerState: Le.eagerState,
                        next: null,
                    };
                    he === null ? ((Z = he = St), (z = y)) : (he = he.next = St),
                        (_n.lanes |= Ze),
                        (ul |= Ze);
                }
                Le = Le.next;
            } while (Le !== null && Le !== C);
            he === null ? (z = y) : (he.next = Z),
                Jr(y, u.memoizedState) || (ji = !0),
                (u.memoizedState = y),
                (u.baseState = z),
                (u.baseQueue = he),
                (m.lastRenderedState = y);
        }
        if (((l = m.interleaved), l !== null)) {
            E = l;
            do (C = E.lane), (_n.lanes |= C), (ul |= C), (E = E.next);
            while (E !== l);
        } else E === null && (m.lanes = 0);
        return [u.memoizedState, m.dispatch];
    }
    function gd(l) {
        var u = ts(),
            m = u.queue;
        if (m === null) throw Error(o(311));
        m.lastRenderedReducer = l;
        var y = m.dispatch,
            E = m.pending,
            C = u.memoizedState;
        if (E !== null) {
            m.pending = null;
            var z = (E = E.next);
            do (C = l(C, z.action)), (z = z.next);
            while (z !== E);
            Jr(C, u.memoizedState) || (ji = !0),
                (u.memoizedState = C),
                u.baseQueue === null && (u.baseState = C),
                (m.lastRenderedState = C);
        }
        return [C, y];
    }
    function R1() {}
    function P1(l, u) {
        var m = _n,
            y = ts(),
            E = u(),
            C = !Jr(y.memoizedState, E);
        if (
            (C && ((y.memoizedState = E), (ji = !0)),
            (y = y.queue),
            Gu(N1.bind(null, m, y, l), [l]),
            y.getSnapshot !== u || C || (jn !== null && jn.memoizedState.tag & 1))
        ) {
            if (((m.flags |= 2048), Vu(9, I1.bind(null, m, y, E, u), void 0, null), Ln === null))
                throw Error(o(349));
            al & 30 || L1(m, u, E);
        }
        return E;
    }
    function L1(l, u, m) {
        (l.flags |= 16384),
            (l = { getSnapshot: u, value: m }),
            (u = _n.updateQueue),
            u === null
                ? ((u = { lastEffect: null, stores: null }), (_n.updateQueue = u), (u.stores = [l]))
                : ((m = u.stores), m === null ? (u.stores = [l]) : m.push(l));
    }
    function I1(l, u, m, y) {
        (u.value = m), (u.getSnapshot = y), D1(u) && hr(l, 1, -1);
    }
    function N1(l, u, m) {
        return m(function () {
            D1(u) && hr(l, 1, -1);
        });
    }
    function D1(l) {
        var u = l.getSnapshot;
        l = l.value;
        try {
            var m = u();
            return !Jr(l, m);
        } catch {
            return !0;
        }
    }
    function bg(l) {
        var u = ys();
        return (
            typeof l == 'function' && (l = l()),
            (u.memoizedState = u.baseState = l),
            (l = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Zo,
                lastRenderedState: l,
            }),
            (u.queue = l),
            (l = l.dispatch = FR.bind(null, _n, l)),
            [u.memoizedState, l]
        );
    }
    function Vu(l, u, m, y) {
        return (
            (l = { tag: l, create: u, destroy: m, deps: y, next: null }),
            (u = _n.updateQueue),
            u === null
                ? ((u = { lastEffect: null, stores: null }),
                  (_n.updateQueue = u),
                  (u.lastEffect = l.next = l))
                : ((m = u.lastEffect),
                  m === null
                      ? (u.lastEffect = l.next = l)
                      : ((y = m.next), (m.next = l), (l.next = y), (u.lastEffect = l))),
            l
        );
    }
    function U1() {
        return ts().memoizedState;
    }
    function vd(l, u, m, y) {
        var E = ys();
        (_n.flags |= l), (E.memoizedState = Vu(1 | u, m, void 0, y === void 0 ? null : y));
    }
    function _d(l, u, m, y) {
        var E = ts();
        y = y === void 0 ? null : y;
        var C = void 0;
        if (ri !== null) {
            var z = ri.memoizedState;
            if (((C = z.destroy), y !== null && Tg(y, z.deps))) {
                E.memoizedState = Vu(u, m, C, y);
                return;
            }
        }
        (_n.flags |= l), (E.memoizedState = Vu(1 | u, m, C, y));
    }
    function Rg(l, u) {
        return vd(8390656, 8, l, u);
    }
    function Gu(l, u) {
        return _d(2048, 8, l, u);
    }
    function O1(l, u) {
        return _d(4, 2, l, u);
    }
    function F1(l, u) {
        return _d(4, 4, l, u);
    }
    function k1(l, u) {
        if (typeof u == 'function')
            return (
                (l = l()),
                u(l),
                function () {
                    u(null);
                }
            );
        if (u != null)
            return (
                (l = l()),
                (u.current = l),
                function () {
                    u.current = null;
                }
            );
    }
    function z1(l, u, m) {
        return (m = m != null ? m.concat([l]) : null), _d(4, 4, k1.bind(null, u, l), m);
    }
    function Pg() {}
    function B1(l, u) {
        var m = ts();
        u = u === void 0 ? null : u;
        var y = m.memoizedState;
        return y !== null && u !== null && Tg(u, y[1]) ? y[0] : ((m.memoizedState = [l, u]), l);
    }
    function H1(l, u) {
        var m = ts();
        u = u === void 0 ? null : u;
        var y = m.memoizedState;
        return y !== null && u !== null && Tg(u, y[1])
            ? y[0]
            : ((l = l()), (m.memoizedState = [l, u]), l);
    }
    function UR(l, u) {
        var m = Ft;
        (Ft = m !== 0 && 4 > m ? m : 4), l(!0);
        var y = dr.transition;
        dr.transition = {};
        try {
            l(!1), u();
        } finally {
            (Ft = m), (dr.transition = y);
        }
    }
    function V1() {
        return ts().memoizedState;
    }
    function OR(l, u, m) {
        var y = eo(l);
        (m = { lane: y, action: m, hasEagerState: !1, eagerState: null, next: null }),
            G1(l)
                ? W1(u, m)
                : (j1(l, u, m), (m = _i()), (l = hr(l, y, m)), l !== null && X1(l, u, y));
    }
    function FR(l, u, m) {
        var y = eo(l),
            E = { lane: y, action: m, hasEagerState: !1, eagerState: null, next: null };
        if (G1(l)) W1(u, E);
        else {
            j1(l, u, E);
            var C = l.alternate;
            if (
                l.lanes === 0 &&
                (C === null || C.lanes === 0) &&
                ((C = u.lastRenderedReducer), C !== null)
            )
                try {
                    var z = u.lastRenderedState,
                        Z = C(z, m);
                    if (((E.hasEagerState = !0), (E.eagerState = Z), Jr(Z, z))) return;
                } catch {
                } finally {
                }
            (m = _i()), (l = hr(l, y, m)), l !== null && X1(l, u, y);
        }
    }
    function G1(l) {
        var u = l.alternate;
        return l === _n || (u !== null && u === _n);
    }
    function W1(l, u) {
        Bu = pd = !0;
        var m = l.pending;
        m === null ? (u.next = u) : ((u.next = m.next), (m.next = u)), (l.pending = u);
    }
    function j1(l, u, m) {
        Ln !== null && l.mode & 1 && !(Pt & 2)
            ? ((l = u.interleaved),
              l === null
                  ? ((m.next = m), $r === null ? ($r = [u]) : $r.push(u))
                  : ((m.next = l.next), (l.next = m)),
              (u.interleaved = m))
            : ((l = u.pending),
              l === null ? (m.next = m) : ((m.next = l.next), (l.next = m)),
              (u.pending = m));
    }
    function X1(l, u, m) {
        if (m & 4194240) {
            var y = u.lanes;
            (y &= l.pendingLanes), (m |= y), (u.lanes = m), rg(l, m);
        }
    }
    var yd = {
            readContext: lr,
            useCallback: si,
            useContext: si,
            useEffect: si,
            useImperativeHandle: si,
            useInsertionEffect: si,
            useLayoutEffect: si,
            useMemo: si,
            useReducer: si,
            useRef: si,
            useState: si,
            useDebugValue: si,
            useDeferredValue: si,
            useTransition: si,
            useMutableSource: si,
            useSyncExternalStore: si,
            useId: si,
            unstable_isNewReconciler: !1,
        },
        kR = {
            readContext: lr,
            useCallback: function (l, u) {
                return (ys().memoizedState = [l, u === void 0 ? null : u]), l;
            },
            useContext: lr,
            useEffect: Rg,
            useImperativeHandle: function (l, u, m) {
                return (
                    (m = m != null ? m.concat([l]) : null), vd(4194308, 4, k1.bind(null, u, l), m)
                );
            },
            useLayoutEffect: function (l, u) {
                return vd(4194308, 4, l, u);
            },
            useInsertionEffect: function (l, u) {
                return vd(4, 2, l, u);
            },
            useMemo: function (l, u) {
                var m = ys();
                return (u = u === void 0 ? null : u), (l = l()), (m.memoizedState = [l, u]), l;
            },
            useReducer: function (l, u, m) {
                var y = ys();
                return (
                    (u = m !== void 0 ? m(u) : u),
                    (y.memoizedState = y.baseState = u),
                    (l = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: l,
                        lastRenderedState: u,
                    }),
                    (y.queue = l),
                    (l = l.dispatch = OR.bind(null, _n, l)),
                    [y.memoizedState, l]
                );
            },
            useRef: function (l) {
                var u = ys();
                return (l = { current: l }), (u.memoizedState = l);
            },
            useState: bg,
            useDebugValue: Pg,
            useDeferredValue: function (l) {
                var u = bg(l),
                    m = u[0],
                    y = u[1];
                return (
                    Rg(
                        function () {
                            var E = dr.transition;
                            dr.transition = {};
                            try {
                                y(l);
                            } finally {
                                dr.transition = E;
                            }
                        },
                        [l]
                    ),
                    m
                );
            },
            useTransition: function () {
                var l = bg(!1),
                    u = l[0];
                return (l = UR.bind(null, l[1])), (ys().memoizedState = l), [u, l];
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (l, u, m) {
                var y = _n,
                    E = ys();
                if (sn) {
                    if (m === void 0) throw Error(o(407));
                    m = m();
                } else {
                    if (((m = u()), Ln === null)) throw Error(o(349));
                    al & 30 || L1(y, u, m);
                }
                E.memoizedState = m;
                var C = { value: m, getSnapshot: u };
                return (
                    (E.queue = C),
                    Rg(N1.bind(null, y, C, l), [l]),
                    (y.flags |= 2048),
                    Vu(9, I1.bind(null, y, C, m, u), void 0, null),
                    m
                );
            },
            useId: function () {
                var l = ys(),
                    u = Ln.identifierPrefix;
                if (sn) {
                    var m = _s,
                        y = vs;
                    (m = (y & ~(1 << (32 - Vi(y) - 1))).toString(32) + m),
                        (u = ':' + u + 'R' + m),
                        (m = Hu++),
                        0 < m && (u += 'H' + m.toString(32)),
                        (u += ':');
                } else (m = DR++), (u = ':' + u + 'r' + m.toString(32) + ':');
                return (l.memoizedState = u);
            },
            unstable_isNewReconciler: !1,
        },
        zR = {
            readContext: lr,
            useCallback: B1,
            useContext: lr,
            useEffect: Gu,
            useImperativeHandle: z1,
            useInsertionEffect: O1,
            useLayoutEffect: F1,
            useMemo: H1,
            useReducer: md,
            useRef: U1,
            useState: function () {
                return md(Zo);
            },
            useDebugValue: Pg,
            useDeferredValue: function (l) {
                var u = md(Zo),
                    m = u[0],
                    y = u[1];
                return (
                    Gu(
                        function () {
                            var E = dr.transition;
                            dr.transition = {};
                            try {
                                y(l);
                            } finally {
                                dr.transition = E;
                            }
                        },
                        [l]
                    ),
                    m
                );
            },
            useTransition: function () {
                var l = md(Zo)[0],
                    u = ts().memoizedState;
                return [l, u];
            },
            useMutableSource: R1,
            useSyncExternalStore: P1,
            useId: V1,
            unstable_isNewReconciler: !1,
        },
        BR = {
            readContext: lr,
            useCallback: B1,
            useContext: lr,
            useEffect: Gu,
            useImperativeHandle: z1,
            useInsertionEffect: O1,
            useLayoutEffect: F1,
            useMemo: H1,
            useReducer: gd,
            useRef: U1,
            useState: function () {
                return gd(Zo);
            },
            useDebugValue: Pg,
            useDeferredValue: function (l) {
                var u = gd(Zo),
                    m = u[0],
                    y = u[1];
                return (
                    Gu(
                        function () {
                            var E = dr.transition;
                            dr.transition = {};
                            try {
                                y(l);
                            } finally {
                                dr.transition = E;
                            }
                        },
                        [l]
                    ),
                    m
                );
            },
            useTransition: function () {
                var l = gd(Zo)[0],
                    u = ts().memoizedState;
                return [l, u];
            },
            useMutableSource: R1,
            useSyncExternalStore: P1,
            useId: V1,
            unstable_isNewReconciler: !1,
        };
    function Lg(l, u) {
        try {
            var m = '',
                y = u;
            do (m += NR(y)), (y = y.return);
            while (y);
            var E = m;
        } catch (C) {
            E =
                `
Error generating stack: ` +
                C.message +
                `
` +
                C.stack;
        }
        return { value: l, source: u, stack: E };
    }
    function Ig(l, u) {
        try {
            console.error(u.value);
        } catch (m) {
            setTimeout(function () {
                throw m;
            });
        }
    }
    var HR = typeof WeakMap == 'function' ? WeakMap : Map;
    function Y1(l, u, m) {
        (m = gs(-1, m)), (m.tag = 3), (m.payload = { element: null });
        var y = u.value;
        return (
            (m.callback = function () {
                Ud || ((Ud = !0), (Kg = y)), Ig(l, u);
            }),
            m
        );
    }
    function q1(l, u, m) {
        (m = gs(-1, m)), (m.tag = 3);
        var y = l.type.getDerivedStateFromError;
        if (typeof y == 'function') {
            var E = u.value;
            (m.payload = function () {
                return y(E);
            }),
                (m.callback = function () {
                    Ig(l, u);
                });
        }
        var C = l.stateNode;
        return (
            C !== null &&
                typeof C.componentDidCatch == 'function' &&
                (m.callback = function () {
                    Ig(l, u),
                        typeof y != 'function' &&
                            (Qs === null ? (Qs = new Set([this])) : Qs.add(this));
                    var z = u.stack;
                    this.componentDidCatch(u.value, { componentStack: z !== null ? z : '' });
                }),
            m
        );
    }
    function Z1(l, u, m) {
        var y = l.pingCache;
        if (y === null) {
            y = l.pingCache = new HR();
            var E = new Set();
            y.set(u, E);
        } else (E = y.get(u)), E === void 0 && ((E = new Set()), y.set(u, E));
        E.has(m) || (E.add(m), (l = tP.bind(null, l, u, m)), u.then(l, l));
    }
    function K1(l) {
        do {
            var u;
            if (
                ((u = l.tag === 13) &&
                    ((u = l.memoizedState), (u = u !== null ? u.dehydrated !== null : !0)),
                u)
            )
                return l;
            l = l.return;
        } while (l !== null);
        return null;
    }
    function J1(l, u, m, y, E) {
        return l.mode & 1
            ? ((l.flags |= 65536), (l.lanes = E), l)
            : (l === u
                  ? (l.flags |= 65536)
                  : ((l.flags |= 128),
                    (m.flags |= 131072),
                    (m.flags &= -52805),
                    m.tag === 1 &&
                        (m.alternate === null
                            ? (m.tag = 17)
                            : ((u = gs(-1, 1)), (u.tag = 2), Js(m, u))),
                    (m.lanes |= 1)),
              l);
    }
    function ns(l) {
        l.flags |= 4;
    }
    function Q1(l, u) {
        if (l !== null && l.child === u.child) return !0;
        if (u.flags & 16) return !1;
        for (l = u.child; l !== null; ) {
            if (l.flags & 12854 || l.subtreeFlags & 12854) return !1;
            l = l.sibling;
        }
        return !0;
    }
    var Wu, ju, xd, Sd;
    if (De)
        (Wu = function (l, u) {
            for (var m = u.child; m !== null; ) {
                if (m.tag === 5 || m.tag === 6) le(l, m.stateNode);
                else if (m.tag !== 4 && m.child !== null) {
                    (m.child.return = m), (m = m.child);
                    continue;
                }
                if (m === u) break;
                for (; m.sibling === null; ) {
                    if (m.return === null || m.return === u) return;
                    m = m.return;
                }
                (m.sibling.return = m.return), (m = m.sibling);
            }
        }),
            (ju = function () {}),
            (xd = function (l, u, m, y, E) {
                if (((l = l.memoizedProps), l !== y)) {
                    var C = u.stateNode,
                        z = es(fr.current);
                    (m = Q(C, m, l, y, E, z)), (u.updateQueue = m) && ns(u);
                }
            }),
            (Sd = function (l, u, m, y) {
                m !== y && ns(u);
            });
    else if (V) {
        Wu = function (l, u, m, y) {
            for (var E = u.child; E !== null; ) {
                if (E.tag === 5) {
                    var C = E.stateNode;
                    m && y && (C = it(C, E.type, E.memoizedProps, E)), le(l, C);
                } else if (E.tag === 6)
                    (C = E.stateNode), m && y && (C = $e(C, E.memoizedProps, E)), le(l, C);
                else if (E.tag !== 4) {
                    if (E.tag === 22 && E.memoizedState !== null)
                        (C = E.child), C !== null && (C.return = E), Wu(l, E, !0, !0);
                    else if (E.child !== null) {
                        (E.child.return = E), (E = E.child);
                        continue;
                    }
                }
                if (E === u) break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === u) return;
                    E = E.return;
                }
                (E.sibling.return = E.return), (E = E.sibling);
            }
        };
        var $1 = function (l, u, m, y) {
            for (var E = u.child; E !== null; ) {
                if (E.tag === 5) {
                    var C = E.stateNode;
                    m && y && (C = it(C, E.type, E.memoizedProps, E)), Y(l, C);
                } else if (E.tag === 6)
                    (C = E.stateNode), m && y && (C = $e(C, E.memoizedProps, E)), Y(l, C);
                else if (E.tag !== 4) {
                    if (E.tag === 22 && E.memoizedState !== null)
                        (C = E.child), C !== null && (C.return = E), $1(l, E, !0, !0);
                    else if (E.child !== null) {
                        (E.child.return = E), (E = E.child);
                        continue;
                    }
                }
                if (E === u) break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === u) return;
                    E = E.return;
                }
                (E.sibling.return = E.return), (E = E.sibling);
            }
        };
        (ju = function (l, u) {
            var m = u.stateNode;
            if (!Q1(l, u)) {
                l = m.containerInfo;
                var y = W(l);
                $1(y, u, !1, !1), (m.pendingChildren = y), ns(u), ge(l, y);
            }
        }),
            (xd = function (l, u, m, y, E) {
                var C = l.stateNode,
                    z = l.memoizedProps;
                if ((l = Q1(l, u)) && z === y) u.stateNode = C;
                else {
                    var Z = u.stateNode,
                        he = es(fr.current),
                        Le = null;
                    z !== y && (Le = Q(Z, m, z, y, E, he)),
                        l && Le === null
                            ? (u.stateNode = C)
                            : ((C = U(C, Le, m, z, y, u, l, Z)),
                              be(C, m, y, E, he) && ns(u),
                              (u.stateNode = C),
                              l ? ns(u) : Wu(C, u, !1, !1));
                }
            }),
            (Sd = function (l, u, m, y) {
                m !== y
                    ? ((l = es(sl.current)),
                      (m = es(fr.current)),
                      (u.stateNode = Se(y, l, m, u)),
                      ns(u))
                    : (u.stateNode = l.stateNode);
            });
    } else (ju = function () {}), (xd = function () {}), (Sd = function () {});
    function Xu(l, u) {
        if (!sn)
            switch (l.tailMode) {
                case 'hidden':
                    u = l.tail;
                    for (var m = null; u !== null; )
                        u.alternate !== null && (m = u), (u = u.sibling);
                    m === null ? (l.tail = null) : (m.sibling = null);
                    break;
                case 'collapsed':
                    m = l.tail;
                    for (var y = null; m !== null; )
                        m.alternate !== null && (y = m), (m = m.sibling);
                    y === null
                        ? u || l.tail === null
                            ? (l.tail = null)
                            : (l.tail.sibling = null)
                        : (y.sibling = null);
            }
    }
    function oi(l) {
        var u = l.alternate !== null && l.alternate.child === l.child,
            m = 0,
            y = 0;
        if (u)
            for (var E = l.child; E !== null; )
                (m |= E.lanes | E.childLanes),
                    (y |= E.subtreeFlags & 14680064),
                    (y |= E.flags & 14680064),
                    (E.return = l),
                    (E = E.sibling);
        else
            for (E = l.child; E !== null; )
                (m |= E.lanes | E.childLanes),
                    (y |= E.subtreeFlags),
                    (y |= E.flags),
                    (E.return = l),
                    (E = E.sibling);
        return (l.subtreeFlags |= y), (l.childLanes = m), u;
    }
    function VR(l, u, m) {
        var y = u.pendingProps;
        switch ((vg(u), u.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return oi(u), null;
            case 1:
                return Gn(u.type) && En(), oi(u), null;
            case 3:
                return (
                    (y = u.stateNode),
                    ol(),
                    dt(vn),
                    dt(At),
                    Eg(),
                    y.pendingContext && ((y.context = y.pendingContext), (y.pendingContext = null)),
                    (l === null || l.child === null) &&
                        (Ou(u)
                            ? ns(u)
                            : l === null ||
                              (l.memoizedState.isDehydrated && !(u.flags & 256)) ||
                              ((u.flags |= 1024), br !== null && ($g(br), (br = null)))),
                    ju(l, u),
                    oi(u),
                    null
                );
            case 5:
                Mg(u), (m = es(sl.current));
                var E = u.type;
                if (l !== null && u.stateNode != null)
                    xd(l, u, E, y, m), l.ref !== u.ref && ((u.flags |= 512), (u.flags |= 2097152));
                else {
                    if (!y) {
                        if (u.stateNode === null) throw Error(o(166));
                        return oi(u), null;
                    }
                    if (((l = es(fr.current)), Ou(u))) {
                        if (!we) throw Error(o(175));
                        (l = Xo(u.stateNode, u.type, u.memoizedProps, m, l, u, !Uu)),
                            (u.updateQueue = l),
                            l !== null && ns(u);
                    } else {
                        var C = K(E, y, m, l, u);
                        Wu(C, u, !1, !1), (u.stateNode = C), be(C, E, y, m, l) && ns(u);
                    }
                    u.ref !== null && ((u.flags |= 512), (u.flags |= 2097152));
                }
                return oi(u), null;
            case 6:
                if (l && u.stateNode != null) Sd(l, u, l.memoizedProps, y);
                else {
                    if (typeof y != 'string' && u.stateNode === null) throw Error(o(166));
                    if (((l = es(sl.current)), (m = es(fr.current)), Ou(u))) {
                        if (!we) throw Error(o(176));
                        if (
                            ((l = u.stateNode),
                            (y = u.memoizedProps),
                            (m = Yr(l, y, u, !Uu)) && ((E = Gi), E !== null))
                        )
                            switch (((C = (E.mode & 1) !== 0), E.tag)) {
                                case 3:
                                    Re(E.stateNode.containerInfo, l, y, C);
                                    break;
                                case 5:
                                    Ue(E.type, E.memoizedProps, E.stateNode, l, y, C);
                            }
                        m && ns(u);
                    } else u.stateNode = Se(y, l, m, u);
                }
                return oi(u), null;
            case 13:
                if (
                    (dt(cn),
                    (y = u.memoizedState),
                    sn && Wi !== null && u.mode & 1 && !(u.flags & 128))
                ) {
                    for (l = Wi; l; ) l = Kt(l);
                    return il(), (u.flags |= 98560), u;
                }
                if (y !== null && y.dehydrated !== null) {
                    if (((y = Ou(u)), l === null)) {
                        if (!y) throw Error(o(318));
                        if (!we) throw Error(o(344));
                        if (((l = u.memoizedState), (l = l !== null ? l.dehydrated : null), !l))
                            throw Error(o(317));
                        sr(l, u);
                    } else il(), !(u.flags & 128) && (u.memoizedState = null), (u.flags |= 4);
                    return oi(u), null;
                }
                return (
                    br !== null && ($g(br), (br = null)),
                    u.flags & 128
                        ? ((u.lanes = m), u)
                        : ((y = y !== null),
                          (m = !1),
                          l === null ? Ou(u) : (m = l.memoizedState !== null),
                          y &&
                              !m &&
                              ((u.child.flags |= 8192),
                              u.mode & 1 &&
                                  (l === null || cn.current & 1 ? Fn === 0 && (Fn = 3) : tv())),
                          u.updateQueue !== null && (u.flags |= 4),
                          oi(u),
                          null)
                );
            case 4:
                return ol(), ju(l, u), l === null && Ee(u.stateNode.containerInfo), oi(u), null;
            case 10:
                return fg(u.type._context), oi(u), null;
            case 17:
                return Gn(u.type) && En(), oi(u), null;
            case 19:
                if ((dt(cn), (E = u.memoizedState), E === null)) return oi(u), null;
                if (((y = (u.flags & 128) !== 0), (C = E.rendering), C === null))
                    if (y) Xu(E, !1);
                    else {
                        if (Fn !== 0 || (l !== null && l.flags & 128))
                            for (l = u.child; l !== null; ) {
                                if (((C = dd(l)), C !== null)) {
                                    for (
                                        u.flags |= 128,
                                            Xu(E, !1),
                                            l = C.updateQueue,
                                            l !== null && ((u.updateQueue = l), (u.flags |= 4)),
                                            u.subtreeFlags = 0,
                                            l = m,
                                            y = u.child;
                                        y !== null;

                                    )
                                        (m = y),
                                            (E = l),
                                            (m.flags &= 14680066),
                                            (C = m.alternate),
                                            C === null
                                                ? ((m.childLanes = 0),
                                                  (m.lanes = E),
                                                  (m.child = null),
                                                  (m.subtreeFlags = 0),
                                                  (m.memoizedProps = null),
                                                  (m.memoizedState = null),
                                                  (m.updateQueue = null),
                                                  (m.dependencies = null),
                                                  (m.stateNode = null))
                                                : ((m.childLanes = C.childLanes),
                                                  (m.lanes = C.lanes),
                                                  (m.child = C.child),
                                                  (m.subtreeFlags = 0),
                                                  (m.deletions = null),
                                                  (m.memoizedProps = C.memoizedProps),
                                                  (m.memoizedState = C.memoizedState),
                                                  (m.updateQueue = C.updateQueue),
                                                  (m.type = C.type),
                                                  (E = C.dependencies),
                                                  (m.dependencies =
                                                      E === null
                                                          ? null
                                                          : {
                                                                lanes: E.lanes,
                                                                firstContext: E.firstContext,
                                                            })),
                                            (y = y.sibling);
                                    return Ye(cn, (cn.current & 1) | 2), u.child;
                                }
                                l = l.sibling;
                            }
                        E.tail !== null &&
                            Wn() > Zg &&
                            ((u.flags |= 128), (y = !0), Xu(E, !1), (u.lanes = 4194304));
                    }
                else {
                    if (!y)
                        if (((l = dd(C)), l !== null)) {
                            if (
                                ((u.flags |= 128),
                                (y = !0),
                                (l = l.updateQueue),
                                l !== null && ((u.updateQueue = l), (u.flags |= 4)),
                                Xu(E, !0),
                                E.tail === null && E.tailMode === 'hidden' && !C.alternate && !sn)
                            )
                                return oi(u), null;
                        } else
                            2 * Wn() - E.renderingStartTime > Zg &&
                                m !== 1073741824 &&
                                ((u.flags |= 128), (y = !0), Xu(E, !1), (u.lanes = 4194304));
                    E.isBackwards
                        ? ((C.sibling = u.child), (u.child = C))
                        : ((l = E.last),
                          l !== null ? (l.sibling = C) : (u.child = C),
                          (E.last = C));
                }
                return E.tail !== null
                    ? ((u = E.tail),
                      (E.rendering = u),
                      (E.tail = u.sibling),
                      (E.renderingStartTime = Wn()),
                      (u.sibling = null),
                      (l = cn.current),
                      Ye(cn, y ? (l & 1) | 2 : l & 1),
                      u)
                    : (oi(u), null);
            case 22:
            case 23:
                return (
                    ev(),
                    (y = u.memoizedState !== null),
                    l !== null && (l.memoizedState !== null) !== y && (u.flags |= 8192),
                    y && u.mode & 1
                        ? Xi & 1073741824 && (oi(u), De && u.subtreeFlags & 6 && (u.flags |= 8192))
                        : oi(u),
                    null
                );
            case 24:
                return null;
            case 25:
                return null;
        }
        throw Error(o(156, u.tag));
    }
    var GR = a.ReactCurrentOwner,
        ji = !1;
    function vi(l, u, m, y) {
        u.child = l === null ? C1(u, null, m, y) : rl(u, l.child, m, y);
    }
    function eS(l, u, m, y, E) {
        m = m.render;
        var C = u.ref;
        return (
            el(u, E),
            (y = Ag(l, u, m, y, C, E)),
            (m = Cg()),
            l !== null && !ji
                ? ((u.updateQueue = l.updateQueue),
                  (u.flags &= -2053),
                  (l.lanes &= ~E),
                  xs(l, u, E))
                : (sn && m && gg(u), (u.flags |= 1), vi(l, u, y, E), u.child)
        );
    }
    function tS(l, u, m, y, E) {
        if (l === null) {
            var C = m.type;
            return typeof C == 'function' &&
                !nv(C) &&
                C.defaultProps === void 0 &&
                m.compare === null &&
                m.defaultProps === void 0
                ? ((u.tag = 15), (u.type = C), nS(l, u, C, y, E))
                : ((l = Vd(m.type, null, y, u, u.mode, E)),
                  (l.ref = u.ref),
                  (l.return = u),
                  (u.child = l));
        }
        if (((C = l.child), !(l.lanes & E))) {
            var z = C.memoizedProps;
            if (((m = m.compare), (m = m !== null ? m : id), m(z, y) && l.ref === u.ref))
                return xs(l, u, E);
        }
        return (u.flags |= 1), (l = no(C, y)), (l.ref = u.ref), (l.return = u), (u.child = l);
    }
    function nS(l, u, m, y, E) {
        if (l !== null && id(l.memoizedProps, y) && l.ref === u.ref)
            if (((ji = !1), (l.lanes & E) !== 0)) l.flags & 131072 && (ji = !0);
            else return (u.lanes = l.lanes), xs(l, u, E);
        return Ng(l, u, m, y, E);
    }
    function iS(l, u, m) {
        var y = u.pendingProps,
            E = y.children,
            C = l !== null ? l.memoizedState : null;
        if (y.mode === 'hidden')
            if (!(u.mode & 1))
                (u.memoizedState = { baseLanes: 0, cachePool: null }), Ye(ll, Xi), (Xi |= m);
            else if (m & 1073741824)
                (u.memoizedState = { baseLanes: 0, cachePool: null }),
                    (y = C !== null ? C.baseLanes : m),
                    Ye(ll, Xi),
                    (Xi |= y);
            else
                return (
                    (l = C !== null ? C.baseLanes | m : m),
                    (u.lanes = u.childLanes = 1073741824),
                    (u.memoizedState = { baseLanes: l, cachePool: null }),
                    (u.updateQueue = null),
                    Ye(ll, Xi),
                    (Xi |= l),
                    null
                );
        else
            C !== null ? ((y = C.baseLanes | m), (u.memoizedState = null)) : (y = m),
                Ye(ll, Xi),
                (Xi |= y);
        return vi(l, u, E, m), u.child;
    }
    function rS(l, u) {
        var m = u.ref;
        ((l === null && m !== null) || (l !== null && l.ref !== m)) &&
            ((u.flags |= 512), (u.flags |= 2097152));
    }
    function Ng(l, u, m, y, E) {
        var C = Gn(m) ? qr : At.current;
        return (
            (C = ar(u, C)),
            el(u, E),
            (m = Ag(l, u, m, y, C, E)),
            (y = Cg()),
            l !== null && !ji
                ? ((u.updateQueue = l.updateQueue),
                  (u.flags &= -2053),
                  (l.lanes &= ~E),
                  xs(l, u, E))
                : (sn && y && gg(u), (u.flags |= 1), vi(l, u, m, E), u.child)
        );
    }
    function sS(l, u, m, y, E) {
        if (Gn(m)) {
            var C = !0;
            Qn(u);
        } else C = !1;
        if ((el(u, E), u.stateNode === null))
            l !== null && ((l.alternate = null), (u.alternate = null), (u.flags |= 2)),
                y1(u, m, y),
                mg(u, m, y, E),
                (y = !0);
        else if (l === null) {
            var z = u.stateNode,
                Z = u.memoizedProps;
            z.props = Z;
            var he = z.context,
                Le = m.contextType;
            typeof Le == 'object' && Le !== null
                ? (Le = lr(Le))
                : ((Le = Gn(m) ? qr : At.current), (Le = ar(u, Le)));
            var Ze = m.getDerivedStateFromProps,
                St = typeof Ze == 'function' || typeof z.getSnapshotBeforeUpdate == 'function';
            St ||
                (typeof z.UNSAFE_componentWillReceiveProps != 'function' &&
                    typeof z.componentWillReceiveProps != 'function') ||
                ((Z !== y || he !== Le) && x1(u, z, y, Le)),
                (Ks = !1);
            var lt = u.memoizedState;
            (z.state = lt),
                ad(u, y, z, E),
                (he = u.memoizedState),
                Z !== y || lt !== he || vn.current || Ks
                    ? (typeof Ze == 'function' && (pg(u, m, Ze, y), (he = u.memoizedState)),
                      (Z = Ks || _1(u, m, Z, y, lt, he, Le))
                          ? (St ||
                                (typeof z.UNSAFE_componentWillMount != 'function' &&
                                    typeof z.componentWillMount != 'function') ||
                                (typeof z.componentWillMount == 'function' &&
                                    z.componentWillMount(),
                                typeof z.UNSAFE_componentWillMount == 'function' &&
                                    z.UNSAFE_componentWillMount()),
                            typeof z.componentDidMount == 'function' && (u.flags |= 4194308))
                          : (typeof z.componentDidMount == 'function' && (u.flags |= 4194308),
                            (u.memoizedProps = y),
                            (u.memoizedState = he)),
                      (z.props = y),
                      (z.state = he),
                      (z.context = Le),
                      (y = Z))
                    : (typeof z.componentDidMount == 'function' && (u.flags |= 4194308), (y = !1));
        } else {
            (z = u.stateNode),
                p1(l, u),
                (Z = u.memoizedProps),
                (Le = u.type === u.elementType ? Z : Cr(u.type, Z)),
                (z.props = Le),
                (St = u.pendingProps),
                (lt = z.context),
                (he = m.contextType),
                typeof he == 'object' && he !== null
                    ? (he = lr(he))
                    : ((he = Gn(m) ? qr : At.current), (he = ar(u, he)));
            var qt = m.getDerivedStateFromProps;
            (Ze = typeof qt == 'function' || typeof z.getSnapshotBeforeUpdate == 'function') ||
                (typeof z.UNSAFE_componentWillReceiveProps != 'function' &&
                    typeof z.componentWillReceiveProps != 'function') ||
                ((Z !== St || lt !== he) && x1(u, z, y, he)),
                (Ks = !1),
                (lt = u.memoizedState),
                (z.state = lt),
                ad(u, y, z, E);
            var ot = u.memoizedState;
            Z !== St || lt !== ot || vn.current || Ks
                ? (typeof qt == 'function' && (pg(u, m, qt, y), (ot = u.memoizedState)),
                  (Le = Ks || _1(u, m, Le, y, lt, ot, he) || !1)
                      ? (Ze ||
                            (typeof z.UNSAFE_componentWillUpdate != 'function' &&
                                typeof z.componentWillUpdate != 'function') ||
                            (typeof z.componentWillUpdate == 'function' &&
                                z.componentWillUpdate(y, ot, he),
                            typeof z.UNSAFE_componentWillUpdate == 'function' &&
                                z.UNSAFE_componentWillUpdate(y, ot, he)),
                        typeof z.componentDidUpdate == 'function' && (u.flags |= 4),
                        typeof z.getSnapshotBeforeUpdate == 'function' && (u.flags |= 1024))
                      : (typeof z.componentDidUpdate != 'function' ||
                            (Z === l.memoizedProps && lt === l.memoizedState) ||
                            (u.flags |= 4),
                        typeof z.getSnapshotBeforeUpdate != 'function' ||
                            (Z === l.memoizedProps && lt === l.memoizedState) ||
                            (u.flags |= 1024),
                        (u.memoizedProps = y),
                        (u.memoizedState = ot)),
                  (z.props = y),
                  (z.state = ot),
                  (z.context = he),
                  (y = Le))
                : (typeof z.componentDidUpdate != 'function' ||
                      (Z === l.memoizedProps && lt === l.memoizedState) ||
                      (u.flags |= 4),
                  typeof z.getSnapshotBeforeUpdate != 'function' ||
                      (Z === l.memoizedProps && lt === l.memoizedState) ||
                      (u.flags |= 1024),
                  (y = !1));
        }
        return Dg(l, u, m, y, C, E);
    }
    function Dg(l, u, m, y, E, C) {
        rS(l, u);
        var z = (u.flags & 128) !== 0;
        if (!y && !z) return E && Qa(u, m, !1), xs(l, u, C);
        (y = u.stateNode), (GR.current = u);
        var Z = z && typeof m.getDerivedStateFromError != 'function' ? null : y.render();
        return (
            (u.flags |= 1),
            l !== null && z
                ? ((u.child = rl(u, l.child, null, C)), (u.child = rl(u, null, Z, C)))
                : vi(l, u, Z, C),
            (u.memoizedState = y.state),
            E && Qa(u, m, !0),
            u.child
        );
    }
    function oS(l) {
        var u = l.stateNode;
        u.pendingContext
            ? Zr(l, u.pendingContext, u.pendingContext !== u.context)
            : u.context && Zr(l, u.context, !1),
            Sg(l, u.containerInfo);
    }
    function aS(l, u, m, y, E) {
        return il(), xg(E), (u.flags |= 256), vi(l, u, m, y), u.child;
    }
    var Md = { dehydrated: null, treeContext: null, retryLane: 0 };
    function wd(l) {
        return { baseLanes: l, cachePool: null };
    }
    function lS(l, u, m) {
        var y = u.pendingProps,
            E = cn.current,
            C = !1,
            z = (u.flags & 128) !== 0,
            Z;
        if (
            ((Z = z) || (Z = l !== null && l.memoizedState === null ? !1 : (E & 2) !== 0),
            Z
                ? ((C = !0), (u.flags &= -129))
                : (l === null || l.memoizedState !== null) && (E |= 1),
            Ye(cn, E & 1),
            l === null)
        )
            return (
                yg(u),
                (l = u.memoizedState),
                l !== null && ((l = l.dehydrated), l !== null)
                    ? (u.mode & 1
                          ? _t(l)
                              ? (u.lanes = 8)
                              : (u.lanes = 1073741824)
                          : (u.lanes = 1),
                      null)
                    : ((E = y.children),
                      (l = y.fallback),
                      C
                          ? ((y = u.mode),
                            (C = u.child),
                            (E = { mode: 'hidden', children: E }),
                            !(y & 1) && C !== null
                                ? ((C.childLanes = 0), (C.pendingProps = E))
                                : (C = Gd(E, y, 0, null)),
                            (l = ta(l, y, m, null)),
                            (C.return = u),
                            (l.return = u),
                            (C.sibling = l),
                            (u.child = C),
                            (u.child.memoizedState = wd(m)),
                            (u.memoizedState = Md),
                            l)
                          : Ug(u, E))
            );
        if (((E = l.memoizedState), E !== null)) {
            if (((Z = E.dehydrated), Z !== null)) {
                if (z)
                    return u.flags & 256
                        ? ((u.flags &= -257), Ed(l, u, m, Error(o(422))))
                        : u.memoizedState !== null
                        ? ((u.child = l.child), (u.flags |= 128), null)
                        : ((C = y.fallback),
                          (E = u.mode),
                          (y = Gd({ mode: 'visible', children: y.children }, E, 0, null)),
                          (C = ta(C, E, m, null)),
                          (C.flags |= 2),
                          (y.return = u),
                          (C.return = u),
                          (y.sibling = C),
                          (u.child = y),
                          u.mode & 1 && rl(u, l.child, null, m),
                          (u.child.memoizedState = wd(m)),
                          (u.memoizedState = Md),
                          C);
                if (!(u.mode & 1)) u = Ed(l, u, m, null);
                else if (_t(Z)) u = Ed(l, u, m, Error(o(419)));
                else if (((y = (m & l.childLanes) !== 0), ji || y)) {
                    if (((y = Ln), y !== null)) {
                        switch (m & -m) {
                            case 4:
                                C = 2;
                                break;
                            case 16:
                                C = 8;
                                break;
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                            case 67108864:
                                C = 32;
                                break;
                            case 536870912:
                                C = 268435456;
                                break;
                            default:
                                C = 0;
                        }
                        (y = C & (y.suspendedLanes | m) ? 0 : C),
                            y !== 0 && y !== E.retryLane && ((E.retryLane = y), hr(l, y, -1));
                    }
                    tv(), (u = Ed(l, u, m, Error(o(421))));
                } else
                    rn(Z)
                        ? ((u.flags |= 128),
                          (u.child = l.child),
                          (u = nP.bind(null, l)),
                          Dt(Z, u),
                          (u = null))
                        : ((m = E.treeContext),
                          we &&
                              ((Wi = Ar(Z)),
                              (Gi = u),
                              (sn = !0),
                              (br = null),
                              (Uu = !1),
                              m !== null &&
                                  ((ur[cr++] = vs),
                                  (ur[cr++] = _s),
                                  (ur[cr++] = Yo),
                                  (vs = m.id),
                                  (_s = m.overflow),
                                  (Yo = u))),
                          (u = Ug(u, u.pendingProps.children)),
                          (u.flags |= 4096));
                return u;
            }
            return C
                ? ((y = cS(l, u, y.children, y.fallback, m)),
                  (C = u.child),
                  (E = l.child.memoizedState),
                  (C.memoizedState =
                      E === null ? wd(m) : { baseLanes: E.baseLanes | m, cachePool: null }),
                  (C.childLanes = l.childLanes & ~m),
                  (u.memoizedState = Md),
                  y)
                : ((m = uS(l, u, y.children, m)), (u.memoizedState = null), m);
        }
        return C
            ? ((y = cS(l, u, y.children, y.fallback, m)),
              (C = u.child),
              (E = l.child.memoizedState),
              (C.memoizedState =
                  E === null ? wd(m) : { baseLanes: E.baseLanes | m, cachePool: null }),
              (C.childLanes = l.childLanes & ~m),
              (u.memoizedState = Md),
              y)
            : ((m = uS(l, u, y.children, m)), (u.memoizedState = null), m);
    }
    function Ug(l, u) {
        return (
            (u = Gd({ mode: 'visible', children: u }, l.mode, 0, null)),
            (u.return = l),
            (l.child = u)
        );
    }
    function uS(l, u, m, y) {
        var E = l.child;
        return (
            (l = E.sibling),
            (m = no(E, { mode: 'visible', children: m })),
            !(u.mode & 1) && (m.lanes = y),
            (m.return = u),
            (m.sibling = null),
            l !== null &&
                ((y = u.deletions),
                y === null ? ((u.deletions = [l]), (u.flags |= 16)) : y.push(l)),
            (u.child = m)
        );
    }
    function cS(l, u, m, y, E) {
        var C = u.mode;
        l = l.child;
        var z = l.sibling,
            Z = { mode: 'hidden', children: m };
        return (
            !(C & 1) && u.child !== l
                ? ((m = u.child), (m.childLanes = 0), (m.pendingProps = Z), (u.deletions = null))
                : ((m = no(l, Z)), (m.subtreeFlags = l.subtreeFlags & 14680064)),
            z !== null ? (y = no(z, y)) : ((y = ta(y, C, E, null)), (y.flags |= 2)),
            (y.return = u),
            (m.return = u),
            (m.sibling = y),
            (u.child = m),
            y
        );
    }
    function Ed(l, u, m, y) {
        return (
            y !== null && xg(y),
            rl(u, l.child, null, m),
            (l = Ug(u, u.pendingProps.children)),
            (l.flags |= 2),
            (u.memoizedState = null),
            l
        );
    }
    function fS(l, u, m) {
        l.lanes |= u;
        var y = l.alternate;
        y !== null && (y.lanes |= u), dg(l.return, u, m);
    }
    function Og(l, u, m, y, E) {
        var C = l.memoizedState;
        C === null
            ? (l.memoizedState = {
                  isBackwards: u,
                  rendering: null,
                  renderingStartTime: 0,
                  last: y,
                  tail: m,
                  tailMode: E,
              })
            : ((C.isBackwards = u),
              (C.rendering = null),
              (C.renderingStartTime = 0),
              (C.last = y),
              (C.tail = m),
              (C.tailMode = E));
    }
    function dS(l, u, m) {
        var y = u.pendingProps,
            E = y.revealOrder,
            C = y.tail;
        if ((vi(l, u, y.children, m), (y = cn.current), y & 2)) (y = (y & 1) | 2), (u.flags |= 128);
        else {
            if (l !== null && l.flags & 128)
                e: for (l = u.child; l !== null; ) {
                    if (l.tag === 13) l.memoizedState !== null && fS(l, m, u);
                    else if (l.tag === 19) fS(l, m, u);
                    else if (l.child !== null) {
                        (l.child.return = l), (l = l.child);
                        continue;
                    }
                    if (l === u) break e;
                    for (; l.sibling === null; ) {
                        if (l.return === null || l.return === u) break e;
                        l = l.return;
                    }
                    (l.sibling.return = l.return), (l = l.sibling);
                }
            y &= 1;
        }
        if ((Ye(cn, y), !(u.mode & 1))) u.memoizedState = null;
        else
            switch (E) {
                case 'forwards':
                    for (m = u.child, E = null; m !== null; )
                        (l = m.alternate), l !== null && dd(l) === null && (E = m), (m = m.sibling);
                    (m = E),
                        m === null
                            ? ((E = u.child), (u.child = null))
                            : ((E = m.sibling), (m.sibling = null)),
                        Og(u, !1, E, m, C);
                    break;
                case 'backwards':
                    for (m = null, E = u.child, u.child = null; E !== null; ) {
                        if (((l = E.alternate), l !== null && dd(l) === null)) {
                            u.child = E;
                            break;
                        }
                        (l = E.sibling), (E.sibling = m), (m = E), (E = l);
                    }
                    Og(u, !0, m, null, C);
                    break;
                case 'together':
                    Og(u, !1, null, null, void 0);
                    break;
                default:
                    u.memoizedState = null;
            }
        return u.child;
    }
    function xs(l, u, m) {
        if ((l !== null && (u.dependencies = l.dependencies), (ul |= u.lanes), !(m & u.childLanes)))
            return null;
        if (l !== null && u.child !== l.child) throw Error(o(153));
        if (u.child !== null) {
            for (
                l = u.child, m = no(l, l.pendingProps), u.child = m, m.return = u;
                l.sibling !== null;

            )
                (l = l.sibling), (m = m.sibling = no(l, l.pendingProps)), (m.return = u);
            m.sibling = null;
        }
        return u.child;
    }
    function WR(l, u, m) {
        switch (u.tag) {
            case 3:
                oS(u), il();
                break;
            case 5:
                b1(u);
                break;
            case 1:
                Gn(u.type) && Qn(u);
                break;
            case 4:
                Sg(u, u.stateNode.containerInfo);
                break;
            case 10:
                h1(u, u.type._context, u.memoizedProps.value);
                break;
            case 13:
                var y = u.memoizedState;
                if (y !== null)
                    return y.dehydrated !== null
                        ? (Ye(cn, cn.current & 1), (u.flags |= 128), null)
                        : m & u.child.childLanes
                        ? lS(l, u, m)
                        : (Ye(cn, cn.current & 1),
                          (l = xs(l, u, m)),
                          l !== null ? l.sibling : null);
                Ye(cn, cn.current & 1);
                break;
            case 19:
                if (((y = (m & u.childLanes) !== 0), l.flags & 128)) {
                    if (y) return dS(l, u, m);
                    u.flags |= 128;
                }
                var E = u.memoizedState;
                if (
                    (E !== null && ((E.rendering = null), (E.tail = null), (E.lastEffect = null)),
                    Ye(cn, cn.current),
                    y)
                )
                    break;
                return null;
            case 22:
            case 23:
                return (u.lanes = 0), iS(l, u, m);
        }
        return xs(l, u, m);
    }
    function jR(l, u) {
        switch ((vg(u), u.tag)) {
            case 1:
                return (
                    Gn(u.type) && En(),
                    (l = u.flags),
                    l & 65536 ? ((u.flags = (l & -65537) | 128), u) : null
                );
            case 3:
                return (
                    ol(),
                    dt(vn),
                    dt(At),
                    Eg(),
                    (l = u.flags),
                    l & 65536 && !(l & 128) ? ((u.flags = (l & -65537) | 128), u) : null
                );
            case 5:
                return Mg(u), null;
            case 13:
                if ((dt(cn), (l = u.memoizedState), l !== null && l.dehydrated !== null)) {
                    if (u.alternate === null) throw Error(o(340));
                    il();
                }
                return (l = u.flags), l & 65536 ? ((u.flags = (l & -65537) | 128), u) : null;
            case 19:
                return dt(cn), null;
            case 4:
                return ol(), null;
            case 10:
                return fg(u.type._context), null;
            case 22:
            case 23:
                return ev(), null;
            case 24:
                return null;
            default:
                return null;
        }
    }
    var Td = !1,
        Ko = !1,
        XR = typeof WeakSet == 'function' ? WeakSet : Set,
        Be = null;
    function Ad(l, u) {
        var m = l.ref;
        if (m !== null)
            if (typeof m == 'function')
                try {
                    m(null);
                } catch (y) {
                    Ni(l, u, y);
                }
            else m.current = null;
    }
    function Fg(l, u, m) {
        try {
            m();
        } catch (y) {
            Ni(l, u, y);
        }
    }
    var hS = !1;
    function YR(l, u) {
        for (B(l.containerInfo), Be = u; Be !== null; )
            if (((l = Be), (u = l.child), (l.subtreeFlags & 1028) !== 0 && u !== null))
                (u.return = l), (Be = u);
            else
                for (; Be !== null; ) {
                    l = Be;
                    try {
                        var m = l.alternate;
                        if (l.flags & 1024)
                            switch (l.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    break;
                                case 1:
                                    if (m !== null) {
                                        var y = m.memoizedProps,
                                            E = m.memoizedState,
                                            C = l.stateNode,
                                            z = C.getSnapshotBeforeUpdate(
                                                l.elementType === l.type ? y : Cr(l.type, y),
                                                E
                                            );
                                        C.__reactInternalSnapshotBeforeUpdate = z;
                                    }
                                    break;
                                case 3:
                                    De && Fe(l.stateNode.containerInfo);
                                    break;
                                case 5:
                                case 6:
                                case 4:
                                case 17:
                                    break;
                                default:
                                    throw Error(o(163));
                            }
                    } catch (Z) {
                        Ni(l, l.return, Z);
                    }
                    if (((u = l.sibling), u !== null)) {
                        (u.return = l.return), (Be = u);
                        break;
                    }
                    Be = l.return;
                }
        return (m = hS), (hS = !1), m;
    }
    function Jo(l, u, m) {
        var y = u.updateQueue;
        if (((y = y !== null ? y.lastEffect : null), y !== null)) {
            var E = (y = y.next);
            do {
                if ((E.tag & l) === l) {
                    var C = E.destroy;
                    (E.destroy = void 0), C !== void 0 && Fg(u, m, C);
                }
                E = E.next;
            } while (E !== y);
        }
    }
    function Yu(l, u) {
        if (((u = u.updateQueue), (u = u !== null ? u.lastEffect : null), u !== null)) {
            var m = (u = u.next);
            do {
                if ((m.tag & l) === l) {
                    var y = m.create;
                    m.destroy = y();
                }
                m = m.next;
            } while (m !== u);
        }
    }
    function kg(l) {
        var u = l.ref;
        if (u !== null) {
            var m = l.stateNode;
            switch (l.tag) {
                case 5:
                    l = te(m);
                    break;
                default:
                    l = m;
            }
            typeof u == 'function' ? u(l) : (u.current = l);
        }
    }
    function pS(l, u, m) {
        if (Kr && typeof Kr.onCommitFiberUnmount == 'function')
            try {
                Kr.onCommitFiberUnmount(td, u);
            } catch {}
        switch (u.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (((l = u.updateQueue), l !== null && ((l = l.lastEffect), l !== null))) {
                    var y = (l = l.next);
                    do {
                        var E = y,
                            C = E.destroy;
                        (E = E.tag), C !== void 0 && (E & 2 || E & 4) && Fg(u, m, C), (y = y.next);
                    } while (y !== l);
                }
                break;
            case 1:
                if ((Ad(u, m), (l = u.stateNode), typeof l.componentWillUnmount == 'function'))
                    try {
                        (l.props = u.memoizedProps),
                            (l.state = u.memoizedState),
                            l.componentWillUnmount();
                    } catch (z) {
                        Ni(u, m, z);
                    }
                break;
            case 5:
                Ad(u, m);
                break;
            case 4:
                De
                    ? xS(l, u, m)
                    : V && V && ((u = u.stateNode.containerInfo), (m = W(u)), Ce(u, m));
        }
    }
    function mS(l, u, m) {
        for (var y = u; ; )
            if ((pS(l, y, m), y.child === null || (De && y.tag === 4))) {
                if (y === u) break;
                for (; y.sibling === null; ) {
                    if (y.return === null || y.return === u) return;
                    y = y.return;
                }
                (y.sibling.return = y.return), (y = y.sibling);
            } else (y.child.return = y), (y = y.child);
    }
    function gS(l) {
        var u = l.alternate;
        u !== null && ((l.alternate = null), gS(u)),
            (l.child = null),
            (l.deletions = null),
            (l.sibling = null),
            l.tag === 5 && ((u = l.stateNode), u !== null && We(u)),
            (l.stateNode = null),
            (l.return = null),
            (l.dependencies = null),
            (l.memoizedProps = null),
            (l.memoizedState = null),
            (l.pendingProps = null),
            (l.stateNode = null),
            (l.updateQueue = null);
    }
    function vS(l) {
        return l.tag === 5 || l.tag === 3 || l.tag === 4;
    }
    function _S(l) {
        e: for (;;) {
            for (; l.sibling === null; ) {
                if (l.return === null || vS(l.return)) return null;
                l = l.return;
            }
            for (
                l.sibling.return = l.return, l = l.sibling;
                l.tag !== 5 && l.tag !== 6 && l.tag !== 18;

            ) {
                if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
                (l.child.return = l), (l = l.child);
            }
            if (!(l.flags & 2)) return l.stateNode;
        }
    }
    function yS(l) {
        if (De) {
            e: {
                for (var u = l.return; u !== null; ) {
                    if (vS(u)) break e;
                    u = u.return;
                }
                throw Error(o(160));
            }
            var m = u;
            switch (m.tag) {
                case 5:
                    (u = m.stateNode),
                        m.flags & 32 && (Qe(u), (m.flags &= -33)),
                        (m = _S(l)),
                        Bg(l, m, u);
                    break;
                case 3:
                case 4:
                    (u = m.stateNode.containerInfo), (m = _S(l)), zg(l, m, u);
                    break;
                default:
                    throw Error(o(161));
            }
        }
    }
    function zg(l, u, m) {
        var y = l.tag;
        if (y === 5 || y === 6) (l = l.stateNode), u ? wt(m, l, u) : Ae(m, l);
        else if (y !== 4 && ((l = l.child), l !== null))
            for (zg(l, u, m), l = l.sibling; l !== null; ) zg(l, u, m), (l = l.sibling);
    }
    function Bg(l, u, m) {
        var y = l.tag;
        if (y === 5 || y === 6) (l = l.stateNode), u ? nn(m, l, u) : at(m, l);
        else if (y !== 4 && ((l = l.child), l !== null))
            for (Bg(l, u, m), l = l.sibling; l !== null; ) Bg(l, u, m), (l = l.sibling);
    }
    function xS(l, u, m) {
        for (var y = u, E = !1, C, z; ; ) {
            if (!E) {
                E = y.return;
                e: for (;;) {
                    if (E === null) throw Error(o(160));
                    switch (((C = E.stateNode), E.tag)) {
                        case 5:
                            z = !1;
                            break e;
                        case 3:
                            (C = C.containerInfo), (z = !0);
                            break e;
                        case 4:
                            (C = C.containerInfo), (z = !0);
                            break e;
                    }
                    E = E.return;
                }
                E = !0;
            }
            if (y.tag === 5 || y.tag === 6)
                mS(l, y, m), z ? tt(C, y.stateNode) : rt(C, y.stateNode);
            else if (y.tag === 18) z ? ne(C, y.stateNode) : ue(C, y.stateNode);
            else if (y.tag === 4) {
                if (y.child !== null) {
                    (C = y.stateNode.containerInfo), (z = !0), (y.child.return = y), (y = y.child);
                    continue;
                }
            } else if ((pS(l, y, m), y.child !== null)) {
                (y.child.return = y), (y = y.child);
                continue;
            }
            if (y === u) break;
            for (; y.sibling === null; ) {
                if (y.return === null || y.return === u) return;
                (y = y.return), y.tag === 4 && (E = !1);
            }
            (y.sibling.return = y.return), (y = y.sibling);
        }
    }
    function Hg(l, u) {
        if (De) {
            switch (u.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    Jo(3, u, u.return), Yu(3, u), Jo(5, u, u.return);
                    return;
                case 1:
                    return;
                case 5:
                    var m = u.stateNode;
                    if (m != null) {
                        var y = u.memoizedProps;
                        l = l !== null ? l.memoizedProps : y;
                        var E = u.type,
                            C = u.updateQueue;
                        (u.updateQueue = null), C !== null && Pe(m, C, E, l, y, u);
                    }
                    return;
                case 6:
                    if (u.stateNode === null) throw Error(o(162));
                    (m = u.memoizedProps), Ie(u.stateNode, l !== null ? l.memoizedProps : m, m);
                    return;
                case 3:
                    we &&
                        l !== null &&
                        l.memoizedState.isDehydrated &&
                        $(u.stateNode.containerInfo);
                    return;
                case 12:
                    return;
                case 13:
                    Cd(u);
                    return;
                case 19:
                    Cd(u);
                    return;
                case 17:
                    return;
            }
            throw Error(o(163));
        }
        switch (u.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Jo(3, u, u.return), Yu(3, u), Jo(5, u, u.return);
                return;
            case 12:
                return;
            case 13:
                Cd(u);
                return;
            case 19:
                Cd(u);
                return;
            case 3:
                we && l !== null && l.memoizedState.isDehydrated && $(u.stateNode.containerInfo);
                break;
            case 22:
            case 23:
                return;
        }
        e: if (V) {
            switch (u.tag) {
                case 1:
                case 5:
                case 6:
                    break e;
                case 3:
                case 4:
                    (u = u.stateNode), Ce(u.containerInfo, u.pendingChildren);
                    break e;
            }
            throw Error(o(163));
        }
    }
    function Cd(l) {
        var u = l.updateQueue;
        if (u !== null) {
            l.updateQueue = null;
            var m = l.stateNode;
            m === null && (m = l.stateNode = new XR()),
                u.forEach(function (y) {
                    var E = iP.bind(null, l, y);
                    m.has(y) || (m.add(y), y.then(E, E));
                });
        }
    }
    function qR(l, u) {
        for (Be = u; Be !== null; ) {
            u = Be;
            var m = u.deletions;
            if (m !== null)
                for (var y = 0; y < m.length; y++) {
                    var E = m[y];
                    try {
                        var C = l;
                        De ? xS(C, E, u) : mS(C, E, u);
                        var z = E.alternate;
                        z !== null && (z.return = null), (E.return = null);
                    } catch (st) {
                        Ni(E, u, st);
                    }
                }
            if (((m = u.child), u.subtreeFlags & 12854 && m !== null)) (m.return = u), (Be = m);
            else
                for (; Be !== null; ) {
                    u = Be;
                    try {
                        var Z = u.flags;
                        if ((Z & 32 && De && Qe(u.stateNode), Z & 512)) {
                            var he = u.alternate;
                            if (he !== null) {
                                var Le = he.ref;
                                Le !== null &&
                                    (typeof Le == 'function' ? Le(null) : (Le.current = null));
                            }
                        }
                        if (Z & 8192)
                            switch (u.tag) {
                                case 13:
                                    if (u.memoizedState !== null) {
                                        var Ze = u.alternate;
                                        (Ze === null || Ze.memoizedState === null) && (qg = Wn());
                                    }
                                    break;
                                case 22:
                                    var St = u.memoizedState !== null,
                                        lt = u.alternate,
                                        qt = lt !== null && lt.memoizedState !== null;
                                    if (((m = u), De)) {
                                        e: if (((y = m), (E = St), (C = null), De))
                                            for (var ot = y; ; ) {
                                                if (ot.tag === 5) {
                                                    if (C === null) {
                                                        C = ot;
                                                        var ai = ot.stateNode;
                                                        E
                                                            ? Lt(ai)
                                                            : Xt(ot.stateNode, ot.memoizedProps);
                                                    }
                                                } else if (ot.tag === 6) {
                                                    if (C === null) {
                                                        var mr = ot.stateNode;
                                                        E ? vt(mr) : q(mr, ot.memoizedProps);
                                                    }
                                                } else if (
                                                    ((ot.tag !== 22 && ot.tag !== 23) ||
                                                        ot.memoizedState === null ||
                                                        ot === y) &&
                                                    ot.child !== null
                                                ) {
                                                    (ot.child.return = ot), (ot = ot.child);
                                                    continue;
                                                }
                                                if (ot === y) break;
                                                for (; ot.sibling === null; ) {
                                                    if (ot.return === null || ot.return === y)
                                                        break e;
                                                    C === ot && (C = null), (ot = ot.return);
                                                }
                                                C === ot && (C = null),
                                                    (ot.sibling.return = ot.return),
                                                    (ot = ot.sibling);
                                            }
                                    }
                                    if (St && !qt && m.mode & 1) {
                                        Be = m;
                                        for (var re = m.child; re !== null; ) {
                                            for (m = Be = re; Be !== null; ) {
                                                y = Be;
                                                var J = y.child;
                                                switch (y.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 14:
                                                    case 15:
                                                        Jo(4, y, y.return);
                                                        break;
                                                    case 1:
                                                        Ad(y, y.return);
                                                        var fe = y.stateNode;
                                                        if (
                                                            typeof fe.componentWillUnmount ==
                                                            'function'
                                                        ) {
                                                            var Ve = y.return;
                                                            try {
                                                                (fe.props = y.memoizedProps),
                                                                    (fe.state = y.memoizedState),
                                                                    fe.componentWillUnmount();
                                                            } catch (st) {
                                                                Ni(y, Ve, st);
                                                            }
                                                        }
                                                        break;
                                                    case 5:
                                                        Ad(y, y.return);
                                                        break;
                                                    case 22:
                                                        if (y.memoizedState !== null) {
                                                            wS(m);
                                                            continue;
                                                        }
                                                }
                                                J !== null ? ((J.return = y), (Be = J)) : wS(m);
                                            }
                                            re = re.sibling;
                                        }
                                    }
                            }
                        switch (Z & 4102) {
                            case 2:
                                yS(u), (u.flags &= -3);
                                break;
                            case 6:
                                yS(u), (u.flags &= -3), Hg(u.alternate, u);
                                break;
                            case 4096:
                                u.flags &= -4097;
                                break;
                            case 4100:
                                (u.flags &= -4097), Hg(u.alternate, u);
                                break;
                            case 4:
                                Hg(u.alternate, u);
                        }
                    } catch (st) {
                        Ni(u, u.return, st);
                    }
                    if (((m = u.sibling), m !== null)) {
                        (m.return = u.return), (Be = m);
                        break;
                    }
                    Be = u.return;
                }
        }
    }
    function ZR(l, u, m) {
        (Be = l), SS(l);
    }
    function SS(l, u, m) {
        for (var y = (l.mode & 1) !== 0; Be !== null; ) {
            var E = Be,
                C = E.child;
            if (E.tag === 22 && y) {
                var z = E.memoizedState !== null || Td;
                if (!z) {
                    var Z = E.alternate,
                        he = (Z !== null && Z.memoizedState !== null) || Ko;
                    Z = Td;
                    var Le = Ko;
                    if (((Td = z), (Ko = he) && !Le))
                        for (Be = E; Be !== null; )
                            (z = Be),
                                (he = z.child),
                                z.tag === 22 && z.memoizedState !== null
                                    ? ES(E)
                                    : he !== null
                                    ? ((he.return = z), (Be = he))
                                    : ES(E);
                    for (; C !== null; ) (Be = C), SS(C), (C = C.sibling);
                    (Be = E), (Td = Z), (Ko = Le);
                }
                MS(l);
            } else E.subtreeFlags & 8772 && C !== null ? ((C.return = E), (Be = C)) : MS(l);
        }
    }
    function MS(l) {
        for (; Be !== null; ) {
            var u = Be;
            if (u.flags & 8772) {
                var m = u.alternate;
                try {
                    if (u.flags & 8772)
                        switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Ko || Yu(5, u);
                                break;
                            case 1:
                                var y = u.stateNode;
                                if (u.flags & 4 && !Ko)
                                    if (m === null) y.componentDidMount();
                                    else {
                                        var E =
                                            u.elementType === u.type
                                                ? m.memoizedProps
                                                : Cr(u.type, m.memoizedProps);
                                        y.componentDidUpdate(
                                            E,
                                            m.memoizedState,
                                            y.__reactInternalSnapshotBeforeUpdate
                                        );
                                    }
                                var C = u.updateQueue;
                                C !== null && g1(u, C, y);
                                break;
                            case 3:
                                var z = u.updateQueue;
                                if (z !== null) {
                                    if (((m = null), u.child !== null))
                                        switch (u.child.tag) {
                                            case 5:
                                                m = te(u.child.stateNode);
                                                break;
                                            case 1:
                                                m = u.child.stateNode;
                                        }
                                    g1(u, z, m);
                                }
                                break;
                            case 5:
                                var Z = u.stateNode;
                                m === null && u.flags & 4 && ht(Z, u.type, u.memoizedProps, u);
                                break;
                            case 6:
                                break;
                            case 4:
                                break;
                            case 12:
                                break;
                            case 13:
                                if (we && u.memoizedState === null) {
                                    var he = u.alternate;
                                    if (he !== null) {
                                        var Le = he.memoizedState;
                                        if (Le !== null) {
                                            var Ze = Le.dehydrated;
                                            Ze !== null && se(Ze);
                                        }
                                    }
                                }
                                break;
                            case 19:
                            case 17:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            default:
                                throw Error(o(163));
                        }
                    Ko || (u.flags & 512 && kg(u));
                } catch (St) {
                    Ni(u, u.return, St);
                }
            }
            if (u === l) {
                Be = null;
                break;
            }
            if (((m = u.sibling), m !== null)) {
                (m.return = u.return), (Be = m);
                break;
            }
            Be = u.return;
        }
    }
    function wS(l) {
        for (; Be !== null; ) {
            var u = Be;
            if (u === l) {
                Be = null;
                break;
            }
            var m = u.sibling;
            if (m !== null) {
                (m.return = u.return), (Be = m);
                break;
            }
            Be = u.return;
        }
    }
    function ES(l) {
        for (; Be !== null; ) {
            var u = Be;
            try {
                switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var m = u.return;
                        try {
                            Yu(4, u);
                        } catch (he) {
                            Ni(u, m, he);
                        }
                        break;
                    case 1:
                        var y = u.stateNode;
                        if (typeof y.componentDidMount == 'function') {
                            var E = u.return;
                            try {
                                y.componentDidMount();
                            } catch (he) {
                                Ni(u, E, he);
                            }
                        }
                        var C = u.return;
                        try {
                            kg(u);
                        } catch (he) {
                            Ni(u, C, he);
                        }
                        break;
                    case 5:
                        var z = u.return;
                        try {
                            kg(u);
                        } catch (he) {
                            Ni(u, z, he);
                        }
                }
            } catch (he) {
                Ni(u, u.return, he);
            }
            if (u === l) {
                Be = null;
                break;
            }
            var Z = u.sibling;
            if (Z !== null) {
                (Z.return = u.return), (Be = Z);
                break;
            }
            Be = u.return;
        }
    }
    var bd = 0,
        Rd = 1,
        Pd = 2,
        Ld = 3,
        Id = 4;
    if (typeof Symbol == 'function' && Symbol.for) {
        var qu = Symbol.for;
        (bd = qu('selector.component')),
            (Rd = qu('selector.has_pseudo_class')),
            (Pd = qu('selector.role')),
            (Ld = qu('selector.test_id')),
            (Id = qu('selector.text'));
    }
    function Vg(l) {
        var u = ve(l);
        if (u != null) {
            if (typeof u.memoizedProps['data-testname'] != 'string') throw Error(o(364));
            return u;
        }
        if (((l = F(l)), l === null)) throw Error(o(362));
        return l.stateNode.current;
    }
    function Gg(l, u) {
        switch (u.$$typeof) {
            case bd:
                if (l.type === u.value) return !0;
                break;
            case Rd:
                e: {
                    (u = u.value), (l = [l, 0]);
                    for (var m = 0; m < l.length; ) {
                        var y = l[m++],
                            E = l[m++],
                            C = u[E];
                        if (y.tag !== 5 || !de(y)) {
                            for (; C != null && Gg(y, C); ) E++, (C = u[E]);
                            if (E === u.length) {
                                u = !0;
                                break e;
                            } else for (y = y.child; y !== null; ) l.push(y, E), (y = y.sibling);
                        }
                    }
                    u = !1;
                }
                return u;
            case Pd:
                if (l.tag === 5 && Me(l.stateNode, u.value)) return !0;
                break;
            case Id:
                if (
                    (l.tag === 5 || l.tag === 6) &&
                    ((l = ce(l)), l !== null && 0 <= l.indexOf(u.value))
                )
                    return !0;
                break;
            case Ld:
                if (
                    l.tag === 5 &&
                    ((l = l.memoizedProps['data-testname']),
                    typeof l == 'string' && l.toLowerCase() === u.value.toLowerCase())
                )
                    return !0;
                break;
            default:
                throw Error(o(365));
        }
        return !1;
    }
    function Wg(l) {
        switch (l.$$typeof) {
            case bd:
                return '<' + (R(l.value) || 'Unknown') + '>';
            case Rd:
                return ':has(' + (Wg(l) || '') + ')';
            case Pd:
                return '[role="' + l.value + '"]';
            case Id:
                return '"' + l.value + '"';
            case Ld:
                return '[data-testname="' + l.value + '"]';
            default:
                throw Error(o(365));
        }
    }
    function TS(l, u) {
        var m = [];
        l = [l, 0];
        for (var y = 0; y < l.length; ) {
            var E = l[y++],
                C = l[y++],
                z = u[C];
            if (E.tag !== 5 || !de(E)) {
                for (; z != null && Gg(E, z); ) C++, (z = u[C]);
                if (C === u.length) m.push(E);
                else for (E = E.child; E !== null; ) l.push(E, C), (E = E.sibling);
            }
        }
        return m;
    }
    function jg(l, u) {
        if (!yt) throw Error(o(363));
        (l = Vg(l)), (l = TS(l, u)), (u = []), (l = Array.from(l));
        for (var m = 0; m < l.length; ) {
            var y = l[m++];
            if (y.tag === 5) de(y) || u.push(y.stateNode);
            else for (y = y.child; y !== null; ) l.push(y), (y = y.sibling);
        }
        return u;
    }
    var KR = Math.ceil,
        Nd = a.ReactCurrentDispatcher,
        Xg = a.ReactCurrentOwner,
        Tn = a.ReactCurrentBatchConfig,
        Pt = 0,
        Ln = null,
        In = null,
        $n = 0,
        Xi = 0,
        ll = Vn(0),
        Fn = 0,
        Zu = null,
        ul = 0,
        Dd = 0,
        Yg = 0,
        Ku = null,
        Li = null,
        qg = 0,
        Zg = 1 / 0;
    function cl() {
        Zg = Wn() + 500;
    }
    var Ud = !1,
        Kg = null,
        Qs = null,
        Od = !1,
        $s = null,
        Fd = 0,
        Ju = 0,
        Jg = null,
        kd = -1,
        zd = 0;
    function _i() {
        return Pt & 6 ? Wn() : kd !== -1 ? kd : (kd = Wn());
    }
    function eo(l) {
        return l.mode & 1
            ? Pt & 2 && $n !== 0
                ? $n & -$n
                : IR.transition !== null
                ? (zd === 0 && ((l = Qf), (Qf <<= 1), !(Qf & 4194240) && (Qf = 64), (zd = l)), zd)
                : ((l = Ft), l !== 0 ? l : ye())
            : 1;
    }
    function hr(l, u, m) {
        if (50 < Ju) throw ((Ju = 0), (Jg = null), Error(o(185)));
        var y = Bd(l, u);
        return y === null
            ? null
            : (Du(y, u, m),
              (!(Pt & 2) || y !== Ln) &&
                  (y === Ln && (!(Pt & 2) && (Dd |= u), Fn === 4 && to(y, $n)),
                  Ii(y, m),
                  u === 1 && Pt === 0 && !(l.mode & 1) && (cl(), nd && Qr())),
              y);
    }
    function Bd(l, u) {
        l.lanes |= u;
        var m = l.alternate;
        for (m !== null && (m.lanes |= u), m = l, l = l.return; l !== null; )
            (l.childLanes |= u),
                (m = l.alternate),
                m !== null && (m.childLanes |= u),
                (m = l),
                (l = l.return);
        return m.tag === 3 ? m.stateNode : null;
    }
    function Ii(l, u) {
        var m = l.callbackNode;
        wR(l, u);
        var y = ed(l, l === Ln ? $n : 0);
        if (y === 0) m !== null && f1(m), (l.callbackNode = null), (l.callbackPriority = 0);
        else if (((u = y & -y), l.callbackPriority !== u)) {
            if ((m != null && f1(m), u === 1))
                l.tag === 0 ? LR(CS.bind(null, l)) : d1(CS.bind(null, l)),
                    He
                        ? Ke(function () {
                              Pt === 0 && Qr();
                          })
                        : sg(og, Qr),
                    (m = null);
            else {
                switch (c1(y)) {
                    case 1:
                        m = og;
                        break;
                    case 4:
                        m = CR;
                        break;
                    case 16:
                        m = ag;
                        break;
                    case 536870912:
                        m = bR;
                        break;
                    default:
                        m = ag;
                }
                m = OS(m, AS.bind(null, l));
            }
            (l.callbackPriority = u), (l.callbackNode = m);
        }
    }
    function AS(l, u) {
        if (((kd = -1), (zd = 0), Pt & 6)) throw Error(o(327));
        var m = l.callbackNode;
        if (ea() && l.callbackNode !== m) return null;
        var y = ed(l, l === Ln ? $n : 0);
        if (y === 0) return null;
        if (y & 30 || y & l.expiredLanes || u) u = Hd(l, y);
        else {
            u = y;
            var E = Pt;
            Pt |= 2;
            var C = PS();
            (Ln !== l || $n !== u) && (cl(), Qo(l, u));
            do
                try {
                    $R();
                    break;
                } catch (Z) {
                    RS(l, Z);
                }
            while (1);
            cg(),
                (Nd.current = C),
                (Pt = E),
                In !== null ? (u = 0) : ((Ln = null), ($n = 0), (u = Fn));
        }
        if (u !== 0) {
            if ((u === 2 && ((E = ng(l)), E !== 0 && ((y = E), (u = Qg(l, E)))), u === 1))
                throw ((m = Zu), Qo(l, 0), to(l, y), Ii(l, Wn()), m);
            if (u === 6) to(l, y);
            else {
                if (
                    ((E = l.current.alternate),
                    !(y & 30) &&
                        !JR(E) &&
                        ((u = Hd(l, y)),
                        u === 2 && ((C = ng(l)), C !== 0 && ((y = C), (u = Qg(l, C)))),
                        u === 1))
                )
                    throw ((m = Zu), Qo(l, 0), to(l, y), Ii(l, Wn()), m);
                switch (((l.finishedWork = E), (l.finishedLanes = y), u)) {
                    case 0:
                    case 1:
                        throw Error(o(345));
                    case 2:
                        $o(l, Li);
                        break;
                    case 3:
                        if ((to(l, y), (y & 130023424) === y && ((u = qg + 500 - Wn()), 10 < u))) {
                            if (ed(l, 0) !== 0) break;
                            if (((E = l.suspendedLanes), (E & y) !== y)) {
                                _i(), (l.pingedLanes |= l.suspendedLanes & E);
                                break;
                            }
                            l.timeoutHandle = ke($o.bind(null, l, Li), u);
                            break;
                        }
                        $o(l, Li);
                        break;
                    case 4:
                        if ((to(l, y), (y & 4194240) === y)) break;
                        for (u = l.eventTimes, E = -1; 0 < y; ) {
                            var z = 31 - Vi(y);
                            (C = 1 << z), (z = u[z]), z > E && (E = z), (y &= ~C);
                        }
                        if (
                            ((y = E),
                            (y = Wn() - y),
                            (y =
                                (120 > y
                                    ? 120
                                    : 480 > y
                                    ? 480
                                    : 1080 > y
                                    ? 1080
                                    : 1920 > y
                                    ? 1920
                                    : 3e3 > y
                                    ? 3e3
                                    : 4320 > y
                                    ? 4320
                                    : 1960 * KR(y / 1960)) - y),
                            10 < y)
                        ) {
                            l.timeoutHandle = ke($o.bind(null, l, Li), y);
                            break;
                        }
                        $o(l, Li);
                        break;
                    case 5:
                        $o(l, Li);
                        break;
                    default:
                        throw Error(o(329));
                }
            }
        }
        return Ii(l, Wn()), l.callbackNode === m ? AS.bind(null, l) : null;
    }
    function Qg(l, u) {
        var m = Ku;
        return (
            l.current.memoizedState.isDehydrated && (Qo(l, u).flags |= 256),
            (l = Hd(l, u)),
            l !== 2 && ((u = Li), (Li = m), u !== null && $g(u)),
            l
        );
    }
    function $g(l) {
        Li === null ? (Li = l) : Li.push.apply(Li, l);
    }
    function JR(l) {
        for (var u = l; ; ) {
            if (u.flags & 16384) {
                var m = u.updateQueue;
                if (m !== null && ((m = m.stores), m !== null))
                    for (var y = 0; y < m.length; y++) {
                        var E = m[y],
                            C = E.getSnapshot;
                        E = E.value;
                        try {
                            if (!Jr(C(), E)) return !1;
                        } catch {
                            return !1;
                        }
                    }
            }
            if (((m = u.child), u.subtreeFlags & 16384 && m !== null)) (m.return = u), (u = m);
            else {
                if (u === l) break;
                for (; u.sibling === null; ) {
                    if (u.return === null || u.return === l) return !0;
                    u = u.return;
                }
                (u.sibling.return = u.return), (u = u.sibling);
            }
        }
        return !0;
    }
    function to(l, u) {
        for (
            u &= ~Yg, u &= ~Dd, l.suspendedLanes |= u, l.pingedLanes &= ~u, l = l.expirationTimes;
            0 < u;

        ) {
            var m = 31 - Vi(u),
                y = 1 << m;
            (l[m] = -1), (u &= ~y);
        }
    }
    function CS(l) {
        if (Pt & 6) throw Error(o(327));
        ea();
        var u = ed(l, 0);
        if (!(u & 1)) return Ii(l, Wn()), null;
        var m = Hd(l, u);
        if (l.tag !== 0 && m === 2) {
            var y = ng(l);
            y !== 0 && ((u = y), (m = Qg(l, y)));
        }
        if (m === 1) throw ((m = Zu), Qo(l, 0), to(l, u), Ii(l, Wn()), m);
        if (m === 6) throw Error(o(345));
        return (
            (l.finishedWork = l.current.alternate),
            (l.finishedLanes = u),
            $o(l, Li),
            Ii(l, Wn()),
            null
        );
    }
    function bS(l) {
        $s !== null && $s.tag === 0 && !(Pt & 6) && ea();
        var u = Pt;
        Pt |= 1;
        var m = Tn.transition,
            y = Ft;
        try {
            if (((Tn.transition = null), (Ft = 1), l)) return l();
        } finally {
            (Ft = y), (Tn.transition = m), (Pt = u), !(Pt & 6) && Qr();
        }
    }
    function ev() {
        (Xi = ll.current), dt(ll);
    }
    function Qo(l, u) {
        (l.finishedWork = null), (l.finishedLanes = 0);
        var m = l.timeoutHandle;
        if ((m !== Xe && ((l.timeoutHandle = Xe), et(m)), In !== null))
            for (m = In.return; m !== null; ) {
                var y = m;
                switch ((vg(y), y.tag)) {
                    case 1:
                        (y = y.type.childContextTypes), y != null && En();
                        break;
                    case 3:
                        ol(), dt(vn), dt(At), Eg();
                        break;
                    case 5:
                        Mg(y);
                        break;
                    case 4:
                        ol();
                        break;
                    case 13:
                        dt(cn);
                        break;
                    case 19:
                        dt(cn);
                        break;
                    case 10:
                        fg(y.type._context);
                        break;
                    case 22:
                    case 23:
                        ev();
                }
                m = m.return;
            }
        if (
            ((Ln = l),
            (In = l = no(l.current, null)),
            ($n = Xi = u),
            (Fn = 0),
            (Zu = null),
            (Yg = Dd = ul = 0),
            (Li = Ku = null),
            $r !== null)
        ) {
            for (u = 0; u < $r.length; u++)
                if (((m = $r[u]), (y = m.interleaved), y !== null)) {
                    m.interleaved = null;
                    var E = y.next,
                        C = m.pending;
                    if (C !== null) {
                        var z = C.next;
                        (C.next = E), (y.next = z);
                    }
                    m.pending = y;
                }
            $r = null;
        }
        return l;
    }
    function RS(l, u) {
        do {
            var m = In;
            try {
                if ((cg(), (hd.current = yd), pd)) {
                    for (var y = _n.memoizedState; y !== null; ) {
                        var E = y.queue;
                        E !== null && (E.pending = null), (y = y.next);
                    }
                    pd = !1;
                }
                if (
                    ((al = 0),
                    (jn = ri = _n = null),
                    (Bu = !1),
                    (Hu = 0),
                    (Xg.current = null),
                    m === null || m.return === null)
                ) {
                    (Fn = 1), (Zu = u), (In = null);
                    break;
                }
                e: {
                    var C = l,
                        z = m.return,
                        Z = m,
                        he = u;
                    if (
                        ((u = $n),
                        (Z.flags |= 32768),
                        he !== null && typeof he == 'object' && typeof he.then == 'function')
                    ) {
                        var Le = he,
                            Ze = Z,
                            St = Ze.tag;
                        if (!(Ze.mode & 1) && (St === 0 || St === 11 || St === 15)) {
                            var lt = Ze.alternate;
                            lt
                                ? ((Ze.updateQueue = lt.updateQueue),
                                  (Ze.memoizedState = lt.memoizedState),
                                  (Ze.lanes = lt.lanes))
                                : ((Ze.updateQueue = null), (Ze.memoizedState = null));
                        }
                        var qt = K1(z);
                        if (qt !== null) {
                            (qt.flags &= -257),
                                J1(qt, z, Z, C, u),
                                qt.mode & 1 && Z1(C, Le, u),
                                (u = qt),
                                (he = Le);
                            var ot = u.updateQueue;
                            if (ot === null) {
                                var ai = new Set();
                                ai.add(he), (u.updateQueue = ai);
                            } else ot.add(he);
                            break e;
                        } else {
                            if (!(u & 1)) {
                                Z1(C, Le, u), tv();
                                break e;
                            }
                            he = Error(o(426));
                        }
                    } else if (sn && Z.mode & 1) {
                        var mr = K1(z);
                        if (mr !== null) {
                            !(mr.flags & 65536) && (mr.flags |= 256), J1(mr, z, Z, C, u), xg(he);
                            break e;
                        }
                    }
                    (C = he),
                        Fn !== 4 && (Fn = 2),
                        Ku === null ? (Ku = [C]) : Ku.push(C),
                        (he = Lg(he, Z)),
                        (Z = z);
                    do {
                        switch (Z.tag) {
                            case 3:
                                (Z.flags |= 65536), (u &= -u), (Z.lanes |= u);
                                var re = Y1(Z, he, u);
                                m1(Z, re);
                                break e;
                            case 1:
                                C = he;
                                var J = Z.type,
                                    fe = Z.stateNode;
                                if (
                                    !(Z.flags & 128) &&
                                    (typeof J.getDerivedStateFromError == 'function' ||
                                        (fe !== null &&
                                            typeof fe.componentDidCatch == 'function' &&
                                            (Qs === null || !Qs.has(fe))))
                                ) {
                                    (Z.flags |= 65536), (u &= -u), (Z.lanes |= u);
                                    var Ve = q1(Z, C, u);
                                    m1(Z, Ve);
                                    break e;
                                }
                        }
                        Z = Z.return;
                    } while (Z !== null);
                }
                IS(m);
            } catch (st) {
                (u = st), In === m && m !== null && (In = m = m.return);
                continue;
            }
            break;
        } while (1);
    }
    function PS() {
        var l = Nd.current;
        return (Nd.current = yd), l === null ? yd : l;
    }
    function tv() {
        (Fn === 0 || Fn === 3 || Fn === 2) && (Fn = 4),
            Ln === null || (!(ul & 268435455) && !(Dd & 268435455)) || to(Ln, $n);
    }
    function Hd(l, u) {
        var m = Pt;
        Pt |= 2;
        var y = PS();
        (Ln === l && $n === u) || Qo(l, u);
        do
            try {
                QR();
                break;
            } catch (E) {
                RS(l, E);
            }
        while (1);
        if ((cg(), (Pt = m), (Nd.current = y), In !== null)) throw Error(o(261));
        return (Ln = null), ($n = 0), Fn;
    }
    function QR() {
        for (; In !== null; ) LS(In);
    }
    function $R() {
        for (; In !== null && !TR(); ) LS(In);
    }
    function LS(l) {
        var u = US(l.alternate, l, Xi);
        (l.memoizedProps = l.pendingProps), u === null ? IS(l) : (In = u), (Xg.current = null);
    }
    function IS(l) {
        var u = l;
        do {
            var m = u.alternate;
            if (((l = u.return), u.flags & 32768)) {
                if (((m = jR(m, u)), m !== null)) {
                    (m.flags &= 32767), (In = m);
                    return;
                }
                if (l !== null) (l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null);
                else {
                    (Fn = 6), (In = null);
                    return;
                }
            } else if (((m = VR(m, u, Xi)), m !== null)) {
                In = m;
                return;
            }
            if (((u = u.sibling), u !== null)) {
                In = u;
                return;
            }
            In = u = l;
        } while (u !== null);
        Fn === 0 && (Fn = 5);
    }
    function $o(l, u) {
        var m = Ft,
            y = Tn.transition;
        try {
            (Tn.transition = null), (Ft = 1), eP(l, u, m);
        } finally {
            (Tn.transition = y), (Ft = m);
        }
        return null;
    }
    function eP(l, u, m) {
        do ea();
        while ($s !== null);
        if (Pt & 6) throw Error(o(327));
        var y = l.finishedWork,
            E = l.finishedLanes;
        if (y === null) return null;
        if (((l.finishedWork = null), (l.finishedLanes = 0), y === l.current)) throw Error(o(177));
        (l.callbackNode = null), (l.callbackPriority = 0);
        var C = y.lanes | y.childLanes;
        if (
            (ER(l, C),
            l === Ln && ((In = Ln = null), ($n = 0)),
            (!(y.subtreeFlags & 2064) && !(y.flags & 2064)) ||
                Od ||
                ((Od = !0),
                OS(ag, function () {
                    return ea(), null;
                })),
            (C = (y.flags & 15990) !== 0),
            y.subtreeFlags & 15990 || C)
        ) {
            (C = Tn.transition), (Tn.transition = null);
            var z = Ft;
            Ft = 1;
            var Z = Pt;
            (Pt |= 4),
                (Xg.current = null),
                YR(l, y),
                qR(l, y),
                H(l.containerInfo),
                (l.current = y),
                ZR(y),
                AR(),
                (Pt = Z),
                (Ft = z),
                (Tn.transition = C);
        } else l.current = y;
        if (
            (Od && ((Od = !1), ($s = l), (Fd = E)),
            (C = l.pendingLanes),
            C === 0 && (Qs = null),
            RR(y.stateNode),
            Ii(l, Wn()),
            u !== null)
        )
            for (m = l.onRecoverableError, y = 0; y < u.length; y++) m(u[y]);
        if (Ud) throw ((Ud = !1), (l = Kg), (Kg = null), l);
        return (
            Fd & 1 && l.tag !== 0 && ea(),
            (C = l.pendingLanes),
            C & 1 ? (l === Jg ? Ju++ : ((Ju = 0), (Jg = l))) : (Ju = 0),
            Qr(),
            null
        );
    }
    function ea() {
        if ($s !== null) {
            var l = c1(Fd),
                u = Tn.transition,
                m = Ft;
            try {
                if (((Tn.transition = null), (Ft = 16 > l ? 16 : l), $s === null)) var y = !1;
                else {
                    if (((l = $s), ($s = null), (Fd = 0), Pt & 6)) throw Error(o(331));
                    var E = Pt;
                    for (Pt |= 4, Be = l.current; Be !== null; ) {
                        var C = Be,
                            z = C.child;
                        if (Be.flags & 16) {
                            var Z = C.deletions;
                            if (Z !== null) {
                                for (var he = 0; he < Z.length; he++) {
                                    var Le = Z[he];
                                    for (Be = Le; Be !== null; ) {
                                        var Ze = Be;
                                        switch (Ze.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Jo(8, Ze, C);
                                        }
                                        var St = Ze.child;
                                        if (St !== null) (St.return = Ze), (Be = St);
                                        else
                                            for (; Be !== null; ) {
                                                Ze = Be;
                                                var lt = Ze.sibling,
                                                    qt = Ze.return;
                                                if ((gS(Ze), Ze === Le)) {
                                                    Be = null;
                                                    break;
                                                }
                                                if (lt !== null) {
                                                    (lt.return = qt), (Be = lt);
                                                    break;
                                                }
                                                Be = qt;
                                            }
                                    }
                                }
                                var ot = C.alternate;
                                if (ot !== null) {
                                    var ai = ot.child;
                                    if (ai !== null) {
                                        ot.child = null;
                                        do {
                                            var mr = ai.sibling;
                                            (ai.sibling = null), (ai = mr);
                                        } while (ai !== null);
                                    }
                                }
                                Be = C;
                            }
                        }
                        if (C.subtreeFlags & 2064 && z !== null) (z.return = C), (Be = z);
                        else
                            e: for (; Be !== null; ) {
                                if (((C = Be), C.flags & 2048))
                                    switch (C.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Jo(9, C, C.return);
                                    }
                                var re = C.sibling;
                                if (re !== null) {
                                    (re.return = C.return), (Be = re);
                                    break e;
                                }
                                Be = C.return;
                            }
                    }
                    var J = l.current;
                    for (Be = J; Be !== null; ) {
                        z = Be;
                        var fe = z.child;
                        if (z.subtreeFlags & 2064 && fe !== null) (fe.return = z), (Be = fe);
                        else
                            e: for (z = J; Be !== null; ) {
                                if (((Z = Be), Z.flags & 2048))
                                    try {
                                        switch (Z.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Yu(9, Z);
                                        }
                                    } catch (st) {
                                        Ni(Z, Z.return, st);
                                    }
                                if (Z === z) {
                                    Be = null;
                                    break e;
                                }
                                var Ve = Z.sibling;
                                if (Ve !== null) {
                                    (Ve.return = Z.return), (Be = Ve);
                                    break e;
                                }
                                Be = Z.return;
                            }
                    }
                    if (((Pt = E), Qr(), Kr && typeof Kr.onPostCommitFiberRoot == 'function'))
                        try {
                            Kr.onPostCommitFiberRoot(td, l);
                        } catch {}
                    y = !0;
                }
                return y;
            } finally {
                (Ft = m), (Tn.transition = u);
            }
        }
        return !1;
    }
    function NS(l, u, m) {
        (u = Lg(m, u)),
            (u = Y1(l, u, 1)),
            Js(l, u),
            (u = _i()),
            (l = Bd(l, 1)),
            l !== null && (Du(l, 1, u), Ii(l, u));
    }
    function Ni(l, u, m) {
        if (l.tag === 3) NS(l, l, m);
        else
            for (; u !== null; ) {
                if (u.tag === 3) {
                    NS(u, l, m);
                    break;
                } else if (u.tag === 1) {
                    var y = u.stateNode;
                    if (
                        typeof u.type.getDerivedStateFromError == 'function' ||
                        (typeof y.componentDidCatch == 'function' && (Qs === null || !Qs.has(y)))
                    ) {
                        (l = Lg(m, l)),
                            (l = q1(u, l, 1)),
                            Js(u, l),
                            (l = _i()),
                            (u = Bd(u, 1)),
                            u !== null && (Du(u, 1, l), Ii(u, l));
                        break;
                    }
                }
                u = u.return;
            }
    }
    function tP(l, u, m) {
        var y = l.pingCache;
        y !== null && y.delete(u),
            (u = _i()),
            (l.pingedLanes |= l.suspendedLanes & m),
            Ln === l &&
                ($n & m) === m &&
                (Fn === 4 || (Fn === 3 && ($n & 130023424) === $n && 500 > Wn() - qg)
                    ? Qo(l, 0)
                    : (Yg |= m)),
            Ii(l, u);
    }
    function DS(l, u) {
        u === 0 &&
            (l.mode & 1 ? ((u = $f), ($f <<= 1), !($f & 130023424) && ($f = 4194304)) : (u = 1));
        var m = _i();
        (l = Bd(l, u)), l !== null && (Du(l, u, m), Ii(l, m));
    }
    function nP(l) {
        var u = l.memoizedState,
            m = 0;
        u !== null && (m = u.retryLane), DS(l, m);
    }
    function iP(l, u) {
        var m = 0;
        switch (l.tag) {
            case 13:
                var y = l.stateNode,
                    E = l.memoizedState;
                E !== null && (m = E.retryLane);
                break;
            case 19:
                y = l.stateNode;
                break;
            default:
                throw Error(o(314));
        }
        y !== null && y.delete(u), DS(l, m);
    }
    var US;
    US = function (l, u, m) {
        if (l !== null)
            if (l.memoizedProps !== u.pendingProps || vn.current) ji = !0;
            else {
                if (!(l.lanes & m) && !(u.flags & 128)) return (ji = !1), WR(l, u, m);
                ji = !!(l.flags & 131072);
            }
        else (ji = !1), sn && u.flags & 1048576 && S1(u, cd, u.index);
        switch (((u.lanes = 0), u.tag)) {
            case 2:
                var y = u.type;
                l !== null && ((l.alternate = null), (u.alternate = null), (u.flags |= 2)),
                    (l = u.pendingProps);
                var E = ar(u, At.current);
                el(u, m), (E = Ag(null, u, y, l, E, m));
                var C = Cg();
                return (
                    (u.flags |= 1),
                    typeof E == 'object' &&
                    E !== null &&
                    typeof E.render == 'function' &&
                    E.$$typeof === void 0
                        ? ((u.tag = 1),
                          (u.memoizedState = null),
                          (u.updateQueue = null),
                          Gn(y) ? ((C = !0), Qn(u)) : (C = !1),
                          (u.memoizedState =
                              E.state !== null && E.state !== void 0 ? E.state : null),
                          hg(u),
                          (E.updater = ld),
                          (u.stateNode = E),
                          (E._reactInternals = u),
                          mg(u, y, l, m),
                          (u = Dg(null, u, y, !0, C, m)))
                        : ((u.tag = 0), sn && C && gg(u), vi(null, u, E, m), (u = u.child)),
                    u
                );
            case 16:
                y = u.elementType;
                e: {
                    switch (
                        (l !== null && ((l.alternate = null), (u.alternate = null), (u.flags |= 2)),
                        (l = u.pendingProps),
                        (E = y._init),
                        (y = E(y._payload)),
                        (u.type = y),
                        (E = u.tag = sP(y)),
                        (l = Cr(y, l)),
                        E)
                    ) {
                        case 0:
                            u = Ng(null, u, y, l, m);
                            break e;
                        case 1:
                            u = sS(null, u, y, l, m);
                            break e;
                        case 11:
                            u = eS(null, u, y, l, m);
                            break e;
                        case 14:
                            u = tS(null, u, y, Cr(y.type, l), m);
                            break e;
                    }
                    throw Error(o(306, y, ''));
                }
                return u;
            case 0:
                return (
                    (y = u.type),
                    (E = u.pendingProps),
                    (E = u.elementType === y ? E : Cr(y, E)),
                    Ng(l, u, y, E, m)
                );
            case 1:
                return (
                    (y = u.type),
                    (E = u.pendingProps),
                    (E = u.elementType === y ? E : Cr(y, E)),
                    sS(l, u, y, E, m)
                );
            case 3:
                e: {
                    if ((oS(u), l === null)) throw Error(o(387));
                    (y = u.pendingProps),
                        (C = u.memoizedState),
                        (E = C.element),
                        p1(l, u),
                        ad(u, y, null, m);
                    var z = u.memoizedState;
                    if (((y = z.element), we && C.isDehydrated))
                        if (
                            ((C = {
                                element: y,
                                isDehydrated: !1,
                                cache: z.cache,
                                transitions: z.transitions,
                            }),
                            (u.updateQueue.baseState = C),
                            (u.memoizedState = C),
                            u.flags & 256)
                        ) {
                            (E = Error(o(423))), (u = aS(l, u, y, m, E));
                            break e;
                        } else if (y !== E) {
                            (E = Error(o(424))), (u = aS(l, u, y, m, E));
                            break e;
                        } else
                            for (
                                we &&
                                    ((Wi = ln(u.stateNode.containerInfo)),
                                    (Gi = u),
                                    (sn = !0),
                                    (br = null),
                                    (Uu = !1)),
                                    m = C1(u, null, y, m),
                                    u.child = m;
                                m;

                            )
                                (m.flags = (m.flags & -3) | 4096), (m = m.sibling);
                    else {
                        if ((il(), y === E)) {
                            u = xs(l, u, m);
                            break e;
                        }
                        vi(l, u, y, m);
                    }
                    u = u.child;
                }
                return u;
            case 5:
                return (
                    b1(u),
                    l === null && yg(u),
                    (y = u.type),
                    (E = u.pendingProps),
                    (C = l !== null ? l.memoizedProps : null),
                    (z = E.children),
                    me(y, E) ? (z = null) : C !== null && me(y, C) && (u.flags |= 32),
                    rS(l, u),
                    vi(l, u, z, m),
                    u.child
                );
            case 6:
                return l === null && yg(u), null;
            case 13:
                return lS(l, u, m);
            case 4:
                return (
                    Sg(u, u.stateNode.containerInfo),
                    (y = u.pendingProps),
                    l === null ? (u.child = rl(u, null, y, m)) : vi(l, u, y, m),
                    u.child
                );
            case 11:
                return (
                    (y = u.type),
                    (E = u.pendingProps),
                    (E = u.elementType === y ? E : Cr(y, E)),
                    eS(l, u, y, E, m)
                );
            case 7:
                return vi(l, u, u.pendingProps, m), u.child;
            case 8:
                return vi(l, u, u.pendingProps.children, m), u.child;
            case 12:
                return vi(l, u, u.pendingProps.children, m), u.child;
            case 10:
                e: {
                    if (
                        ((y = u.type._context),
                        (E = u.pendingProps),
                        (C = u.memoizedProps),
                        (z = E.value),
                        h1(u, y, z),
                        C !== null)
                    )
                        if (Jr(C.value, z)) {
                            if (C.children === E.children && !vn.current) {
                                u = xs(l, u, m);
                                break e;
                            }
                        } else
                            for (C = u.child, C !== null && (C.return = u); C !== null; ) {
                                var Z = C.dependencies;
                                if (Z !== null) {
                                    z = C.child;
                                    for (var he = Z.firstContext; he !== null; ) {
                                        if (he.context === y) {
                                            if (C.tag === 1) {
                                                (he = gs(-1, m & -m)), (he.tag = 2);
                                                var Le = C.updateQueue;
                                                if (Le !== null) {
                                                    Le = Le.shared;
                                                    var Ze = Le.pending;
                                                    Ze === null
                                                        ? (he.next = he)
                                                        : ((he.next = Ze.next), (Ze.next = he)),
                                                        (Le.pending = he);
                                                }
                                            }
                                            (C.lanes |= m),
                                                (he = C.alternate),
                                                he !== null && (he.lanes |= m),
                                                dg(C.return, m, u),
                                                (Z.lanes |= m);
                                            break;
                                        }
                                        he = he.next;
                                    }
                                } else if (C.tag === 10) z = C.type === u.type ? null : C.child;
                                else if (C.tag === 18) {
                                    if (((z = C.return), z === null)) throw Error(o(341));
                                    (z.lanes |= m),
                                        (Z = z.alternate),
                                        Z !== null && (Z.lanes |= m),
                                        dg(z, m, u),
                                        (z = C.sibling);
                                } else z = C.child;
                                if (z !== null) z.return = C;
                                else
                                    for (z = C; z !== null; ) {
                                        if (z === u) {
                                            z = null;
                                            break;
                                        }
                                        if (((C = z.sibling), C !== null)) {
                                            (C.return = z.return), (z = C);
                                            break;
                                        }
                                        z = z.return;
                                    }
                                C = z;
                            }
                    vi(l, u, E.children, m), (u = u.child);
                }
                return u;
            case 9:
                return (
                    (E = u.type),
                    (y = u.pendingProps.children),
                    el(u, m),
                    (E = lr(E)),
                    (y = y(E)),
                    (u.flags |= 1),
                    vi(l, u, y, m),
                    u.child
                );
            case 14:
                return (
                    (y = u.type),
                    (E = Cr(y, u.pendingProps)),
                    (E = Cr(y.type, E)),
                    tS(l, u, y, E, m)
                );
            case 15:
                return nS(l, u, u.type, u.pendingProps, m);
            case 17:
                return (
                    (y = u.type),
                    (E = u.pendingProps),
                    (E = u.elementType === y ? E : Cr(y, E)),
                    l !== null && ((l.alternate = null), (u.alternate = null), (u.flags |= 2)),
                    (u.tag = 1),
                    Gn(y) ? ((l = !0), Qn(u)) : (l = !1),
                    el(u, m),
                    y1(u, y, E),
                    mg(u, y, E, m),
                    Dg(null, u, y, !0, l, m)
                );
            case 19:
                return dS(l, u, m);
            case 22:
                return iS(l, u, m);
        }
        throw Error(o(156, u.tag));
    };
    function OS(l, u) {
        return sg(l, u);
    }
    function rP(l, u, m, y) {
        (this.tag = l),
            (this.key = m),
            (this.sibling =
                this.child =
                this.return =
                this.stateNode =
                this.type =
                this.elementType =
                    null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = u),
            (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
            (this.mode = y),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
    }
    function pr(l, u, m, y) {
        return new rP(l, u, m, y);
    }
    function nv(l) {
        return (l = l.prototype), !(!l || !l.isReactComponent);
    }
    function sP(l) {
        if (typeof l == 'function') return nv(l) ? 1 : 0;
        if (l != null) {
            if (((l = l.$$typeof), l === w)) return 11;
            if (l === S) return 14;
        }
        return 2;
    }
    function no(l, u) {
        var m = l.alternate;
        return (
            m === null
                ? ((m = pr(l.tag, u, l.key, l.mode)),
                  (m.elementType = l.elementType),
                  (m.type = l.type),
                  (m.stateNode = l.stateNode),
                  (m.alternate = l),
                  (l.alternate = m))
                : ((m.pendingProps = u),
                  (m.type = l.type),
                  (m.flags = 0),
                  (m.subtreeFlags = 0),
                  (m.deletions = null)),
            (m.flags = l.flags & 14680064),
            (m.childLanes = l.childLanes),
            (m.lanes = l.lanes),
            (m.child = l.child),
            (m.memoizedProps = l.memoizedProps),
            (m.memoizedState = l.memoizedState),
            (m.updateQueue = l.updateQueue),
            (u = l.dependencies),
            (m.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }),
            (m.sibling = l.sibling),
            (m.index = l.index),
            (m.ref = l.ref),
            m
        );
    }
    function Vd(l, u, m, y, E, C) {
        var z = 2;
        if (((y = l), typeof l == 'function')) nv(l) && (z = 1);
        else if (typeof l == 'string') z = 5;
        else
            e: switch (l) {
                case d:
                    return ta(m.children, E, C, u);
                case h:
                    (z = 8), (E |= 8);
                    break;
                case p:
                    return (l = pr(12, m, u, E | 2)), (l.elementType = p), (l.lanes = C), l;
                case x:
                    return (l = pr(13, m, u, E)), (l.elementType = x), (l.lanes = C), l;
                case g:
                    return (l = pr(19, m, u, E)), (l.elementType = g), (l.lanes = C), l;
                case T:
                    return Gd(m, E, C, u);
                default:
                    if (typeof l == 'object' && l !== null)
                        switch (l.$$typeof) {
                            case v:
                                z = 10;
                                break e;
                            case _:
                                z = 9;
                                break e;
                            case w:
                                z = 11;
                                break e;
                            case S:
                                z = 14;
                                break e;
                            case M:
                                (z = 16), (y = null);
                                break e;
                        }
                    throw Error(o(130, l == null ? l : typeof l, ''));
            }
        return (u = pr(z, m, u, E)), (u.elementType = l), (u.type = y), (u.lanes = C), u;
    }
    function ta(l, u, m, y) {
        return (l = pr(7, l, y, u)), (l.lanes = m), l;
    }
    function Gd(l, u, m, y) {
        return (l = pr(22, l, y, u)), (l.elementType = T), (l.lanes = m), (l.stateNode = {}), l;
    }
    function iv(l, u, m) {
        return (l = pr(6, l, null, u)), (l.lanes = m), l;
    }
    function rv(l, u, m) {
        return (
            (u = pr(4, l.children !== null ? l.children : [], l.key, u)),
            (u.lanes = m),
            (u.stateNode = {
                containerInfo: l.containerInfo,
                pendingChildren: null,
                implementation: l.implementation,
            }),
            u
        );
    }
    function oP(l, u, m, y, E) {
        (this.tag = u),
            (this.containerInfo = l),
            (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
            (this.timeoutHandle = Xe),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = ig(0)),
            (this.expirationTimes = ig(-1)),
            (this.entangledLanes =
                this.finishedLanes =
                this.mutableReadLanes =
                this.expiredLanes =
                this.pingedLanes =
                this.suspendedLanes =
                this.pendingLanes =
                    0),
            (this.entanglements = ig(0)),
            (this.identifierPrefix = y),
            (this.onRecoverableError = E),
            we && (this.mutableSourceEagerHydrationData = null);
    }
    function FS(l, u, m, y, E, C, z, Z, he) {
        return (
            (l = new oP(l, u, m, Z, he)),
            u === 1 ? ((u = 1), C === !0 && (u |= 8)) : (u = 0),
            (C = pr(3, null, null, u)),
            (l.current = C),
            (C.stateNode = l),
            (C.memoizedState = { element: y, isDehydrated: m, cache: null, transitions: null }),
            hg(C),
            l
        );
    }
    function kS(l) {
        if (!l) return or;
        l = l._reactInternals;
        e: {
            if (G(l) !== l || l.tag !== 1) throw Error(o(170));
            var u = l;
            do {
                switch (u.tag) {
                    case 3:
                        u = u.stateNode.context;
                        break e;
                    case 1:
                        if (Gn(u.type)) {
                            u = u.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e;
                        }
                }
                u = u.return;
            } while (u !== null);
            throw Error(o(171));
        }
        if (l.tag === 1) {
            var m = l.type;
            if (Gn(m)) return Ja(l, m, u);
        }
        return u;
    }
    function zS(l) {
        var u = l._reactInternals;
        if (u === void 0)
            throw typeof l.render == 'function'
                ? Error(o(188))
                : ((l = Object.keys(l).join(',')), Error(o(268, l)));
        return (l = ee(u)), l === null ? null : l.stateNode;
    }
    function BS(l, u) {
        if (((l = l.memoizedState), l !== null && l.dehydrated !== null)) {
            var m = l.retryLane;
            l.retryLane = m !== 0 && m < u ? m : u;
        }
    }
    function sv(l, u) {
        BS(l, u), (l = l.alternate) && BS(l, u);
    }
    function aP(l) {
        return (l = ee(l)), l === null ? null : l.stateNode;
    }
    function lP() {
        return null;
    }
    return (
        (t.attemptContinuousHydration = function (l) {
            if (l.tag === 13) {
                var u = _i();
                hr(l, 134217728, u), sv(l, 134217728);
            }
        }),
        (t.attemptHydrationAtCurrentPriority = function (l) {
            if (l.tag === 13) {
                var u = _i(),
                    m = eo(l);
                hr(l, m, u), sv(l, m);
            }
        }),
        (t.attemptSynchronousHydration = function (l) {
            switch (l.tag) {
                case 3:
                    var u = l.stateNode;
                    if (u.current.memoizedState.isDehydrated) {
                        var m = Nu(u.pendingLanes);
                        m !== 0 && (rg(u, m | 1), Ii(u, Wn()), !(Pt & 6) && (cl(), Qr()));
                    }
                    break;
                case 13:
                    var y = _i();
                    bS(function () {
                        return hr(l, 1, y);
                    }),
                        sv(l, 1);
            }
        }),
        (t.batchedUpdates = function (l, u) {
            var m = Pt;
            Pt |= 1;
            try {
                return l(u);
            } finally {
                (Pt = m), Pt === 0 && (cl(), nd && Qr());
            }
        }),
        (t.createComponentSelector = function (l) {
            return { $$typeof: bd, value: l };
        }),
        (t.createContainer = function (l, u, m, y, E, C, z) {
            return FS(l, u, !1, null, m, y, E, C, z);
        }),
        (t.createHasPseudoClassSelector = function (l) {
            return { $$typeof: Rd, value: l };
        }),
        (t.createHydrationContainer = function (l, u, m, y, E, C, z, Z, he) {
            return (
                (l = FS(m, y, !0, l, E, C, z, Z, he)),
                (l.context = kS(null)),
                (m = l.current),
                (y = _i()),
                (E = eo(m)),
                (C = gs(y, E)),
                (C.callback = u ?? null),
                Js(m, C),
                (l.current.lanes = E),
                Du(l, E, y),
                Ii(l, y),
                l
            );
        }),
        (t.createPortal = function (l, u, m) {
            var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
                $$typeof: f,
                key: y == null ? null : '' + y,
                children: l,
                containerInfo: u,
                implementation: m,
            };
        }),
        (t.createRoleSelector = function (l) {
            return { $$typeof: Pd, value: l };
        }),
        (t.createTestNameSelector = function (l) {
            return { $$typeof: Ld, value: l };
        }),
        (t.createTextSelector = function (l) {
            return { $$typeof: Id, value: l };
        }),
        (t.deferredUpdates = function (l) {
            var u = Ft,
                m = Tn.transition;
            try {
                return (Tn.transition = null), (Ft = 16), l();
            } finally {
                (Ft = u), (Tn.transition = m);
            }
        }),
        (t.discreteUpdates = function (l, u, m, y, E) {
            var C = Ft,
                z = Tn.transition;
            try {
                return (Tn.transition = null), (Ft = 1), l(u, m, y, E);
            } finally {
                (Ft = C), (Tn.transition = z), Pt === 0 && cl();
            }
        }),
        (t.findAllNodes = jg),
        (t.findBoundingRects = function (l, u) {
            if (!yt) throw Error(o(363));
            (u = jg(l, u)), (l = []);
            for (var m = 0; m < u.length; m++) l.push(I(u[m]));
            for (u = l.length - 1; 0 < u; u--) {
                m = l[u];
                for (
                    var y = m.x, E = y + m.width, C = m.y, z = C + m.height, Z = u - 1;
                    0 <= Z;
                    Z--
                )
                    if (u !== Z) {
                        var he = l[Z],
                            Le = he.x,
                            Ze = Le + he.width,
                            St = he.y,
                            lt = St + he.height;
                        if (y >= Le && C >= St && E <= Ze && z <= lt) {
                            l.splice(u, 1);
                            break;
                        } else if (y !== Le || m.width !== he.width || lt < C || St > z) {
                            if (!(C !== St || m.height !== he.height || Ze < y || Le > E)) {
                                Le > y && ((he.width += Le - y), (he.x = y)),
                                    Ze < E && (he.width = E - Le),
                                    l.splice(u, 1);
                                break;
                            }
                        } else {
                            St > C && ((he.height += St - C), (he.y = C)),
                                lt < z && (he.height = z - St),
                                l.splice(u, 1);
                            break;
                        }
                    }
            }
            return l;
        }),
        (t.findHostInstance = zS),
        (t.findHostInstanceWithNoPortals = function (l) {
            return (l = L(l)), (l = l !== null ? j(l) : null), l === null ? null : l.stateNode;
        }),
        (t.findHostInstanceWithWarning = function (l) {
            return zS(l);
        }),
        (t.flushControlled = function (l) {
            var u = Pt;
            Pt |= 1;
            var m = Tn.transition,
                y = Ft;
            try {
                (Tn.transition = null), (Ft = 1), l();
            } finally {
                (Ft = y), (Tn.transition = m), (Pt = u), Pt === 0 && (cl(), Qr());
            }
        }),
        (t.flushPassiveEffects = ea),
        (t.flushSync = bS),
        (t.focusWithin = function (l, u) {
            if (!yt) throw Error(o(363));
            for (l = Vg(l), u = TS(l, u), u = Array.from(u), l = 0; l < u.length; ) {
                var m = u[l++];
                if (!de(m)) {
                    if (m.tag === 5 && xe(m.stateNode)) return !0;
                    for (m = m.child; m !== null; ) u.push(m), (m = m.sibling);
                }
            }
            return !1;
        }),
        (t.getCurrentUpdatePriority = function () {
            return Ft;
        }),
        (t.getFindAllNodesFailureDescription = function (l, u) {
            if (!yt) throw Error(o(363));
            var m = 0,
                y = [];
            l = [Vg(l), 0];
            for (var E = 0; E < l.length; ) {
                var C = l[E++],
                    z = l[E++],
                    Z = u[z];
                if (
                    (C.tag !== 5 || !de(C)) &&
                    (Gg(C, Z) && (y.push(Wg(Z)), z++, z > m && (m = z)), z < u.length)
                )
                    for (C = C.child; C !== null; ) l.push(C, z), (C = C.sibling);
            }
            if (m < u.length) {
                for (l = []; m < u.length; m++) l.push(Wg(u[m]));
                return (
                    `findAllNodes was able to match part of the selector:
  ` +
                    (y.join(' > ') +
                        `

No matching component was found for:
  `) +
                    l.join(' > ')
                );
            }
            return null;
        }),
        (t.getPublicRootInstance = function (l) {
            if (((l = l.current), !l.child)) return null;
            switch (l.child.tag) {
                case 5:
                    return te(l.child.stateNode);
                default:
                    return l.child.stateNode;
            }
        }),
        (t.injectIntoDevTools = function (l) {
            if (
                ((l = {
                    bundleType: l.bundleType,
                    version: l.version,
                    rendererPackageName: l.rendererPackageName,
                    rendererConfig: l.rendererConfig,
                    overrideHookState: null,
                    overrideHookStateDeletePath: null,
                    overrideHookStateRenamePath: null,
                    overrideProps: null,
                    overridePropsDeletePath: null,
                    overridePropsRenamePath: null,
                    setErrorHandler: null,
                    setSuspenseHandler: null,
                    scheduleUpdate: null,
                    currentDispatcherRef: a.ReactCurrentDispatcher,
                    findHostInstanceByFiber: aP,
                    findFiberByHostInstance: l.findFiberByHostInstance || lP,
                    findHostInstancesForRefresh: null,
                    scheduleRefresh: null,
                    scheduleRoot: null,
                    setRefreshHandler: null,
                    getCurrentFiber: null,
                    reconcilerVersion: '18.0.0-fc46dba67-20220329',
                }),
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u')
            )
                l = !1;
            else {
                var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (u.isDisabled || !u.supportsFiber) l = !0;
                else {
                    try {
                        (td = u.inject(l)), (Kr = u);
                    } catch {}
                    l = !!u.checkDCE;
                }
            }
            return l;
        }),
        (t.isAlreadyRendering = function () {
            return !1;
        }),
        (t.observeVisibleRects = function (l, u, m, y) {
            if (!yt) throw Error(o(363));
            l = jg(l, u);
            var E = ut(l, m, y).disconnect;
            return {
                disconnect: function () {
                    E();
                },
            };
        }),
        (t.registerMutableSourceForHydration = function (l, u) {
            var m = u._getVersion;
            (m = m(u._source)),
                l.mutableSourceEagerHydrationData == null
                    ? (l.mutableSourceEagerHydrationData = [u, m])
                    : l.mutableSourceEagerHydrationData.push(u, m);
        }),
        (t.runWithPriority = function (l, u) {
            var m = Ft;
            try {
                return (Ft = l), u();
            } finally {
                Ft = m;
            }
        }),
        (t.shouldError = function () {
            return null;
        }),
        (t.shouldSuspend = function () {
            return !1;
        }),
        (t.updateContainer = function (l, u, m, y) {
            var E = u.current,
                C = _i(),
                z = eo(E);
            return (
                (m = kS(m)),
                u.context === null ? (u.context = m) : (u.pendingContext = m),
                (u = gs(C, z)),
                (u.payload = { element: l }),
                (y = y === void 0 ? null : y),
                y !== null && (u.callback = y),
                Js(E, u),
                (l = hr(E, z, C)),
                l !== null && od(l, E, z),
                z
            );
        }),
        t
    );
};
Wb.exports = iB;
var rB = Wb.exports;
const sB = Nf(rB);
var jb = { exports: {} },
    Xb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
    function e(N, B) {
        var H = N.length;
        N.push(B);
        e: for (; 0 < H; ) {
            var K = (H - 1) >>> 1,
                le = N[K];
            if (0 < r(le, B)) (N[K] = B), (N[H] = le), (H = K);
            else break e;
        }
    }
    function t(N) {
        return N.length === 0 ? null : N[0];
    }
    function i(N) {
        if (N.length === 0) return null;
        var B = N[0],
            H = N.pop();
        if (H !== B) {
            N[0] = H;
            e: for (var K = 0, le = N.length, be = le >>> 1; K < be; ) {
                var Q = 2 * (K + 1) - 1,
                    me = N[Q],
                    Se = Q + 1,
                    ke = N[Se];
                if (0 > r(me, H))
                    Se < le && 0 > r(ke, me)
                        ? ((N[K] = ke), (N[Se] = H), (K = Se))
                        : ((N[K] = me), (N[Q] = H), (K = Q));
                else if (Se < le && 0 > r(ke, H)) (N[K] = ke), (N[Se] = H), (K = Se);
                else break e;
            }
        }
        return B;
    }
    function r(N, B) {
        var H = N.sortIndex - B.sortIndex;
        return H !== 0 ? H : N.id - B.id;
    }
    if (typeof performance == 'object' && typeof performance.now == 'function') {
        var s = performance;
        n.unstable_now = function () {
            return s.now();
        };
    } else {
        var o = Date,
            a = o.now();
        n.unstable_now = function () {
            return o.now() - a;
        };
    }
    var c = [],
        f = [],
        d = 1,
        h = null,
        p = 3,
        v = !1,
        _ = !1,
        w = !1,
        x = typeof setTimeout == 'function' ? setTimeout : null,
        g = typeof clearTimeout == 'function' ? clearTimeout : null,
        S = typeof setImmediate < 'u' ? setImmediate : null;
    typeof navigator < 'u' &&
        navigator.scheduling !== void 0 &&
        navigator.scheduling.isInputPending !== void 0 &&
        navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(N) {
        for (var B = t(f); B !== null; ) {
            if (B.callback === null) i(f);
            else if (B.startTime <= N) i(f), (B.sortIndex = B.expirationTime), e(c, B);
            else break;
            B = t(f);
        }
    }
    function T(N) {
        if (((w = !1), M(N), !_))
            if (t(c) !== null) (_ = !0), te(P);
            else {
                var B = t(f);
                B !== null && ae(T, B.startTime - N);
            }
    }
    function P(N, B) {
        (_ = !1), w && ((w = !1), g(D), (D = -1)), (v = !0);
        var H = p;
        try {
            for (M(B), h = t(c); h !== null && (!(h.expirationTime > B) || (N && !L())); ) {
                var K = h.callback;
                if (typeof K == 'function') {
                    (h.callback = null), (p = h.priorityLevel);
                    var le = K(h.expirationTime <= B);
                    (B = n.unstable_now()),
                        typeof le == 'function' ? (h.callback = le) : h === t(c) && i(c),
                        M(B);
                } else i(c);
                h = t(c);
            }
            if (h !== null) var be = !0;
            else {
                var Q = t(f);
                Q !== null && ae(T, Q.startTime - B), (be = !1);
            }
            return be;
        } finally {
            (h = null), (p = H), (v = !1);
        }
    }
    var A = !1,
        R = null,
        D = -1,
        G = 5,
        b = -1;
    function L() {
        return !(n.unstable_now() - b < G);
    }
    function ee() {
        if (R !== null) {
            var N = n.unstable_now();
            b = N;
            var B = !0;
            try {
                B = R(!0, N);
            } finally {
                B ? ie() : ((A = !1), (R = null));
            }
        } else A = !1;
    }
    var ie;
    if (typeof S == 'function')
        ie = function () {
            S(ee);
        };
    else if (typeof MessageChannel < 'u') {
        var j = new MessageChannel(),
            oe = j.port2;
        (j.port1.onmessage = ee),
            (ie = function () {
                oe.postMessage(null);
            });
    } else
        ie = function () {
            x(ee, 0);
        };
    function te(N) {
        (R = N), A || ((A = !0), ie());
    }
    function ae(N, B) {
        D = x(function () {
            N(n.unstable_now());
        }, B);
    }
    (n.unstable_IdlePriority = 5),
        (n.unstable_ImmediatePriority = 1),
        (n.unstable_LowPriority = 4),
        (n.unstable_NormalPriority = 3),
        (n.unstable_Profiling = null),
        (n.unstable_UserBlockingPriority = 2),
        (n.unstable_cancelCallback = function (N) {
            N.callback = null;
        }),
        (n.unstable_continueExecution = function () {
            _ || v || ((_ = !0), te(P));
        }),
        (n.unstable_forceFrameRate = function (N) {
            0 > N || 125 < N
                ? console.error(
                      'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                  )
                : (G = 0 < N ? Math.floor(1e3 / N) : 5);
        }),
        (n.unstable_getCurrentPriorityLevel = function () {
            return p;
        }),
        (n.unstable_getFirstCallbackNode = function () {
            return t(c);
        }),
        (n.unstable_next = function (N) {
            switch (p) {
                case 1:
                case 2:
                case 3:
                    var B = 3;
                    break;
                default:
                    B = p;
            }
            var H = p;
            p = B;
            try {
                return N();
            } finally {
                p = H;
            }
        }),
        (n.unstable_pauseExecution = function () {}),
        (n.unstable_requestPaint = function () {}),
        (n.unstable_runWithPriority = function (N, B) {
            switch (N) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    N = 3;
            }
            var H = p;
            p = N;
            try {
                return B();
            } finally {
                p = H;
            }
        }),
        (n.unstable_scheduleCallback = function (N, B, H) {
            var K = n.unstable_now();
            switch (
                (typeof H == 'object' && H !== null
                    ? ((H = H.delay), (H = typeof H == 'number' && 0 < H ? K + H : K))
                    : (H = K),
                N)
            ) {
                case 1:
                    var le = -1;
                    break;
                case 2:
                    le = 250;
                    break;
                case 5:
                    le = 1073741823;
                    break;
                case 4:
                    le = 1e4;
                    break;
                default:
                    le = 5e3;
            }
            return (
                (le = H + le),
                (N = {
                    id: d++,
                    callback: B,
                    priorityLevel: N,
                    startTime: H,
                    expirationTime: le,
                    sortIndex: -1,
                }),
                H > K
                    ? ((N.sortIndex = H),
                      e(f, N),
                      t(c) === null &&
                          N === t(f) &&
                          (w ? (g(D), (D = -1)) : (w = !0), ae(T, H - K)))
                    : ((N.sortIndex = le), e(c, N), _ || v || ((_ = !0), te(P))),
                N
            );
        }),
        (n.unstable_shouldYield = L),
        (n.unstable_wrapCallback = function (N) {
            var B = p;
            return function () {
                var H = p;
                p = B;
                try {
                    return N.apply(this, arguments);
                } finally {
                    p = H;
                }
            };
        });
})(Xb);
jb.exports = Xb;
var NE = jb.exports;
const s1 = {},
    oB = (n) => void Object.assign(s1, n);
function aB(n, e) {
    function t(d, { args: h = [], attach: p, ...v }, _) {
        let w = `${d[0].toUpperCase()}${d.slice(1)}`,
            x;
        if (d === 'primitive') {
            if (v.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const g = v.object;
            x = Ol(g, { type: d, root: _, attach: p, primitive: !0 });
        } else {
            const g = s1[w];
            if (!g)
                throw new Error(
                    `R3F: ${w} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
                );
            if (!Array.isArray(h)) throw new Error('R3F: The args prop must be an array!');
            x = Ol(new g(...h), { type: d, root: _, attach: p, memoizedProps: { args: h } });
        }
        return (
            x.__r3f.attach === void 0 &&
                (x instanceof bt
                    ? (x.__r3f.attach = 'geometry')
                    : x instanceof ii && (x.__r3f.attach = 'material')),
            w !== 'inject' && w0(x, v),
            x
        );
    }
    function i(d, h) {
        let p = !1;
        if (h) {
            var v, _;
            (v = h.__r3f) != null && v.attach
                ? M0(d, h, h.__r3f.attach)
                : h.isObject3D && d.isObject3D && (d.add(h), (p = !0)),
                p || (_ = d.__r3f) == null || _.objects.push(h),
                h.__r3f || Ol(h, {}),
                (h.__r3f.parent = d),
                my(h),
                Fl(h);
        }
    }
    function r(d, h, p) {
        let v = !1;
        if (h) {
            var _, w;
            if ((_ = h.__r3f) != null && _.attach) M0(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                (h.parent = d), h.dispatchEvent({ type: 'added' });
                const x = d.children.filter((S) => S !== h),
                    g = x.indexOf(p);
                (d.children = [...x.slice(0, g), h, ...x.slice(g)]), (v = !0);
            }
            v || (w = d.__r3f) == null || w.objects.push(h),
                h.__r3f || Ol(h, {}),
                (h.__r3f.parent = d),
                my(h),
                Fl(h);
        }
    }
    function s(d, h, p = !1) {
        d && [...d].forEach((v) => o(h, v, p));
    }
    function o(d, h, p) {
        if (h) {
            var v, _, w;
            if (
                (h.__r3f && (h.__r3f.parent = null),
                (v = d.__r3f) != null &&
                    v.objects &&
                    (d.__r3f.objects = d.__r3f.objects.filter((T) => T !== h)),
                (_ = h.__r3f) != null && _.attach)
            )
                kE(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                var x;
                d.remove(h), (x = h.__r3f) != null && x.root && gB(Ep(h), h);
            }
            const S = (w = h.__r3f) == null ? void 0 : w.primitive,
                M = !S && (p === void 0 ? h.dispose !== null : p);
            if (!S) {
                var g;
                s((g = h.__r3f) == null ? void 0 : g.objects, h, M), s(h.children, h, M);
            }
            if ((delete h.__r3f, M && h.dispose && h.type !== 'Scene')) {
                const T = () => {
                    try {
                        h.dispose();
                    } catch {}
                };
                typeof IS_REACT_ACT_ENVIRONMENT > 'u'
                    ? NE.unstable_scheduleCallback(NE.unstable_IdlePriority, T)
                    : T();
            }
            Fl(d);
        }
    }
    function a(d, h, p, v) {
        var _;
        const w = (_ = d.__r3f) == null ? void 0 : _.parent;
        if (!w) return;
        const x = t(h, p, d.__r3f.root);
        if (d.children) {
            for (const g of d.children) g.__r3f && i(x, g);
            d.children = d.children.filter((g) => !g.__r3f);
        }
        d.__r3f.objects.forEach((g) => i(x, g)),
            (d.__r3f.objects = []),
            d.__r3f.autoRemovedBeforeAppend || o(w, d),
            x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
            i(w, x),
            x.raycast && x.__r3f.eventCount && Ep(x).getState().internal.interaction.push(x),
            [v, v.alternate].forEach((g) => {
                g !== null &&
                    ((g.stateNode = x),
                    g.ref && (typeof g.ref == 'function' ? g.ref(x) : (g.ref.current = x)));
            });
    }
    const c = () =>
        console.warn(
            'Text is not allowed in the R3F tree! This could be stray whitespace or characters.'
        );
    return {
        reconciler: sB({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (d, h) => {
                if (!h) return;
                const p = d.getState().scene;
                p.__r3f && ((p.__r3f.root = d), i(p, h));
            },
            removeChildFromContainer: (d, h) => {
                h && o(d.getState().scene, h);
            },
            insertInContainerBefore: (d, h, p) => {
                if (!h || !p) return;
                const v = d.getState().scene;
                v.__r3f && r(v, h, p);
            },
            getRootHostContext: () => null,
            getChildHostContext: (d) => d,
            finalizeInitialChildren(d) {
                var h;
                return !!((h = d == null ? void 0 : d.__r3f) != null ? h : {}).handlers;
            },
            prepareUpdate(d, h, p, v) {
                var _;
                if (
                    ((_ = d == null ? void 0 : d.__r3f) != null ? _ : {}).primitive &&
                    v.object &&
                    v.object !== d
                )
                    return [!0];
                {
                    const { args: x = [], children: g, ...S } = v,
                        { args: M = [], children: T, ...P } = p;
                    if (!Array.isArray(x)) throw new Error('R3F: the args prop must be an array!');
                    if (x.some((R, D) => R !== M[D])) return [!0];
                    const A = Qb(d, S, P, !0);
                    return A.changes.length ? [!1, A] : null;
                }
            },
            commitUpdate(d, [h, p], v, _, w, x) {
                h ? a(d, v, w, x) : w0(d, p);
            },
            commitMount(d, h, p, v) {
                var _;
                const w = (_ = d.__r3f) != null ? _ : {};
                d.raycast &&
                    w.handlers &&
                    w.eventCount &&
                    Ep(d).getState().internal.interaction.push(d);
            },
            getPublicInstance: (d) => d,
            prepareForCommit: () => null,
            preparePortalMount: (d) => Ol(d.getState().scene),
            resetAfterCommit: () => {},
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(d) {
                var h;
                const { attach: p, parent: v } = (h = d.__r3f) != null ? h : {};
                p && v && kE(v, d, p), d.isObject3D && (d.visible = !1), Fl(d);
            },
            unhideInstance(d, h) {
                var p;
                const { attach: v, parent: _ } = (p = d.__r3f) != null ? p : {};
                v && _ && M0(_, d, v),
                    ((d.isObject3D && h.visible == null) || h.visible) && (d.visible = !0),
                    Fl(d);
            },
            createTextInstance: c,
            hideTextInstance: c,
            unhideTextInstance: c,
            getCurrentEventPriority: () => (e ? e() : tu.DefaultEventPriority),
            beforeActiveInstanceBlur: () => {},
            afterActiveInstanceBlur: () => {},
            detachDeletedInstance: () => {},
            now:
                typeof performance < 'u' && on.fun(performance.now)
                    ? performance.now
                    : on.fun(Date.now)
                    ? Date.now
                    : () => 0,
            scheduleTimeout: on.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: on.fun(clearTimeout) ? clearTimeout : void 0,
        }),
        applyProps: w0,
    };
}
var DE, UE;
const S0 = (n) => 'colorSpace' in n || 'outputColorSpace' in n,
    Yb = () => {
        var n;
        return (n = s1.ColorManagement) != null ? n : null;
    },
    qb = (n) => n && n.isOrthographicCamera,
    lB = (n) => n && n.hasOwnProperty('current'),
    $m =
        typeof window < 'u' &&
        (((DE = window.document) != null && DE.createElement) ||
            ((UE = window.navigator) == null ? void 0 : UE.product) === 'ReactNative')
            ? pe.useLayoutEffect
            : pe.useEffect;
function uB(n) {
    const e = pe.useRef(n);
    return $m(() => void (e.current = n), [n]), e;
}
function cB({ set: n }) {
    return $m(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class Zb extends pe.Component {
    constructor(...e) {
        super(...e), (this.state = { error: !1 });
    }
    componentDidCatch(e) {
        this.props.set(e);
    }
    render() {
        return this.state.error ? null : this.props.children;
    }
}
Zb.getDerivedStateFromError = () => ({ error: !0 });
const Kb = '__default',
    OE = new Map(),
    fB = (n) => n && !!n.memoized && !!n.changes;
function Jb(n) {
    var e;
    const t = typeof window < 'u' ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const yc = (n) => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function Ep(n) {
    let e = n.__r3f.root;
    for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
    return e;
}
const on = {
    obj: (n) => n === Object(n) && !on.arr(n) && typeof n != 'function',
    fun: (n) => typeof n == 'function',
    str: (n) => typeof n == 'string',
    num: (n) => typeof n == 'number',
    boo: (n) => typeof n == 'boolean',
    und: (n) => n === void 0,
    arr: (n) => Array.isArray(n),
    equ(n, e, { arrays: t = 'shallow', objects: i = 'reference', strict: r = !0 } = {}) {
        if (typeof n != typeof e || !!n != !!e) return !1;
        if (on.str(n) || on.num(n)) return n === e;
        const s = on.obj(n);
        if (s && i === 'reference') return n === e;
        const o = on.arr(n);
        if (o && t === 'reference') return n === e;
        if ((o || s) && n === e) return !0;
        let a;
        for (a in n) if (!(a in e)) return !1;
        if (s && t === 'shallow' && i === 'shallow') {
            for (a in r ? e : n)
                if (!on.equ(n[a], e[a], { strict: r, objects: 'reference' })) return !1;
        } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
        if (on.und(a)) {
            if (
                (o && n.length === 0 && e.length === 0) ||
                (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
            )
                return !0;
            if (n !== e) return !1;
        }
        return !0;
    },
};
function dB(n) {
    n.dispose && n.type !== 'Scene' && n.dispose();
    for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Ol(n, e) {
    const t = n;
    return (
        (t.__r3f = {
            type: '',
            root: null,
            previousAttach: null,
            memoizedProps: {},
            eventCount: 0,
            handlers: {},
            objects: [],
            parent: null,
            ...e,
        }),
        n
    );
}
function py(n, e) {
    let t = n;
    if (e.includes('-')) {
        const i = e.split('-'),
            r = i.pop();
        return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r };
    } else return { target: t, key: e };
}
const FE = /-\d+$/;
function M0(n, e, t) {
    if (on.str(t)) {
        if (FE.test(t)) {
            const s = t.replace(FE, ''),
                { target: o, key: a } = py(n, s);
            Array.isArray(o[a]) || (o[a] = []);
        }
        const { target: i, key: r } = py(n, t);
        (e.__r3f.previousAttach = i[r]), (i[r] = e);
    } else e.__r3f.previousAttach = t(n, e);
}
function kE(n, e, t) {
    var i, r;
    if (on.str(t)) {
        const { target: s, key: o } = py(n, t),
            a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : (s[o] = a);
    } else (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach;
}
function Qb(
    n,
    { children: e, key: t, ref: i, ...r },
    { children: s, key: o, ref: a, ...c } = {},
    f = !1
) {
    var d;
    const h = (d = n == null ? void 0 : n.__r3f) != null ? d : {},
        p = Object.entries(r),
        v = [];
    if (f) {
        const w = Object.keys(c);
        for (let x = 0; x < w.length; x++)
            r.hasOwnProperty(w[x]) || p.unshift([w[x], Kb + 'remove']);
    }
    p.forEach(([w, x]) => {
        var g;
        if (((g = n.__r3f) != null && g.primitive && w === 'object') || on.equ(x, c[w])) return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(w))
            return v.push([w, x, !0, []]);
        let S = [];
        w.includes('-') && (S = w.split('-')), v.push([w, x, !1, S]);
        for (const M in r) {
            const T = r[M];
            M.startsWith(`${w}-`) && v.push([M, T, !1, M.split('-')]);
        }
    });
    const _ = { ...r };
    return (
        h.memoizedProps && h.memoizedProps.args && (_.args = h.memoizedProps.args),
        h.memoizedProps && h.memoizedProps.attach && (_.attach = h.memoizedProps.attach),
        { memoized: _, changes: v }
    );
}
const hB = typeof process < 'u' && !1;
function w0(n, e) {
    var t, i, r;
    const s = (t = n.__r3f) != null ? t : {},
        o = s.root,
        a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {},
        { memoized: c, changes: f } = fB(e) ? e : Qb(n, e),
        d = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = c);
    for (let p = 0; p < f.length; p++) {
        let [v, _, w, x] = f[p];
        if (S0(n)) {
            const T = 'srgb',
                P = 'srgb-linear';
            v === 'encoding'
                ? ((v = 'colorSpace'), (_ = _ === 3001 ? T : P))
                : v === 'outputEncoding' && ((v = 'outputColorSpace'), (_ = _ === 3001 ? T : P));
        }
        let g = n,
            S = g[v];
        if (x.length && ((S = x.reduce((M, T) => M[T], n)), !(S && S.set))) {
            const [M, ...T] = x.reverse();
            (g = T.reverse().reduce((P, A) => P[A], n)), (v = M);
        }
        if (_ === Kb + 'remove')
            if (g.constructor) {
                let M = OE.get(g.constructor);
                M || ((M = new g.constructor()), OE.set(g.constructor, M)), (_ = M[v]);
            } else _ = 0;
        if (w)
            _ ? (s.handlers[v] = _) : delete s.handlers[v],
                (s.eventCount = Object.keys(s.handlers).length);
        else if (S && S.set && (S.copy || S instanceof Da)) {
            if (Array.isArray(_)) S.fromArray ? S.fromArray(_) : S.set(..._);
            else if (
                S.copy &&
                _ &&
                _.constructor &&
                (hB ? S.constructor.name === _.constructor.name : S.constructor === _.constructor)
            )
                S.copy(_);
            else if (_ !== void 0) {
                const M = S instanceof je;
                !M && S.setScalar
                    ? S.setScalar(_)
                    : S instanceof Da && _ instanceof Da
                    ? (S.mask = _.mask)
                    : S.set(_),
                    !Yb() && !a.linear && M && S.convertSRGBToLinear();
            }
        } else if (((g[v] = _), g[v] instanceof mn && g[v].format === wi && g[v].type === ds)) {
            const M = g[v];
            S0(M) && S0(a.gl)
                ? (M.colorSpace = a.gl.outputColorSpace)
                : (M.encoding = a.gl.outputEncoding);
        }
        Fl(n);
    }
    if (s.parent && n.raycast && d !== s.eventCount) {
        const p = Ep(n).getState().internal,
            v = p.interaction.indexOf(n);
        v > -1 && p.interaction.splice(v, 1), s.eventCount && p.interaction.push(n);
    }
    return (
        !(f.length === 1 && f[0][0] === 'onUpdate') &&
            f.length &&
            (r = n.__r3f) != null &&
            r.parent &&
            my(n),
        n
    );
}
function Fl(n) {
    var e, t;
    const i =
        (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate();
}
function my(n) {
    n.onUpdate == null || n.onUpdate(n);
}
function pB(n, e) {
    n.manual ||
        (qb(n)
            ? ((n.left = e.width / -2),
              (n.right = e.width / 2),
              (n.top = e.height / 2),
              (n.bottom = e.height / -2))
            : (n.aspect = e.width / e.height),
        n.updateProjectionMatrix(),
        n.updateMatrixWorld());
}
function ip(n) {
    return (n.eventObject || n.object).uuid + '/' + n.index + n.instanceId;
}
function mB() {
    var n;
    const e = (typeof self < 'u' && self) || (typeof window < 'u' && window);
    if (!e) return tu.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
        case 'click':
        case 'contextmenu':
        case 'dblclick':
        case 'pointercancel':
        case 'pointerdown':
        case 'pointerup':
            return tu.DiscreteEventPriority;
        case 'pointermove':
        case 'pointerout':
        case 'pointerover':
        case 'pointerenter':
        case 'pointerleave':
        case 'wheel':
            return tu.ContinuousEventPriority;
        default:
            return tu.DefaultEventPriority;
    }
}
function $b(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e), t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function gB(n, e) {
    const { internal: t } = n.getState();
    (t.interaction = t.interaction.filter((i) => i !== e)),
        (t.initialHits = t.initialHits.filter((i) => i !== e)),
        t.hovered.forEach((i, r) => {
            (i.eventObject === e || i.object === e) && t.hovered.delete(r);
        }),
        t.capturedMap.forEach((i, r) => {
            $b(t.capturedMap, e, i, r);
        });
}
function vB(n) {
    function e(c) {
        const { internal: f } = n.getState(),
            d = c.offsetX - f.initialClick[0],
            h = c.offsetY - f.initialClick[1];
        return Math.round(Math.sqrt(d * d + h * h));
    }
    function t(c) {
        return c.filter((f) =>
            ['Move', 'Over', 'Enter', 'Out', 'Leave'].some((d) => {
                var h;
                return (h = f.__r3f) == null ? void 0 : h.handlers['onPointer' + d];
            })
        );
    }
    function i(c, f) {
        const d = n.getState(),
            h = new Set(),
            p = [],
            v = f ? f(d.internal.interaction) : d.internal.interaction;
        for (let g = 0; g < v.length; g++) {
            const S = yc(v[g]);
            S && (S.raycaster.camera = void 0);
        }
        d.previousRoot || d.events.compute == null || d.events.compute(c, d);
        function _(g) {
            const S = yc(g);
            if (!S || !S.events.enabled || S.raycaster.camera === null) return [];
            if (S.raycaster.camera === void 0) {
                var M;
                S.events.compute == null ||
                    S.events.compute(c, S, (M = S.previousRoot) == null ? void 0 : M.getState()),
                    S.raycaster.camera === void 0 && (S.raycaster.camera = null);
            }
            return S.raycaster.camera ? S.raycaster.intersectObject(g, !0) : [];
        }
        let w = v
            .flatMap(_)
            .sort((g, S) => {
                const M = yc(g.object),
                    T = yc(S.object);
                return !M || !T
                    ? g.distance - S.distance
                    : T.events.priority - M.events.priority || g.distance - S.distance;
            })
            .filter((g) => {
                const S = ip(g);
                return h.has(S) ? !1 : (h.add(S), !0);
            });
        d.events.filter && (w = d.events.filter(w, d));
        for (const g of w) {
            let S = g.object;
            for (; S; ) {
                var x;
                (x = S.__r3f) != null && x.eventCount && p.push({ ...g, eventObject: S }),
                    (S = S.parent);
            }
        }
        if ('pointerId' in c && d.internal.capturedMap.has(c.pointerId))
            for (let g of d.internal.capturedMap.get(c.pointerId).values())
                h.has(ip(g.intersection)) || p.push(g.intersection);
        return p;
    }
    function r(c, f, d, h) {
        const p = n.getState();
        if (c.length) {
            const v = { stopped: !1 };
            for (const _ of c) {
                const w = yc(_.object) || p,
                    { raycaster: x, pointer: g, camera: S, internal: M } = w,
                    T = new k(g.x, g.y, 0).unproject(S),
                    P = (b) => {
                        var L, ee;
                        return (L =
                            (ee = M.capturedMap.get(b)) == null ? void 0 : ee.has(_.eventObject)) !=
                            null
                            ? L
                            : !1;
                    },
                    A = (b) => {
                        const L = { intersection: _, target: f.target };
                        M.capturedMap.has(b)
                            ? M.capturedMap.get(b).set(_.eventObject, L)
                            : M.capturedMap.set(b, new Map([[_.eventObject, L]])),
                            f.target.setPointerCapture(b);
                    },
                    R = (b) => {
                        const L = M.capturedMap.get(b);
                        L && $b(M.capturedMap, _.eventObject, L, b);
                    };
                let D = {};
                for (let b in f) {
                    let L = f[b];
                    typeof L != 'function' && (D[b] = L);
                }
                let G = {
                    ..._,
                    ...D,
                    pointer: g,
                    intersections: c,
                    stopped: v.stopped,
                    delta: d,
                    unprojectedPoint: T,
                    ray: x.ray,
                    camera: S,
                    stopPropagation() {
                        const b = 'pointerId' in f && M.capturedMap.get(f.pointerId);
                        if (
                            (!b || b.has(_.eventObject)) &&
                            ((G.stopped = v.stopped = !0),
                            M.hovered.size &&
                                Array.from(M.hovered.values()).find(
                                    (L) => L.eventObject === _.eventObject
                                ))
                        ) {
                            const L = c.slice(0, c.indexOf(_));
                            s([...L, _]);
                        }
                    },
                    target: {
                        hasPointerCapture: P,
                        setPointerCapture: A,
                        releasePointerCapture: R,
                    },
                    currentTarget: {
                        hasPointerCapture: P,
                        setPointerCapture: A,
                        releasePointerCapture: R,
                    },
                    nativeEvent: f,
                };
                if ((h(G), v.stopped === !0)) break;
            }
        }
        return c;
    }
    function s(c) {
        const { internal: f } = n.getState();
        for (const d of f.hovered.values())
            if (
                !c.length ||
                !c.find(
                    (h) =>
                        h.object === d.object &&
                        h.index === d.index &&
                        h.instanceId === d.instanceId
                )
            ) {
                const p = d.eventObject.__r3f,
                    v = p == null ? void 0 : p.handlers;
                if ((f.hovered.delete(ip(d)), p != null && p.eventCount)) {
                    const _ = { ...d, intersections: c };
                    v.onPointerOut == null || v.onPointerOut(_),
                        v.onPointerLeave == null || v.onPointerLeave(_);
                }
            }
    }
    function o(c, f) {
        for (let d = 0; d < f.length; d++) {
            const h = f[d].__r3f;
            h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(c);
        }
    }
    function a(c) {
        switch (c) {
            case 'onPointerLeave':
            case 'onPointerCancel':
                return () => s([]);
            case 'onLostPointerCapture':
                return (f) => {
                    const { internal: d } = n.getState();
                    'pointerId' in f &&
                        d.capturedMap.has(f.pointerId) &&
                        requestAnimationFrame(() => {
                            d.capturedMap.has(f.pointerId) &&
                                (d.capturedMap.delete(f.pointerId), s([]));
                        });
                };
        }
        return function (d) {
            const { onPointerMissed: h, internal: p } = n.getState();
            p.lastEvent.current = d;
            const v = c === 'onPointerMove',
                _ = c === 'onClick' || c === 'onContextMenu' || c === 'onDoubleClick',
                x = i(d, v ? t : void 0),
                g = _ ? e(d) : 0;
            c === 'onPointerDown' &&
                ((p.initialClick = [d.offsetX, d.offsetY]),
                (p.initialHits = x.map((M) => M.eventObject))),
                _ && !x.length && g <= 2 && (o(d, p.interaction), h && h(d)),
                v && s(x);
            function S(M) {
                const T = M.eventObject,
                    P = T.__r3f,
                    A = P == null ? void 0 : P.handlers;
                if (P != null && P.eventCount)
                    if (v) {
                        if (
                            A.onPointerOver ||
                            A.onPointerEnter ||
                            A.onPointerOut ||
                            A.onPointerLeave
                        ) {
                            const R = ip(M),
                                D = p.hovered.get(R);
                            D
                                ? D.stopped && M.stopPropagation()
                                : (p.hovered.set(R, M),
                                  A.onPointerOver == null || A.onPointerOver(M),
                                  A.onPointerEnter == null || A.onPointerEnter(M));
                        }
                        A.onPointerMove == null || A.onPointerMove(M);
                    } else {
                        const R = A[c];
                        R
                            ? (!_ || p.initialHits.includes(T)) &&
                              (o(
                                  d,
                                  p.interaction.filter((D) => !p.initialHits.includes(D))
                              ),
                              R(M))
                            : _ &&
                              p.initialHits.includes(T) &&
                              o(
                                  d,
                                  p.interaction.filter((D) => !p.initialHits.includes(D))
                              );
                    }
            }
            r(x, d, g, S);
        };
    }
    return { handlePointer: a };
}
const eR = (n) => !!(n != null && n.render),
    _B = pe.createContext(null),
    yB = (n, e) => {
        const t = eB((a, c) => {
                const f = new k(),
                    d = new k(),
                    h = new k();
                function p(g = c().camera, S = d, M = c().size) {
                    const { width: T, height: P, top: A, left: R } = M,
                        D = T / P;
                    S instanceof k ? h.copy(S) : h.set(...S);
                    const G = g.getWorldPosition(f).distanceTo(h);
                    if (qb(g))
                        return {
                            width: T / g.zoom,
                            height: P / g.zoom,
                            top: A,
                            left: R,
                            factor: 1,
                            distance: G,
                            aspect: D,
                        };
                    {
                        const b = (g.fov * Math.PI) / 180,
                            L = 2 * Math.tan(b / 2) * G,
                            ee = L * (T / P);
                        return {
                            width: ee,
                            height: L,
                            top: A,
                            left: R,
                            factor: T / ee,
                            distance: G,
                            aspect: D,
                        };
                    }
                }
                let v;
                const _ = (g) => a((S) => ({ performance: { ...S.performance, current: g } })),
                    w = new _e();
                return {
                    set: a,
                    get: c,
                    gl: null,
                    camera: null,
                    raycaster: null,
                    events: { priority: 1, enabled: !0, connected: !1 },
                    xr: null,
                    scene: null,
                    invalidate: (g = 1) => n(c(), g),
                    advance: (g, S) => e(g, S, c()),
                    legacy: !1,
                    linear: !1,
                    flat: !1,
                    controls: null,
                    clock: new t1(),
                    pointer: w,
                    mouse: w,
                    frameloop: 'always',
                    onPointerMissed: void 0,
                    performance: {
                        current: 1,
                        min: 0.5,
                        max: 1,
                        debounce: 200,
                        regress: () => {
                            const g = c();
                            v && clearTimeout(v),
                                g.performance.current !== g.performance.min && _(g.performance.min),
                                (v = setTimeout(
                                    () => _(c().performance.max),
                                    g.performance.debounce
                                ));
                        },
                    },
                    size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
                    viewport: {
                        initialDpr: 0,
                        dpr: 0,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: p,
                    },
                    setEvents: (g) => a((S) => ({ ...S, events: { ...S.events, ...g } })),
                    setSize: (g, S, M, T, P) => {
                        const A = c().camera,
                            R = { width: g, height: S, top: T || 0, left: P || 0, updateStyle: M };
                        a((D) => ({ size: R, viewport: { ...D.viewport, ...p(A, d, R) } }));
                    },
                    setDpr: (g) =>
                        a((S) => {
                            const M = Jb(g);
                            return {
                                viewport: {
                                    ...S.viewport,
                                    dpr: M,
                                    initialDpr: S.viewport.initialDpr || M,
                                },
                            };
                        }),
                    setFrameloop: (g = 'always') => {
                        const S = c().clock;
                        S.stop(),
                            (S.elapsedTime = 0),
                            g !== 'never' && (S.start(), (S.elapsedTime = 0)),
                            a(() => ({ frameloop: g }));
                    },
                    previousRoot: void 0,
                    internal: {
                        active: !1,
                        priority: 0,
                        frames: 0,
                        lastEvent: pe.createRef(),
                        interaction: [],
                        hovered: new Map(),
                        subscribers: [],
                        initialClick: [0, 0],
                        initialHits: [],
                        capturedMap: new Map(),
                        subscribe: (g, S, M) => {
                            const T = c().internal;
                            return (
                                (T.priority = T.priority + (S > 0 ? 1 : 0)),
                                T.subscribers.push({ ref: g, priority: S, store: M }),
                                (T.subscribers = T.subscribers.sort(
                                    (P, A) => P.priority - A.priority
                                )),
                                () => {
                                    const P = c().internal;
                                    P != null &&
                                        P.subscribers &&
                                        ((P.priority = P.priority - (S > 0 ? 1 : 0)),
                                        (P.subscribers = P.subscribers.filter((A) => A.ref !== g)));
                                }
                            );
                        },
                    },
                };
            }),
            i = t.getState();
        let r = i.size,
            s = i.viewport.dpr,
            o = i.camera;
        return (
            t.subscribe(() => {
                const { camera: a, size: c, viewport: f, gl: d, set: h } = t.getState();
                if (c.width !== r.width || c.height !== r.height || f.dpr !== s) {
                    var p;
                    (r = c), (s = f.dpr), pB(a, c), d.setPixelRatio(f.dpr);
                    const v =
                        (p = c.updateStyle) != null
                            ? p
                            : typeof HTMLCanvasElement < 'u' &&
                              d.domElement instanceof HTMLCanvasElement;
                    d.setSize(c.width, c.height, v);
                }
                a !== o &&
                    ((o = a),
                    h((v) => ({
                        viewport: { ...v.viewport, ...v.viewport.getCurrentViewport(a) },
                    })));
            }),
            t.subscribe((a) => n(a)),
            t
        );
    };
let rp,
    xB = new Set(),
    SB = new Set(),
    MB = new Set();
function E0(n, e) {
    if (n.size) for (const { callback: t } of n.values()) t(e);
}
function xc(n, e) {
    switch (n) {
        case 'before':
            return E0(xB, e);
        case 'after':
            return E0(SB, e);
        case 'tail':
            return E0(MB, e);
    }
}
let T0, A0;
function C0(n, e, t) {
    let i = e.clock.getDelta();
    for (
        e.frameloop === 'never' &&
            typeof n == 'number' &&
            ((i = n - e.clock.elapsedTime),
            (e.clock.oldTime = e.clock.elapsedTime),
            (e.clock.elapsedTime = n)),
            T0 = e.internal.subscribers,
            rp = 0;
        rp < T0.length;
        rp++
    )
        (A0 = T0[rp]), A0.ref.current(A0.store.getState(), i, t);
    return (
        !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
        (e.internal.frames = Math.max(0, e.internal.frames - 1)),
        e.frameloop === 'always' ? 1 : e.internal.frames
    );
}
function wB(n) {
    let e = !1,
        t,
        i,
        r;
    function s(c) {
        (i = requestAnimationFrame(s)), (e = !0), (t = 0), xc('before', c);
        for (const d of n.values()) {
            var f;
            (r = d.store.getState()),
                r.internal.active &&
                    (r.frameloop === 'always' || r.internal.frames > 0) &&
                    !((f = r.gl.xr) != null && f.isPresenting) &&
                    (t += C0(c, r));
        }
        if ((xc('after', c), t === 0)) return xc('tail', c), (e = !1), cancelAnimationFrame(i);
    }
    function o(c, f = 1) {
        var d;
        if (!c) return n.forEach((h) => o(h.store.getState(), f));
        ((d = c.gl.xr) != null && d.isPresenting) ||
            !c.internal.active ||
            c.frameloop === 'never' ||
            ((c.internal.frames = Math.min(60, c.internal.frames + f)),
            e || ((e = !0), requestAnimationFrame(s)));
    }
    function a(c, f = !0, d, h) {
        if ((f && xc('before', c), d)) C0(c, d, h);
        else for (const p of n.values()) C0(c, p.store.getState());
        f && xc('after', c);
    }
    return { loop: s, invalidate: o, advance: a };
}
const Mu = new Map(),
    { invalidate: zE, advance: BE } = wB(Mu),
    { reconciler: rm, applyProps: Dl } = aB(Mu, mB),
    Ul = { objects: 'shallow', strict: !1 },
    EB = (n, e) => {
        const t = typeof n == 'function' ? n(e) : n;
        return eR(t)
            ? t
            : new kx({
                  powerPreference: 'high-performance',
                  canvas: e,
                  antialias: !0,
                  alpha: !0,
                  ...n,
              });
    };
function TB(n, e) {
    const t = typeof HTMLCanvasElement < 'u' && n instanceof HTMLCanvasElement;
    if (e) {
        const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e;
        return { width: i, height: r, top: s, left: o, updateStyle: a };
    } else if (
        typeof HTMLCanvasElement < 'u' &&
        n instanceof HTMLCanvasElement &&
        n.parentElement
    ) {
        const { width: i, height: r, top: s, left: o } = n.parentElement.getBoundingClientRect();
        return { width: i, height: r, top: s, left: o, updateStyle: t };
    } else if (typeof OffscreenCanvas < 'u' && n instanceof OffscreenCanvas)
        return { width: n.width, height: n.height, top: 0, left: 0, updateStyle: t };
    return { width: 0, height: 0, top: 0, left: 0 };
}
function AB(n) {
    const e = Mu.get(n),
        t = e == null ? void 0 : e.fiber,
        i = e == null ? void 0 : e.store;
    e && console.warn('R3F.createRoot should only be called once!');
    const r = typeof reportError == 'function' ? reportError : console.error,
        s = i || yB(zE, BE),
        o = t || rm.createContainer(s, tu.ConcurrentRoot, null, !1, null, '', r, null);
    e || Mu.set(n, { fiber: o, store: s });
    let a,
        c = !1,
        f;
    return {
        configure(d = {}) {
            let {
                    gl: h,
                    size: p,
                    scene: v,
                    events: _,
                    onCreated: w,
                    shadows: x = !1,
                    linear: g = !1,
                    flat: S = !1,
                    legacy: M = !1,
                    orthographic: T = !1,
                    frameloop: P = 'always',
                    dpr: A = [1, 2],
                    performance: R,
                    raycaster: D,
                    camera: G,
                    onPointerMissed: b,
                } = d,
                L = s.getState(),
                ee = L.gl;
            L.gl || L.set({ gl: (ee = EB(h, n)) });
            let ie = L.raycaster;
            ie || L.set({ raycaster: (ie = new Hb()) });
            const { params: j, ...oe } = D || {};
            if (
                (on.equ(oe, ie, Ul) || Dl(ie, { ...oe }),
                on.equ(j, ie.params, Ul) || Dl(ie, { params: { ...ie.params, ...j } }),
                !L.camera || (L.camera === f && !on.equ(f, G, Ul)))
            ) {
                f = G;
                const H = G instanceof Hf,
                    K = H ? G : T ? new Wf(0, 0, 0, 0, 0.1, 1e3) : new Zn(75, 0, 0.1, 1e3);
                H ||
                    ((K.position.z = 5),
                    G && Dl(K, G),
                    !L.camera && !(G != null && G.rotation) && K.lookAt(0, 0, 0)),
                    L.set({ camera: K }),
                    (ie.camera = K);
            }
            if (!L.scene) {
                let H;
                v instanceof nm ? (H = v) : ((H = new nm()), v && Dl(H, v)),
                    L.set({ scene: Ol(H) });
            }
            if (!L.xr) {
                var te;
                const H = (be, Q) => {
                        const me = s.getState();
                        me.frameloop !== 'never' && BE(be, !0, me, Q);
                    },
                    K = () => {
                        const be = s.getState();
                        (be.gl.xr.enabled = be.gl.xr.isPresenting),
                            be.gl.xr.setAnimationLoop(be.gl.xr.isPresenting ? H : null),
                            be.gl.xr.isPresenting || zE(be);
                    },
                    le = {
                        connect() {
                            const be = s.getState().gl;
                            be.xr.addEventListener('sessionstart', K),
                                be.xr.addEventListener('sessionend', K);
                        },
                        disconnect() {
                            const be = s.getState().gl;
                            be.xr.removeEventListener('sessionstart', K),
                                be.xr.removeEventListener('sessionend', K);
                        },
                    };
                typeof ((te = ee.xr) == null ? void 0 : te.addEventListener) == 'function' &&
                    le.connect(),
                    L.set({ xr: le });
            }
            if (ee.shadowMap) {
                const H = ee.shadowMap.enabled,
                    K = ee.shadowMap.type;
                if (((ee.shadowMap.enabled = !!x), on.boo(x))) ee.shadowMap.type = Bc;
                else if (on.str(x)) {
                    var ae;
                    const le = { basic: I2, percentage: Am, soft: Bc, variance: Dr };
                    ee.shadowMap.type = (ae = le[x]) != null ? ae : Bc;
                } else on.obj(x) && Object.assign(ee.shadowMap, x);
                (H !== ee.shadowMap.enabled || K !== ee.shadowMap.type) &&
                    (ee.shadowMap.needsUpdate = !0);
            }
            const N = Yb();
            N && ('enabled' in N ? (N.enabled = !M) : 'legacyMode' in N && (N.legacyMode = M)),
                c || Dl(ee, { outputEncoding: g ? 3e3 : 3001, toneMapping: S ? fs : _x }),
                L.legacy !== M && L.set(() => ({ legacy: M })),
                L.linear !== g && L.set(() => ({ linear: g })),
                L.flat !== S && L.set(() => ({ flat: S })),
                h && !on.fun(h) && !eR(h) && !on.equ(h, ee, Ul) && Dl(ee, h),
                _ && !L.events.handlers && L.set({ events: _(s) });
            const B = TB(n, p);
            return (
                on.equ(B, L.size, Ul) || L.setSize(B.width, B.height, B.updateStyle, B.top, B.left),
                A && L.viewport.dpr !== Jb(A) && L.setDpr(A),
                L.frameloop !== P && L.setFrameloop(P),
                L.onPointerMissed || L.set({ onPointerMissed: b }),
                R &&
                    !on.equ(R, L.performance, Ul) &&
                    L.set((H) => ({ performance: { ...H.performance, ...R } })),
                (a = w),
                (c = !0),
                this
            );
        },
        render(d) {
            return (
                c || this.configure(),
                rm.updateContainer(
                    pe.createElement(CB, { store: s, children: d, onCreated: a, rootElement: n }),
                    o,
                    null,
                    () => {}
                ),
                s
            );
        },
        unmount() {
            tR(n);
        },
    };
}
function CB({ store: n, children: e, onCreated: t, rootElement: i }) {
    return (
        $m(() => {
            const r = n.getState();
            r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
                t && t(r),
                n.getState().events.connected || r.events.connect == null || r.events.connect(i);
        }, []),
        pe.createElement(_B.Provider, { value: n }, e)
    );
}
function tR(n, e) {
    const t = Mu.get(n),
        i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
            rm.updateContainer(null, i, null, () => {
                r &&
                    setTimeout(() => {
                        try {
                            var s, o, a, c;
                            r.events.disconnect == null || r.events.disconnect(),
                                (s = r.gl) == null ||
                                    (o = s.renderLists) == null ||
                                    o.dispose == null ||
                                    o.dispose(),
                                (a = r.gl) == null ||
                                    a.forceContextLoss == null ||
                                    a.forceContextLoss(),
                                (c = r.gl) != null && c.xr && r.xr.disconnect(),
                                dB(r),
                                Mu.delete(n),
                                e && e(n);
                        } catch {}
                    }, 500);
            });
    }
}
rm.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: '@react-three/fiber',
    version: pe.version,
});
function sm() {
    return (
        (sm = Object.assign
            ? Object.assign.bind()
            : function (n) {
                  for (var e = 1; e < arguments.length; e++) {
                      var t = arguments[e];
                      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
                  }
                  return n;
              }),
        sm.apply(this, arguments)
    );
}
function gy(n, e, t) {
    var i, r, s, o, a;
    e == null && (e = 100);
    function c() {
        var d = Date.now() - o;
        d < e && d >= 0
            ? (i = setTimeout(c, e - d))
            : ((i = null), t || ((a = n.apply(s, r)), (s = r = null)));
    }
    var f = function () {
        (s = this), (r = arguments), (o = Date.now());
        var d = t && !i;
        return i || (i = setTimeout(c, e)), d && ((a = n.apply(s, r)), (s = r = null)), a;
    };
    return (
        (f.clear = function () {
            i && (clearTimeout(i), (i = null));
        }),
        (f.flush = function () {
            i && ((a = n.apply(s, r)), (s = r = null), clearTimeout(i), (i = null));
        }),
        f
    );
}
gy.debounce = gy;
var bB = gy;
const HE = Nf(bB);
function RB(n) {
    let {
        debounce: e,
        scroll: t,
        polyfill: i,
        offsetSize: r,
    } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
    const s = i || (typeof window > 'u' ? class {} : window.ResizeObserver);
    if (!s)
        throw new Error(
            'This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills'
        );
    const [o, a] = pe.useState({
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            bottom: 0,
            right: 0,
            x: 0,
            y: 0,
        }),
        c = pe.useRef({
            element: null,
            scrollContainers: null,
            resizeObserver: null,
            lastBounds: o,
        }),
        f = e ? (typeof e == 'number' ? e : e.scroll) : null,
        d = e ? (typeof e == 'number' ? e : e.resize) : null,
        h = pe.useRef(!1);
    pe.useEffect(() => ((h.current = !0), () => void (h.current = !1)));
    const [p, v, _] = pe.useMemo(() => {
        const S = () => {
            if (!c.current.element) return;
            const {
                    left: M,
                    top: T,
                    width: P,
                    height: A,
                    bottom: R,
                    right: D,
                    x: G,
                    y: b,
                } = c.current.element.getBoundingClientRect(),
                L = { left: M, top: T, width: P, height: A, bottom: R, right: D, x: G, y: b };
            c.current.element instanceof HTMLElement &&
                r &&
                ((L.height = c.current.element.offsetHeight),
                (L.width = c.current.element.offsetWidth)),
                Object.freeze(L),
                h.current && !NB(c.current.lastBounds, L) && a((c.current.lastBounds = L));
        };
        return [S, d ? HE(S, d) : S, f ? HE(S, f) : S];
    }, [a, r, f, d]);
    function w() {
        c.current.scrollContainers &&
            (c.current.scrollContainers.forEach((S) => S.removeEventListener('scroll', _, !0)),
            (c.current.scrollContainers = null)),
            c.current.resizeObserver &&
                (c.current.resizeObserver.disconnect(), (c.current.resizeObserver = null));
    }
    function x() {
        c.current.element &&
            ((c.current.resizeObserver = new s(_)),
            c.current.resizeObserver.observe(c.current.element),
            t &&
                c.current.scrollContainers &&
                c.current.scrollContainers.forEach((S) =>
                    S.addEventListener('scroll', _, { capture: !0, passive: !0 })
                ));
    }
    const g = (S) => {
        !S ||
            S === c.current.element ||
            (w(), (c.current.element = S), (c.current.scrollContainers = nR(S)), x());
    };
    return (
        LB(_, !!t),
        PB(v),
        pe.useEffect(() => {
            w(), x();
        }, [t, _, v]),
        pe.useEffect(() => w, []),
        [g, o, p]
    );
}
function PB(n) {
    pe.useEffect(() => {
        const e = n;
        return (
            window.addEventListener('resize', e), () => void window.removeEventListener('resize', e)
        );
    }, [n]);
}
function LB(n, e) {
    pe.useEffect(() => {
        if (e) {
            const t = n;
            return (
                window.addEventListener('scroll', t, { capture: !0, passive: !0 }),
                () => void window.removeEventListener('scroll', t, !0)
            );
        }
    }, [n, e]);
}
function nR(n) {
    const e = [];
    if (!n || n === document.body) return e;
    const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n);
    return (
        [t, i, r].some((s) => s === 'auto' || s === 'scroll') && e.push(n),
        [...e, ...nR(n.parentElement)]
    );
}
const IB = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'],
    NB = (n, e) => IB.every((t) => n[t] === e[t]);
var DB = Object.defineProperty,
    UB = Object.defineProperties,
    OB = Object.getOwnPropertyDescriptors,
    VE = Object.getOwnPropertySymbols,
    FB = Object.prototype.hasOwnProperty,
    kB = Object.prototype.propertyIsEnumerable,
    GE = (n, e, t) =>
        e in n
            ? DB(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
            : (n[e] = t),
    WE = (n, e) => {
        for (var t in e || (e = {})) FB.call(e, t) && GE(n, t, e[t]);
        if (VE) for (var t of VE(e)) kB.call(e, t) && GE(n, t, e[t]);
        return n;
    },
    zB = (n, e) => UB(n, OB(e));
function iR(n, e, t) {
    if (!n) return;
    if (t(n) === !0) return n;
    let i = e ? n.return : n.child;
    for (; i; ) {
        const r = iR(i, e, t);
        if (r) return r;
        i = e ? null : i.sibling;
    }
}
function rR(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null;
                },
                set() {},
            },
            _currentRenderer2: {
                get() {
                    return null;
                },
                set() {},
            },
        });
    } catch {
        return n;
    }
}
const o1 = rR(pe.createContext(null));
class sR extends pe.Component {
    render() {
        return pe.createElement(o1.Provider, { value: this._reactInternals }, this.props.children);
    }
}
const { ReactCurrentOwner: jE, ReactCurrentDispatcher: XE } =
    pe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function BB() {
    const n = pe.useContext(o1);
    if (n === null)
        throw new Error('its-fine: useFiber must be called within a <FiberProvider />!');
    const e = pe.useId();
    return pe.useMemo(() => {
        for (const i of [jE == null ? void 0 : jE.current, n, n == null ? void 0 : n.alternate]) {
            if (!i) continue;
            const r = iR(i, !1, (s) => {
                let o = s.memoizedState;
                for (; o; ) {
                    if (o.memoizedState === e) return !0;
                    o = o.next;
                }
            });
            if (r) return r;
        }
    }, [n, e]);
}
function HB() {
    var n;
    const e = BB(),
        [t] = pe.useState(() => new Map());
    t.clear();
    let i = e;
    for (; i; ) {
        if (i.type && typeof i.type == 'object') {
            const r = 'Provider' in i.type ? i.type : i.type._context;
            r &&
                r !== o1 &&
                !t.has(r) &&
                t.set(
                    r,
                    (n = XE == null ? void 0 : XE.current) == null ? void 0 : n.readContext(rR(r))
                );
        }
        i = i.return;
    }
    return t;
}
function VB() {
    const n = HB();
    return pe.useMemo(
        () =>
            Array.from(n.keys()).reduce(
                (e, t) => (i) =>
                    pe.createElement(
                        e,
                        null,
                        pe.createElement(t.Provider, zB(WE({}, i), { value: n.get(t) }))
                    ),
                (e) => pe.createElement(sR, WE({}, e))
            ),
        [n]
    );
}
const b0 = {
    onClick: ['click', !1],
    onContextMenu: ['contextmenu', !1],
    onDoubleClick: ['dblclick', !1],
    onWheel: ['wheel', !0],
    onPointerDown: ['pointerdown', !0],
    onPointerUp: ['pointerup', !0],
    onPointerLeave: ['pointerleave', !0],
    onPointerMove: ['pointermove', !0],
    onPointerCancel: ['pointercancel', !0],
    onLostPointerCapture: ['lostpointercapture', !0],
};
function GB(n) {
    const { handlePointer: e } = vB(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set((t.offsetX / i.size.width) * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1),
                i.raycaster.setFromCamera(i.pointer, i.camera);
        },
        connected: void 0,
        handlers: Object.keys(b0).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
        update: () => {
            var t;
            const { events: i, internal: r } = n.getState();
            (t = r.lastEvent) != null &&
                t.current &&
                i.handlers &&
                i.handlers.onPointerMove(r.lastEvent.current);
        },
        connect: (t) => {
            var i;
            const { set: r, events: s } = n.getState();
            s.disconnect == null || s.disconnect(),
                r((o) => ({ events: { ...o.events, connected: t } })),
                Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
                    const [c, f] = b0[o];
                    t.addEventListener(c, a, { passive: f });
                });
        },
        disconnect: () => {
            const { set: t, events: i } = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
                    if (i && i.connected instanceof HTMLElement) {
                        const [a] = b0[s];
                        i.connected.removeEventListener(a, o);
                    }
                }),
                    t((s) => ({ events: { ...s.events, connected: void 0 } }));
            }
        },
    };
}
const WB = pe.forwardRef(function (
        {
            children: e,
            fallback: t,
            resize: i,
            style: r,
            gl: s,
            events: o = GB,
            eventSource: a,
            eventPrefix: c,
            shadows: f,
            linear: d,
            flat: h,
            legacy: p,
            orthographic: v,
            frameloop: _,
            dpr: w,
            performance: x,
            raycaster: g,
            camera: S,
            scene: M,
            onPointerMissed: T,
            onCreated: P,
            ...A
        },
        R
    ) {
        pe.useMemo(() => oB(Jz), []);
        const D = VB(),
            [G, b] = RB({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
            L = pe.useRef(null),
            ee = pe.useRef(null);
        pe.useImperativeHandle(R, () => L.current);
        const ie = uB(T),
            [j, oe] = pe.useState(!1),
            [te, ae] = pe.useState(!1);
        if (j) throw j;
        if (te) throw te;
        const N = pe.useRef(null);
        $m(() => {
            const H = L.current;
            b.width > 0 &&
                b.height > 0 &&
                H &&
                (N.current || (N.current = AB(H)),
                N.current.configure({
                    gl: s,
                    events: o,
                    shadows: f,
                    linear: d,
                    flat: h,
                    legacy: p,
                    orthographic: v,
                    frameloop: _,
                    dpr: w,
                    performance: x,
                    raycaster: g,
                    camera: S,
                    scene: M,
                    size: b,
                    onPointerMissed: (...K) => (ie.current == null ? void 0 : ie.current(...K)),
                    onCreated: (K) => {
                        K.events.connect == null ||
                            K.events.connect(a ? (lB(a) ? a.current : a) : ee.current),
                            c &&
                                K.setEvents({
                                    compute: (le, be) => {
                                        const Q = le[c + 'X'],
                                            me = le[c + 'Y'];
                                        be.pointer.set(
                                            (Q / be.size.width) * 2 - 1,
                                            -(me / be.size.height) * 2 + 1
                                        ),
                                            be.raycaster.setFromCamera(be.pointer, be.camera);
                                    },
                                }),
                            P == null || P(K);
                    },
                }),
                N.current.render(
                    pe.createElement(
                        D,
                        null,
                        pe.createElement(
                            Zb,
                            { set: ae },
                            pe.createElement(
                                pe.Suspense,
                                { fallback: pe.createElement(cB, { set: oe }) },
                                e
                            )
                        )
                    )
                ));
        }),
            pe.useEffect(() => {
                const H = L.current;
                if (H) return () => tR(H);
            }, []);
        const B = a ? 'none' : 'auto';
        return pe.createElement(
            'div',
            sm(
                {
                    ref: ee,
                    style: {
                        position: 'relative',
                        width: '100%',
                        height: '100%',
                        overflow: 'hidden',
                        pointerEvents: B,
                        ...r,
                    },
                },
                A
            ),
            pe.createElement(
                'div',
                { ref: G, style: { width: '100%', height: '100%' } },
                pe.createElement('canvas', { ref: L, style: { display: 'block' } }, t)
            )
        );
    }),
    jB = pe.forwardRef(function (e, t) {
        return pe.createElement(sR, null, pe.createElement(WB, sm({}, e, { ref: t })));
    });
function XB(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M502.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l370.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128z',
                },
                child: [],
            },
        ],
    })(n);
}
function YB(n) {
    return Wr({
        tag: 'svg',
        attr: {
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
        },
        child: [
            { tag: 'line', attr: { x1: '22', x2: '2', y1: '6', y2: '6' }, child: [] },
            { tag: 'line', attr: { x1: '22', x2: '2', y1: '18', y2: '18' }, child: [] },
            { tag: 'line', attr: { x1: '6', x2: '6', y1: '2', y2: '22' }, child: [] },
            { tag: 'line', attr: { x1: '18', x2: '18', y1: '2', y2: '22' }, child: [] },
        ],
    })(n);
}
function qB(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 24 24' },
        child: [
            { tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0z' }, child: [] },
            {
                tag: 'path',
                attr: {
                    d: 'M19 1v2H5V1H3v22h2v-2h14v2h2V1h-2zm0 4v6h-6V7H7v4H5V5h14zm-2 14v-4h-6v4H5v-6h14v6h-2z',
                },
                child: [],
            },
        ],
    })(n);
}
function ZB(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 24 24' },
        child: [
            { tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0V0z' }, child: [] },
            {
                tag: 'path',
                attr: {
                    d: 'M20 19V5c0-1.1-.9-2-2-2h-5.25v16h-1.5V3H6c-1.1 0-2 .9-2 2v14H3v2h18v-2h-1zm-10-6H8v-2h2v2zm6 0h-2v-2h2v2z',
                },
                child: [],
            },
        ],
    })(n);
}
function KB(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M23.97 71.4v414.3H57.3V71.4zm109.83 37.7c-12.1-.2-23.6 3.9-32.8 11.2 3.5.4 7 1.1 10.4 2 9.4 2.6 20.2 5.4 28.4 7.7 7.8 2 14.5 7.1 18.5 14.1.3.6.6 1.2.9 1.7 3.5 6.5 4.6 14.3 2.5 21.9-4.1 15.6-19.8 25-35.4 21.6-14.3-4.3-28.59-6.3-41.23-11.8 5.51 15 17.93 27.1 34.53 31.6 27.1 7.2 55-8.9 62.3-36 7.2-27.1-8.9-55-36-62.2-4.1-1.1-8.1-1.7-12.1-1.8zm48.6 2.1c4.8 4.9 8.9 10.6 12.1 16.7H490v-16.7zm-91.16 25.1c-8.82-.1-17.66 1.6-25.9 5.2a64.377 64.377 0 0 0 34.6 23.6c9.36 2.5 20.16 5.4 28.36 7.6 3.5.9 7.3.4 10.5-1.5 3.1-1.7 5.4-4.7 6.4-8.3.9-3.6.4-7.3-1.4-10.4-1.8-3.2-4.8-5.6-8.4-6.5-8.2-2.2-18.9-5.1-28.4-7.6-5.2-1.4-10.46-2.1-15.76-2.1zm277.06 46.6V275l90.4 20V182.9zm-151.4.1 15 236.9 40-10s7.1-92.7 10.6-139c.1-1.1.9-1.9 2-1.9 1 0 1.9.8 1.9 1.9 3.6 46.3 10.6 139 10.6 139l40 10L352 183zm-22.4 9.1c-3.2 6.2-7.3 11.8-12.1 16.6h20.1v-16.6zm278.6 0v16.7H490v-16.7z',
                },
                child: [],
            },
        ],
    })(n);
}
function JB(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M73 41v430h174V220.8c-.3 0-.7-.1-1-.1-21.5-2.9-39.3-2.1-48.7 1.9A71.88 71.88 0 0 1 160 233c-40.2 0-73-32.8-73-73s32.8-73 73-73c29 0 54.1 17 65.9 41.4.2.3.6.7 1.4 1.1 2 1.1 5.4 2.7 10 4.5 2.8 1.1 6.1 2.4 9.7 3.7V41H73zm152.9 87.4c-.4-.5-.2-.4.7 1.5-.2-.5-.5-1-.7-1.5zM160 105c-30.4 0-55 24.6-55 55s24.6 55 55 55c10.7 0 20.5-3 28.9-8.2l.6-.4.6-.3c15.3-6.6 35.3-6.4 58.3-3.3 23.1 3.2 49.2 9.6 75.6 17.6 52.7 16.1 106.4 38.4 137.2 53.5 9 4.5 12.2 3.2 14.2 1.5 2-1.7 4.1-6.8 3.6-14.2-1.1-14.7-12-34.7-32.3-41-78.3-24.5-135.1-42-173-54.4-18.9-6.2-33.1-11.1-43.1-15.1-5-2-8.9-3.7-12-5.5-3.2-1.7-6-2.4-8.4-7.8-8.7-19.1-27.8-32.4-50.2-32.4zm0 183a32 32 0 0 1 32 32 32 32 0 0 1-11.9 24.8L192 416h-64l11.9-71.2A32 32 0 0 1 128 320a32 32 0 0 1 32-32z',
                },
                child: [],
            },
        ],
    })(n);
}
function QB(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 512 512' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M135.6 38.35l-17 6.17c6.2 16.99 9.1 34.17 2.3 51.32 4.5 4.76 8.9 9.46 13.3 14.06 12.5-24.41 9.2-50.15 1.4-71.55zm-25.8 71.95c-6.8 2.6-12.82 5.9-18.27 9.7 27.17 29.8 50.17 61.6 63.77 92.1 12.7 28.7 17.4 57.3 7.2 81.1l219.8 158.9c27.5-1.4 45.3-8.1 57.5-17.5 12.8-9.8 20.1-22.9 25.4-38.4-2.9-3.2-6.1-6.3-9.6-9.4-25.7 4.5-48.2-.6-66.9-12.4-19.5-12.2-34.8-31.1-47.8-53-24.5-41.3-41-94-57.7-137.5-44.5 4.5-77.1-1.7-102.7-14.2-30.6-15-50.7-38.1-70.7-59.4zm-31.92 21.5c-4.57 4.9-8.65 10.3-12.34 16.1-10.56 16.7-17.8 37-23.99 57.9l105.85 76.5c5.7-17.1 2.3-38.5-8.6-62.9-12.5-27.9-34.6-58.6-60.92-87.6zm238.92 47c-5.2 1-10.2 1.9-15.2 2.7 3.7 9.7 7.4 19.7 11.1 29.8l26 13.1c-6.9-16.1-13.7-31.5-21.9-45.6zm-285.29 42c-2.72 2.9-4.48 5.9-5.39 9-1.23 4-1.07 8.4 1.01 13.8L266 398c21.8 14 41.4 25.6 59.2 35.1zm290.29 15.3c6.9 18.3 14.2 36.4 22.3 53.1l33.2 14.7c-11.2-18.1-19.8-36.1-27.5-53.7zm36.2 78.8c11.7 19.2 25 34.7 40.3 44.3 11 6.9 22.9 10.9 36.8 11.3-14.8-12.4-27.1-25.2-37.6-38.2zm119.8 98.4c-5.9 13.3-14.2 25.8-27 35.6-11.4 8.7-26 15.2-44.7 18.6 17.5 4.9 31.2 6.5 41.6 6.1 14.9-.6 23.4-4.7 28.6-8.8 5.2-4.1 7.2-8.2 8.1-10.2 3.5-7.8 3.2-19.9-2.5-33.3-1.1-2.6-2.5-5.3-4.1-8z',
                },
                child: [],
            },
        ],
    })(n);
}
function $B(n) {
    return Wr({
        tag: 'svg',
        attr: { viewBox: '0 0 16 16', fill: 'currentColor' },
        child: [
            {
                tag: 'path',
                attr: {
                    d: 'M2 1L1 2V14L2 15H14L15 14V2L14 1H2ZM2 14V2H4V14H2ZM5 10V2H11V10H5ZM12 2H14V14H12V2Z',
                },
                child: [],
            },
        ],
    })(n);
}
const e5 = ({ className: n }) =>
    X.jsxs('div', {
        className: Tr(Zt.root, n),
        children: [
            X.jsx(Em, {}),
            X.jsxs('div', {
                className: 'Container90',
                style: {
                    width: 1440,
                    height: 118,
                    position: 'relative',
                    background: 'white',
                    boxShadow: '0px 0px 1px rgba(23, 26, 31, 0.19)',
                    borderRadius: 2,
                    flexDirection: 'row',
                    justifyContent: 'flex-start',
                    alignItems: 'flex-start',
                    display: 'flex',
                    flexWrap: 'wrap',
                },
                children: [
                    X.jsx('img', {
                        className: 'Chevron',
                        style: { width: '66px', height: '45px', position: 'relative', top: '30px' },
                        src: 'src/product image/arrowleft.svg',
                    }),
                    X.jsxs('div', {
                        className: Zt['first-slide-block'],
                        children: [
                            X.jsx('img', {
                                className: 'Image50',
                                style: { borderRadius: 2, height: '110px', width: '130px' },
                                src: 'src/product image/Garderobe.png',
                            }),
                            X.jsx('p', {
                                className: 'Lamp',
                                style: {
                                    color: 'black',
                                    fontSize: '24px',
                                    fontFamily: 'Inria Serif',
                                    fontWeight: 400,
                                    overflowWrap: 'break-word',
                                    position: 'relative',
                                    bottom: '70px',
                                    left: '120px',
                                },
                                children: 'Garderobe',
                            }),
                        ],
                    }),
                    X.jsxs('div', {
                        style: { position: 'absolute', left: 480 },
                        className: 'tv-meubel-div',
                        children: [
                            X.jsx('img', {
                                className: 'meubel',
                                style: { width: '120px', height: '112px' },
                                src: 'src/product image/Tvmeubel.svg',
                            }),
                            X.jsx('p', {
                                className: 'LivingRoom',
                                style: {
                                    color: 'black',
                                    fontSize: '24px',
                                    fontFamily: 'Inria Serif',
                                    fontWeight: 400,
                                    overflowWrap: 'break-word',
                                    position: 'relative',
                                    left: '130px',
                                    bottom: '70px',
                                },
                                children: 'TV-meubel',
                            }),
                        ],
                    }),
                    X.jsxs('div', {
                        style: { position: 'absolute', left: '880px', height: '120px' },
                        className: 'Kast',
                        children: [
                            X.jsx('img', {
                                className: 'Image51',
                                style: {
                                    width: '130px',
                                    height: '112px',
                                    boxShadow: '0px 4px 4px rgba(0, 0, 0, 0.25)',
                                    borderRadius: 2,
                                },
                                src: 'src/product image/Kast.png',
                            }),
                            X.jsx('p', {
                                className: 'NewNow',
                                style: {
                                    color: 'black',
                                    fontSize: '24px',
                                    fontFamily: 'Inria Serif',
                                    fontWeight: 400,
                                    overflowWrap: 'break-word',
                                    position: 'relative',
                                    left: '150px',
                                    bottom: '70px',
                                },
                                children: 'Kast',
                            }),
                        ],
                    }),
                    X.jsx('img', {
                        className: 'ChevronLeft',
                        style: {
                            width: 42,
                            position: 'relative',
                            left: 1e3,
                            top: 75,
                            height: 38,
                            transform: 'rotate(180deg)',
                            transformOrigin: '0px 0px',
                        },
                        src: 'src/product image/arrowleft.svg',
                    }),
                ],
            }),
            X.jsxs('div', {
                className: Zt['configurator-section'],
                children: [
                    X.jsx('div', {
                        className: Zt['canva-div'],
                        children: X.jsx(jB, {
                            children: X.jsxs('mesh', {
                                children: [
                                    X.jsx('boxGeometry', { args: [1, 1, 1] }),
                                    X.jsx('meshStandardMaterial', { color: 'hotpink' }),
                                ],
                            }),
                        }),
                    }),
                    X.jsxs('div', {
                        className: Zt['configurator-listing'],
                        children: [
                            X.jsxs('div', {
                                className: 'Container110',
                                style: {
                                    width: '400px',
                                    height: 79,
                                    position: 'relative',
                                    background: 'rgba(243, 243, 243, 1)',
                                    boxShadow: '0px 0px 1px rgba(23, 26, 31, 0.19)',
                                },
                                children: [
                                    X.jsxs('div', {
                                        className: 'Textbox7',
                                        style: {
                                            width: 153,
                                            height: 51,
                                            left: 148,
                                            top: 8.11,
                                            position: 'absolute',
                                            background: '#FFFFFF',
                                            borderRadius: 2,
                                            border: '1px #9095A1 solid',
                                        },
                                        children: [
                                            X.jsx('p', {
                                                className: 'Finalise',
                                                style: {
                                                    width: 82,
                                                    left: 36,
                                                    top: 12,
                                                    position: 'absolute',
                                                    color: '#171A1F',
                                                    fontSize: 18,
                                                    fontFamily: 'Inria Serif',
                                                    fontWeight: '400',
                                                    wordWrap: 'break-word',
                                                },
                                                children: 'Next',
                                            }),
                                            X.jsx('div', {
                                                className: 'ArrowRight',
                                                style: {
                                                    width: 24,
                                                    height: 24,
                                                    left: 110,
                                                    top: 14,
                                                    position: 'absolute',
                                                },
                                                children: X.jsx(XB, {
                                                    style: { width: '50px', height: '20px' },
                                                }),
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: 'Menu2',
                                        style: {
                                            width: 20,
                                            height: 20,
                                            left: 358,
                                            top: 29,
                                            position: 'absolute',
                                        },
                                        children: [
                                            X.jsx('div', {
                                                className: 'Vector',
                                                style: {
                                                    width: 9,
                                                    height: 2,
                                                    left: 2,
                                                    top: 14,
                                                    position: 'absolute',
                                                    background: '#171A1F',
                                                },
                                            }),
                                            X.jsx('div', {
                                                className: 'Vector',
                                                style: {
                                                    width: 9,
                                                    height: 2,
                                                    left: 9,
                                                    top: 4.02,
                                                    position: 'absolute',
                                                    background: '#171A1F',
                                                },
                                            }),
                                            X.jsx('div', {
                                                className: 'Vector',
                                                style: {
                                                    width: 16,
                                                    height: 2,
                                                    left: 2,
                                                    top: 9,
                                                    position: 'absolute',
                                                    background: '#171A1F',
                                                },
                                            }),
                                        ],
                                    }),
                                ],
                            }),
                            X.jsxs('div', {
                                className: Zt['component-config'],
                                children: [
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx(ZB, { className: Zt['door-icon'] }),
                                            X.jsx('p', { className: Zt.door, children: 'Door' }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx(YB, { className: Zt['frame-icon'] }),
                                            X.jsx('p', { className: Zt.door, children: 'Frame' }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx(JB, { className: Zt['handle-icon'] }),
                                            X.jsx('p', { className: Zt.door, children: 'Handle' }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx($B, { className: Zt['drawer-icon'] }),
                                            X.jsx('p', { className: Zt.door, children: 'Drawer' }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx(KB, { className: Zt['rail-icon'] }),
                                            X.jsx('p', {
                                                className: Zt.door,
                                                children: 'Clothes Rail',
                                            }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx(qB, { className: Zt['shelve-icon'] }),
                                            X.jsx('p', { className: Zt.door, children: 'Shelves' }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                    X.jsxs('div', {
                                        className: Zt['components-selection'],
                                        children: [
                                            X.jsx(QB, { className: Zt['shoe-icon'] }),
                                            X.jsx('p', { className: Zt.door, children: 'door' }),
                                            X.jsx(na, {
                                                style: {
                                                    width: '30px',
                                                    height: '20px',
                                                    position: 'relative',
                                                    left: '200px',
                                                },
                                            }),
                                        ],
                                    }),
                                ],
                            }),
                        ],
                    }),
                ],
            }),
        ],
    });
/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Mn() {
    return (
        (Mn = Object.assign
            ? Object.assign.bind()
            : function (n) {
                  for (var e = 1; e < arguments.length; e++) {
                      var t = arguments[e];
                      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
                  }
                  return n;
              }),
        Mn.apply(this, arguments)
    );
}
var Cn;
(function (n) {
    (n.Pop = 'POP'), (n.Push = 'PUSH'), (n.Replace = 'REPLACE');
})(Cn || (Cn = {}));
const YE = 'popstate';
function t5(n) {
    n === void 0 && (n = {});
    function e(i, r) {
        let { pathname: s, search: o, hash: a } = i.location;
        return If(
            '',
            { pathname: s, search: o, hash: a },
            (r.state && r.state.usr) || null,
            (r.state && r.state.key) || 'default'
        );
    }
    function t(i, r) {
        return typeof r == 'string' ? r : Zf(r);
    }
    return i5(e, t, null, n);
}
function Nt(n, e) {
    if (n === !1 || n === null || typeof n > 'u') throw new Error(e);
}
function wu(n, e) {
    if (!n) {
        typeof console < 'u' && console.warn(e);
        try {
            throw new Error(e);
        } catch {}
    }
}
function n5() {
    return Math.random().toString(36).substr(2, 8);
}
function qE(n, e) {
    return { usr: n.state, key: n.key, idx: e };
}
function If(n, e, t, i) {
    return (
        t === void 0 && (t = null),
        Mn(
            { pathname: typeof n == 'string' ? n : n.pathname, search: '', hash: '' },
            typeof e == 'string' ? Zs(e) : e,
            { state: t, key: (e && e.key) || i || n5() }
        )
    );
}
function Zf(n) {
    let { pathname: e = '/', search: t = '', hash: i = '' } = n;
    return (
        t && t !== '?' && (e += t.charAt(0) === '?' ? t : '?' + t),
        i && i !== '#' && (e += i.charAt(0) === '#' ? i : '#' + i),
        e
    );
}
function Zs(n) {
    let e = {};
    if (n) {
        let t = n.indexOf('#');
        t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
        let i = n.indexOf('?');
        i >= 0 && ((e.search = n.substr(i)), (n = n.substr(0, i))), n && (e.pathname = n);
    }
    return e;
}
function i5(n, e, t, i) {
    i === void 0 && (i = {});
    let { window: r = document.defaultView, v5Compat: s = !1 } = i,
        o = r.history,
        a = Cn.Pop,
        c = null,
        f = d();
    f == null && ((f = 0), o.replaceState(Mn({}, o.state, { idx: f }), ''));
    function d() {
        return (o.state || { idx: null }).idx;
    }
    function h() {
        a = Cn.Pop;
        let x = d(),
            g = x == null ? null : x - f;
        (f = x), c && c({ action: a, location: w.location, delta: g });
    }
    function p(x, g) {
        a = Cn.Push;
        let S = If(w.location, x, g);
        t && t(S, x), (f = d() + 1);
        let M = qE(S, f),
            T = w.createHref(S);
        try {
            o.pushState(M, '', T);
        } catch (P) {
            if (P instanceof DOMException && P.name === 'DataCloneError') throw P;
            r.location.assign(T);
        }
        s && c && c({ action: a, location: w.location, delta: 1 });
    }
    function v(x, g) {
        a = Cn.Replace;
        let S = If(w.location, x, g);
        t && t(S, x), (f = d());
        let M = qE(S, f),
            T = w.createHref(S);
        o.replaceState(M, '', T), s && c && c({ action: a, location: w.location, delta: 0 });
    }
    function _(x) {
        let g = r.location.origin !== 'null' ? r.location.origin : r.location.href,
            S = typeof x == 'string' ? x : Zf(x);
        return (
            (S = S.replace(/ $/, '%20')),
            Nt(g, 'No window.location.(origin|href) available to create URL for href: ' + S),
            new URL(S, g)
        );
    }
    let w = {
        get action() {
            return a;
        },
        get location() {
            return n(r, o);
        },
        listen(x) {
            if (c) throw new Error('A history only accepts one active listener');
            return (
                r.addEventListener(YE, h),
                (c = x),
                () => {
                    r.removeEventListener(YE, h), (c = null);
                }
            );
        },
        createHref(x) {
            return e(r, x);
        },
        createURL: _,
        encodeLocation(x) {
            let g = _(x);
            return { pathname: g.pathname, search: g.search, hash: g.hash };
        },
        push: p,
        replace: v,
        go(x) {
            return o.go(x);
        },
    };
    return w;
}
var xn;
(function (n) {
    (n.data = 'data'), (n.deferred = 'deferred'), (n.redirect = 'redirect'), (n.error = 'error');
})(xn || (xn = {}));
const r5 = new Set(['lazy', 'caseSensitive', 'path', 'id', 'index', 'children']);
function s5(n) {
    return n.index === !0;
}
function vy(n, e, t, i) {
    return (
        t === void 0 && (t = []),
        i === void 0 && (i = {}),
        n.map((r, s) => {
            let o = [...t, s],
                a = typeof r.id == 'string' ? r.id : o.join('-');
            if (
                (Nt(r.index !== !0 || !r.children, 'Cannot specify children on an index route'),
                Nt(
                    !i[a],
                    'Found a route id collision on id "' +
                        a +
                        `".  Route id's must be globally unique within Data Router usages`
                ),
                s5(r))
            ) {
                let c = Mn({}, r, e(r), { id: a });
                return (i[a] = c), c;
            } else {
                let c = Mn({}, r, e(r), { id: a, children: void 0 });
                return (i[a] = c), r.children && (c.children = vy(r.children, e, o, i)), c;
            }
        })
    );
}
function nu(n, e, t) {
    t === void 0 && (t = '/');
    let i = typeof e == 'string' ? Zs(e) : e,
        r = Kf(i.pathname || '/', t);
    if (r == null) return null;
    let s = oR(n);
    a5(s);
    let o = null;
    for (let a = 0; o == null && a < s.length; ++a) {
        let c = y5(r);
        o = g5(s[a], c);
    }
    return o;
}
function o5(n, e) {
    let { route: t, pathname: i, params: r } = n;
    return { id: t.id, pathname: i, params: r, data: e[t.id], handle: t.handle };
}
function oR(n, e, t, i) {
    e === void 0 && (e = []), t === void 0 && (t = []), i === void 0 && (i = '');
    let r = (s, o, a) => {
        let c = {
            relativePath: a === void 0 ? s.path || '' : a,
            caseSensitive: s.caseSensitive === !0,
            childrenIndex: o,
            route: s,
        };
        c.relativePath.startsWith('/') &&
            (Nt(
                c.relativePath.startsWith(i),
                'Absolute route path "' +
                    c.relativePath +
                    '" nested under path ' +
                    ('"' + i + '" is not valid. An absolute child route path ') +
                    'must start with the combined path of all its parent routes.'
            ),
            (c.relativePath = c.relativePath.slice(i.length)));
        let f = Oa([i, c.relativePath]),
            d = t.concat(c);
        s.children &&
            s.children.length > 0 &&
            (Nt(
                s.index !== !0,
                'Index routes must not have child routes. Please remove ' +
                    ('all child routes from route path "' + f + '".')
            ),
            oR(s.children, e, d, f)),
            !(s.path == null && !s.index) &&
                e.push({ path: f, score: p5(f, s.index), routesMeta: d });
    };
    return (
        n.forEach((s, o) => {
            var a;
            if (s.path === '' || !((a = s.path) != null && a.includes('?'))) r(s, o);
            else for (let c of aR(s.path)) r(s, o, c);
        }),
        e
    );
}
function aR(n) {
    let e = n.split('/');
    if (e.length === 0) return [];
    let [t, ...i] = e,
        r = t.endsWith('?'),
        s = t.replace(/\?$/, '');
    if (i.length === 0) return r ? [s, ''] : [s];
    let o = aR(i.join('/')),
        a = [];
    return (
        a.push(...o.map((c) => (c === '' ? s : [s, c].join('/')))),
        r && a.push(...o),
        a.map((c) => (n.startsWith('/') && c === '' ? '/' : c))
    );
}
function a5(n) {
    n.sort((e, t) =>
        e.score !== t.score
            ? t.score - e.score
            : m5(
                  e.routesMeta.map((i) => i.childrenIndex),
                  t.routesMeta.map((i) => i.childrenIndex)
              )
    );
}
const l5 = /^:[\w-]+$/,
    u5 = 3,
    c5 = 2,
    f5 = 1,
    d5 = 10,
    h5 = -2,
    ZE = (n) => n === '*';
function p5(n, e) {
    let t = n.split('/'),
        i = t.length;
    return (
        t.some(ZE) && (i += h5),
        e && (i += c5),
        t.filter((r) => !ZE(r)).reduce((r, s) => r + (l5.test(s) ? u5 : s === '' ? f5 : d5), i)
    );
}
function m5(n, e) {
    return n.length === e.length && n.slice(0, -1).every((i, r) => i === e[r])
        ? n[n.length - 1] - e[e.length - 1]
        : 0;
}
function g5(n, e) {
    let { routesMeta: t } = n,
        i = {},
        r = '/',
        s = [];
    for (let o = 0; o < t.length; ++o) {
        let a = t[o],
            c = o === t.length - 1,
            f = r === '/' ? e : e.slice(r.length) || '/',
            d = v5({ path: a.relativePath, caseSensitive: a.caseSensitive, end: c }, f);
        if (!d) return null;
        Object.assign(i, d.params);
        let h = a.route;
        s.push({
            params: i,
            pathname: Oa([r, d.pathname]),
            pathnameBase: E5(Oa([r, d.pathnameBase])),
            route: h,
        }),
            d.pathnameBase !== '/' && (r = Oa([r, d.pathnameBase]));
    }
    return s;
}
function v5(n, e) {
    typeof n == 'string' && (n = { path: n, caseSensitive: !1, end: !0 });
    let [t, i] = _5(n.path, n.caseSensitive, n.end),
        r = e.match(t);
    if (!r) return null;
    let s = r[0],
        o = s.replace(/(.)\/+$/, '$1'),
        a = r.slice(1);
    return {
        params: i.reduce((f, d, h) => {
            let { paramName: p, isOptional: v } = d;
            if (p === '*') {
                let w = a[h] || '';
                o = s.slice(0, s.length - w.length).replace(/(.)\/+$/, '$1');
            }
            const _ = a[h];
            return v && !_ ? (f[p] = void 0) : (f[p] = (_ || '').replace(/%2F/g, '/')), f;
        }, {}),
        pathname: s,
        pathnameBase: o,
        pattern: n,
    };
}
function _5(n, e, t) {
    e === void 0 && (e = !1),
        t === void 0 && (t = !0),
        wu(
            n === '*' || !n.endsWith('*') || n.endsWith('/*'),
            'Route path "' +
                n +
                '" will be treated as if it were ' +
                ('"' + n.replace(/\*$/, '/*') + '" because the `*` character must ') +
                'always follow a `/` in the pattern. To get rid of this warning, ' +
                ('please change the route path to "' + n.replace(/\*$/, '/*') + '".')
        );
    let i = [],
        r =
            '^' +
            n
                .replace(/\/*\*?$/, '')
                .replace(/^\/*/, '/')
                .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
                .replace(
                    /\/:([\w-]+)(\?)?/g,
                    (o, a, c) => (
                        i.push({ paramName: a, isOptional: c != null }),
                        c ? '/?([^\\/]+)?' : '/([^\\/]+)'
                    )
                );
    return (
        n.endsWith('*')
            ? (i.push({ paramName: '*' }),
              (r += n === '*' || n === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
            : t
            ? (r += '\\/*$')
            : n !== '' && n !== '/' && (r += '(?:(?=\\/|$))'),
        [new RegExp(r, e ? void 0 : 'i'), i]
    );
}
function y5(n) {
    try {
        return n
            .split('/')
            .map((e) => decodeURIComponent(e).replace(/\//g, '%2F'))
            .join('/');
    } catch (e) {
        return (
            wu(
                !1,
                'The URL path "' +
                    n +
                    '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
                    ('encoding (' + e + ').')
            ),
            n
        );
    }
}
function Kf(n, e) {
    if (e === '/') return n;
    if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
    let t = e.endsWith('/') ? e.length - 1 : e.length,
        i = n.charAt(t);
    return i && i !== '/' ? null : n.slice(t) || '/';
}
function x5(n, e) {
    e === void 0 && (e = '/');
    let { pathname: t, search: i = '', hash: r = '' } = typeof n == 'string' ? Zs(n) : n;
    return { pathname: t ? (t.startsWith('/') ? t : S5(t, e)) : e, search: T5(i), hash: A5(r) };
}
function S5(n, e) {
    let t = e.replace(/\/+$/, '').split('/');
    return (
        n.split('/').forEach((r) => {
            r === '..' ? t.length > 1 && t.pop() : r !== '.' && t.push(r);
        }),
        t.length > 1 ? t.join('/') : '/'
    );
}
function R0(n, e, t, i) {
    return (
        "Cannot include a '" +
        n +
        "' character in a manually specified " +
        ('`to.' + e + '` field [' + JSON.stringify(i) + '].  Please separate it out to the ') +
        ('`to.' + t + '` field. Alternatively you may provide the full path as ') +
        'a string in <Link to="..."> and the router will parse it for you.'
    );
}
function lR(n) {
    return n.filter((e, t) => t === 0 || (e.route.path && e.route.path.length > 0));
}
function M5(n, e) {
    let t = lR(n);
    return e
        ? t.map((i, r) => (r === n.length - 1 ? i.pathname : i.pathnameBase))
        : t.map((i) => i.pathnameBase);
}
function w5(n, e, t, i) {
    i === void 0 && (i = !1);
    let r;
    typeof n == 'string'
        ? (r = Zs(n))
        : ((r = Mn({}, n)),
          Nt(!r.pathname || !r.pathname.includes('?'), R0('?', 'pathname', 'search', r)),
          Nt(!r.pathname || !r.pathname.includes('#'), R0('#', 'pathname', 'hash', r)),
          Nt(!r.search || !r.search.includes('#'), R0('#', 'search', 'hash', r)));
    let s = n === '' || r.pathname === '',
        o = s ? '/' : r.pathname,
        a;
    if (o == null) a = t;
    else {
        let h = e.length - 1;
        if (!i && o.startsWith('..')) {
            let p = o.split('/');
            for (; p[0] === '..'; ) p.shift(), (h -= 1);
            r.pathname = p.join('/');
        }
        a = h >= 0 ? e[h] : '/';
    }
    let c = x5(r, a),
        f = o && o !== '/' && o.endsWith('/'),
        d = (s || o === '.') && t.endsWith('/');
    return !c.pathname.endsWith('/') && (f || d) && (c.pathname += '/'), c;
}
const Oa = (n) => n.join('/').replace(/\/\/+/g, '/'),
    E5 = (n) => n.replace(/\/+$/, '').replace(/^\/*/, '/'),
    T5 = (n) => (!n || n === '?' ? '' : n.startsWith('?') ? n : '?' + n),
    A5 = (n) => (!n || n === '#' ? '' : n.startsWith('#') ? n : '#' + n);
class a1 {
    constructor(e, t, i, r) {
        r === void 0 && (r = !1),
            (this.status = e),
            (this.statusText = t || ''),
            (this.internal = r),
            i instanceof Error ? ((this.data = i.toString()), (this.error = i)) : (this.data = i);
    }
}
function uR(n) {
    return (
        n != null &&
        typeof n.status == 'number' &&
        typeof n.statusText == 'string' &&
        typeof n.internal == 'boolean' &&
        'data' in n
    );
}
const cR = ['post', 'put', 'patch', 'delete'],
    C5 = new Set(cR),
    b5 = ['get', ...cR],
    R5 = new Set(b5),
    P5 = new Set([301, 302, 303, 307, 308]),
    L5 = new Set([307, 308]),
    P0 = {
        state: 'idle',
        location: void 0,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
    },
    I5 = {
        state: 'idle',
        data: void 0,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
    },
    Sc = { state: 'unblocked', proceed: void 0, reset: void 0, location: void 0 },
    fR = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    N5 = (n) => ({ hasErrorBoundary: !!n.hasErrorBoundary }),
    dR = 'remix-router-transitions';
function D5(n) {
    const e = n.window ? n.window : typeof window < 'u' ? window : void 0,
        t = typeof e < 'u' && typeof e.document < 'u' && typeof e.document.createElement < 'u',
        i = !t;
    Nt(n.routes.length > 0, 'You must provide a non-empty routes array to createRouter');
    let r;
    if (n.mapRouteProperties) r = n.mapRouteProperties;
    else if (n.detectErrorBoundary) {
        let U = n.detectErrorBoundary;
        r = (W) => ({ hasErrorBoundary: U(W) });
    } else r = N5;
    let s = {},
        o = vy(n.routes, r, void 0, s),
        a,
        c = n.basename || '/',
        f = Mn(
            {
                v7_fetcherPersist: !1,
                v7_normalizeFormMethod: !1,
                v7_partialHydration: !1,
                v7_prependBasename: !1,
                v7_relativeSplatPath: !1,
            },
            n.future
        ),
        d = null,
        h = new Set(),
        p = null,
        v = null,
        _ = null,
        w = n.hydrationData != null,
        x = nu(o, n.history.location, c),
        g = null;
    if (x == null) {
        let U = vr(404, { pathname: n.history.location.pathname }),
            { matches: W, route: Y } = iT(o);
        (x = W), (g = { [Y.id]: U });
    }
    let S,
        M = x.some((U) => U.route.lazy),
        T = x.some((U) => U.route.loader);
    if (M) S = !1;
    else if (!T) S = !0;
    else if (f.v7_partialHydration) {
        let U = n.hydrationData ? n.hydrationData.loaderData : null,
            W = n.hydrationData ? n.hydrationData.errors : null,
            Y = (ge) =>
                ge.route.loader
                    ? ge.route.loader.hydrate === !0
                        ? !1
                        : (U && U[ge.route.id] !== void 0) || (W && W[ge.route.id] !== void 0)
                    : !0;
        if (W) {
            let ge = x.findIndex((Ce) => W[Ce.route.id] !== void 0);
            S = x.slice(0, ge + 1).every(Y);
        } else S = x.every(Y);
    } else S = n.hydrationData != null;
    let P,
        A = {
            historyAction: n.history.action,
            location: n.history.location,
            matches: x,
            initialized: S,
            navigation: P0,
            restoreScrollPosition: n.hydrationData != null ? !1 : null,
            preventScrollReset: !1,
            revalidation: 'idle',
            loaderData: (n.hydrationData && n.hydrationData.loaderData) || {},
            actionData: (n.hydrationData && n.hydrationData.actionData) || null,
            errors: (n.hydrationData && n.hydrationData.errors) || g,
            fetchers: new Map(),
            blockers: new Map(),
        },
        R = Cn.Pop,
        D = !1,
        G,
        b = !1,
        L = new Map(),
        ee = null,
        ie = !1,
        j = !1,
        oe = [],
        te = [],
        ae = new Map(),
        N = 0,
        B = -1,
        H = new Map(),
        K = new Set(),
        le = new Map(),
        be = new Map(),
        Q = new Set(),
        me = new Map(),
        Se = new Map(),
        ke = !1;
    function et() {
        if (
            ((d = n.history.listen((U) => {
                let { action: W, location: Y, delta: ge } = U;
                if (ke) {
                    ke = !1;
                    return;
                }
                wu(
                    Se.size === 0 || ge != null,
                    'You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.'
                );
                let Ce = tt({ currentLocation: A.location, nextLocation: Y, historyAction: W });
                if (Ce && ge != null) {
                    (ke = !0),
                        n.history.go(ge * -1),
                        rt(Ce, {
                            state: 'blocked',
                            location: Y,
                            proceed() {
                                rt(Ce, {
                                    state: 'proceeding',
                                    proceed: void 0,
                                    reset: void 0,
                                    location: Y,
                                }),
                                    n.history.go(ge);
                            },
                            reset() {
                                let it = new Map(A.blockers);
                                it.set(Ce, Sc), De({ blockers: it });
                            },
                        });
                    return;
                }
                return Ee(W, Y);
            })),
            t)
        ) {
            j5(e, L);
            let U = () => X5(e, L);
            e.addEventListener('pagehide', U), (ee = () => e.removeEventListener('pagehide', U));
        }
        return A.initialized || Ee(Cn.Pop, A.location, { initialHydration: !0 }), P;
    }
    function Xe() {
        d && d(),
            ee && ee(),
            h.clear(),
            G && G.abort(),
            A.fetchers.forEach((U, W) => ut(W)),
            A.blockers.forEach((U, W) => wt(W));
    }
    function gt(U) {
        return h.add(U), () => h.delete(U);
    }
    function De(U, W) {
        W === void 0 && (W = {}), (A = Mn({}, A, U));
        let Y = [],
            ge = [];
        f.v7_fetcherPersist &&
            A.fetchers.forEach((Ce, it) => {
                Ce.state === 'idle' && (Q.has(it) ? ge.push(it) : Y.push(it));
            }),
            [...h].forEach((Ce) =>
                Ce(A, {
                    deletedFetchers: ge,
                    unstable_viewTransitionOpts: W.viewTransitionOpts,
                    unstable_flushSync: W.flushSync === !0,
                })
            ),
            f.v7_fetcherPersist &&
                (Y.forEach((Ce) => A.fetchers.delete(Ce)), ge.forEach((Ce) => ut(Ce)));
    }
    function V(U, W, Y) {
        var ge, Ce;
        let { flushSync: it } = Y === void 0 ? {} : Y,
            $e =
                A.actionData != null &&
                A.navigation.formMethod != null &&
                Or(A.navigation.formMethod) &&
                A.navigation.state === 'loading' &&
                ((ge = U.state) == null ? void 0 : ge._isRedirect) !== !0,
            Oe;
        W.actionData
            ? Object.keys(W.actionData).length > 0
                ? (Oe = W.actionData)
                : (Oe = null)
            : $e
            ? (Oe = A.actionData)
            : (Oe = null);
        let Ge = W.loaderData
                ? nT(A.loaderData, W.loaderData, W.matches || [], W.errors)
                : A.loaderData,
            pt = A.blockers;
        pt.size > 0 && ((pt = new Map(pt)), pt.forEach((Dt, Kt) => pt.set(Kt, Sc)));
        let rn =
            D === !0 ||
            (A.navigation.formMethod != null &&
                Or(A.navigation.formMethod) &&
                ((Ce = U.state) == null ? void 0 : Ce._isRedirect) !== !0);
        a && ((o = a), (a = void 0)),
            ie ||
                R === Cn.Pop ||
                (R === Cn.Push
                    ? n.history.push(U, U.state)
                    : R === Cn.Replace && n.history.replace(U, U.state));
        let _t;
        if (R === Cn.Pop) {
            let Dt = L.get(A.location.pathname);
            Dt && Dt.has(U.pathname)
                ? (_t = { currentLocation: A.location, nextLocation: U })
                : L.has(U.pathname) && (_t = { currentLocation: U, nextLocation: A.location });
        } else if (b) {
            let Dt = L.get(A.location.pathname);
            Dt
                ? Dt.add(U.pathname)
                : ((Dt = new Set([U.pathname])), L.set(A.location.pathname, Dt)),
                (_t = { currentLocation: A.location, nextLocation: U });
        }
        De(
            Mn({}, W, {
                actionData: Oe,
                loaderData: Ge,
                historyAction: R,
                location: U,
                initialized: !0,
                navigation: P0,
                revalidation: 'idle',
                restoreScrollPosition: q(U, W.matches || A.matches),
                preventScrollReset: rn,
                blockers: pt,
            }),
            { viewTransitionOpts: _t, flushSync: it === !0 }
        ),
            (R = Cn.Pop),
            (D = !1),
            (b = !1),
            (ie = !1),
            (j = !1),
            (oe = []),
            (te = []);
    }
    async function we(U, W) {
        if (typeof U == 'number') {
            n.history.go(U);
            return;
        }
        let Y = _y(
                A.location,
                A.matches,
                c,
                f.v7_prependBasename,
                U,
                f.v7_relativeSplatPath,
                W == null ? void 0 : W.fromRouteId,
                W == null ? void 0 : W.relative
            ),
            { path: ge, submission: Ce, error: it } = KE(f.v7_normalizeFormMethod, !1, Y, W),
            $e = A.location,
            Oe = If(A.location, ge, W && W.state);
        Oe = Mn({}, Oe, n.history.encodeLocation(Oe));
        let Ge = W && W.replace != null ? W.replace : void 0,
            pt = Cn.Push;
        Ge === !0
            ? (pt = Cn.Replace)
            : Ge === !1 ||
              (Ce != null &&
                  Or(Ce.formMethod) &&
                  Ce.formAction === A.location.pathname + A.location.search &&
                  (pt = Cn.Replace));
        let rn = W && 'preventScrollReset' in W ? W.preventScrollReset === !0 : void 0,
            _t = (W && W.unstable_flushSync) === !0,
            Dt = tt({ currentLocation: $e, nextLocation: Oe, historyAction: pt });
        if (Dt) {
            rt(Dt, {
                state: 'blocked',
                location: Oe,
                proceed() {
                    rt(Dt, { state: 'proceeding', proceed: void 0, reset: void 0, location: Oe }),
                        we(U, W);
                },
                reset() {
                    let Kt = new Map(A.blockers);
                    Kt.set(Dt, Sc), De({ blockers: Kt });
                },
            });
            return;
        }
        return await Ee(pt, Oe, {
            submission: Ce,
            pendingError: it,
            preventScrollReset: rn,
            replace: W && W.replace,
            enableViewTransition: W && W.unstable_viewTransition,
            flushSync: _t,
        });
    }
    function ve() {
        if ((ce(), De({ revalidation: 'loading' }), A.navigation.state !== 'submitting')) {
            if (A.navigation.state === 'idle') {
                Ee(A.historyAction, A.location, { startUninterruptedRevalidation: !0 });
                return;
            }
            Ee(R || A.historyAction, A.navigation.location, { overrideNavigation: A.navigation });
        }
    }
    async function Ee(U, W, Y) {
        G && G.abort(),
            (G = null),
            (R = U),
            (ie = (Y && Y.startUninterruptedRevalidation) === !0),
            Xt(A.location, A.matches),
            (D = (Y && Y.preventScrollReset) === !0),
            (b = (Y && Y.enableViewTransition) === !0);
        let ge = a || o,
            Ce = Y && Y.overrideNavigation,
            it = nu(ge, W, c),
            $e = (Y && Y.flushSync) === !0;
        if (!it) {
            let Kt = vr(404, { pathname: W.pathname }),
                { matches: Pn, route: ln } = iT(ge);
            Qe(), V(W, { matches: Pn, loaderData: {}, errors: { [ln.id]: Kt } }, { flushSync: $e });
            return;
        }
        if (
            A.initialized &&
            !j &&
            z5(A.location, W) &&
            !(Y && Y.submission && Or(Y.submission.formMethod))
        ) {
            V(W, { matches: it }, { flushSync: $e });
            return;
        }
        G = new AbortController();
        let Oe = wc(n.history, W, G.signal, Y && Y.submission),
            Ge,
            pt;
        if (Y && Y.pendingError) pt = { [jc(it).route.id]: Y.pendingError };
        else if (Y && Y.submission && Or(Y.submission.formMethod)) {
            let Kt = await ye(Oe, W, Y.submission, it, { replace: Y.replace, flushSync: $e });
            if (Kt.shortCircuited) return;
            (Ge = Kt.pendingActionData),
                (pt = Kt.pendingActionError),
                (Ce = L0(W, Y.submission)),
                ($e = !1),
                (Oe = new Request(Oe.url, { signal: Oe.signal }));
        }
        let {
            shortCircuited: rn,
            loaderData: _t,
            errors: Dt,
        } = await We(
            Oe,
            W,
            it,
            Ce,
            Y && Y.submission,
            Y && Y.fetcherSubmission,
            Y && Y.replace,
            Y && Y.initialHydration === !0,
            $e,
            Ge,
            pt
        );
        rn ||
            ((G = null),
            V(
                W,
                Mn({ matches: it }, Ge ? { actionData: Ge } : {}, { loaderData: _t, errors: Dt })
            ));
    }
    async function ye(U, W, Y, ge, Ce) {
        Ce === void 0 && (Ce = {}), ce();
        let it = G5(W, Y);
        De({ navigation: it }, { flushSync: Ce.flushSync === !0 });
        let $e,
            Oe = xy(ge, W);
        if (!Oe.route.action && !Oe.route.lazy)
            $e = {
                type: xn.error,
                error: vr(405, { method: U.method, pathname: W.pathname, routeId: Oe.route.id }),
            };
        else if (
            (($e = await Mc('action', U, Oe, ge, s, r, c, f.v7_relativeSplatPath)),
            U.signal.aborted)
        )
            return { shortCircuited: !0 };
        if (Ra($e)) {
            let Ge;
            return (
                Ce && Ce.replace != null
                    ? (Ge = Ce.replace)
                    : (Ge = $e.location === A.location.pathname + A.location.search),
                await F(A, $e, { submission: Y, replace: Ge }),
                { shortCircuited: !0 }
            );
        }
        if (iu($e)) {
            let Ge = jc(ge, Oe.route.id);
            return (
                (Ce && Ce.replace) !== !0 && (R = Cn.Push),
                { pendingActionData: {}, pendingActionError: { [Ge.route.id]: $e.error } }
            );
        }
        if (ba($e)) throw vr(400, { type: 'defer-action' });
        return { pendingActionData: { [Oe.route.id]: $e.data } };
    }
    async function We(U, W, Y, ge, Ce, it, $e, Oe, Ge, pt, rn) {
        let _t = ge || L0(W, Ce),
            Dt = Ce || it || oT(_t),
            Kt = a || o,
            [Pn, ln] = JE(
                n.history,
                A,
                Y,
                Dt,
                W,
                f.v7_partialHydration && Oe === !0,
                j,
                oe,
                te,
                Q,
                le,
                K,
                Kt,
                c,
                pt,
                rn
            );
        if (
            (Qe(
                (Re) =>
                    !(Y && Y.some((Ue) => Ue.route.id === Re)) ||
                    (Pn && Pn.some((Ue) => Ue.route.id === Re))
            ),
            (B = ++N),
            Pn.length === 0 && ln.length === 0)
        ) {
            let Re = ht();
            return (
                V(
                    W,
                    Mn(
                        { matches: Y, loaderData: {}, errors: rn || null },
                        pt ? { actionData: pt } : {},
                        Re ? { fetchers: new Map(A.fetchers) } : {}
                    ),
                    { flushSync: Ge }
                ),
                { shortCircuited: !0 }
            );
        }
        if (!ie && (!f.v7_partialHydration || !Oe)) {
            ln.forEach((Ue) => {
                let Je = A.fetchers.get(Ue.key),
                    ct = Ec(void 0, Je ? Je.data : void 0);
                A.fetchers.set(Ue.key, ct);
            });
            let Re = pt || A.actionData;
            De(
                Mn(
                    { navigation: _t },
                    Re
                        ? Object.keys(Re).length === 0
                            ? { actionData: null }
                            : { actionData: Re }
                        : {},
                    ln.length > 0 ? { fetchers: new Map(A.fetchers) } : {}
                ),
                { flushSync: Ge }
            );
        }
        ln.forEach((Re) => {
            ae.has(Re.key) && Ae(Re.key), Re.controller && ae.set(Re.key, Re.controller);
        });
        let Ar = () => ln.forEach((Re) => Ae(Re.key));
        G && G.signal.addEventListener('abort', Ar);
        let {
            results: Xo,
            loaderResults: Yr,
            fetcherResults: sr,
        } = await I(A.matches, Y, Pn, ln, U);
        if (U.signal.aborted) return { shortCircuited: !0 };
        G && G.signal.removeEventListener('abort', Ar), ln.forEach((Re) => ae.delete(Re.key));
        let O = rT(Xo);
        if (O) {
            if (O.idx >= Pn.length) {
                let Re = ln[O.idx - Pn.length].key;
                K.add(Re);
            }
            return await F(A, O.result, { replace: $e }), { shortCircuited: !0 };
        }
        let { loaderData: $, errors: se } = tT(A, Y, Pn, Yr, rn, ln, sr, me);
        me.forEach((Re, Ue) => {
            Re.subscribe((Je) => {
                (Je || Re.done) && me.delete(Ue);
            });
        }),
            f.v7_partialHydration &&
                Oe &&
                A.errors &&
                Object.entries(A.errors)
                    .filter((Re) => {
                        let [Ue] = Re;
                        return !Pn.some((Je) => Je.route.id === Ue);
                    })
                    .forEach((Re) => {
                        let [Ue, Je] = Re;
                        se = Object.assign(se || {}, { [Ue]: Je });
                    });
        let ue = ht(),
            ne = Pe(B),
            ze = ue || ne || ln.length > 0;
        return Mn({ loaderData: $, errors: se }, ze ? { fetchers: new Map(A.fetchers) } : {});
    }
    function He(U, W, Y, ge) {
        if (i)
            throw new Error(
                "router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."
            );
        ae.has(U) && Ae(U);
        let Ce = (ge && ge.unstable_flushSync) === !0,
            it = a || o,
            $e = _y(
                A.location,
                A.matches,
                c,
                f.v7_prependBasename,
                Y,
                f.v7_relativeSplatPath,
                W,
                ge == null ? void 0 : ge.relative
            ),
            Oe = nu(it, $e, c);
        if (!Oe) {
            Me(U, W, vr(404, { pathname: $e }), { flushSync: Ce });
            return;
        }
        let { path: Ge, submission: pt, error: rn } = KE(f.v7_normalizeFormMethod, !0, $e, ge);
        if (rn) {
            Me(U, W, rn, { flushSync: Ce });
            return;
        }
        let _t = xy(Oe, Ge);
        if (((D = (ge && ge.preventScrollReset) === !0), pt && Or(pt.formMethod))) {
            Ke(U, W, Ge, _t, Oe, Ce, pt);
            return;
        }
        le.set(U, { routeId: W, path: Ge }), yt(U, W, Ge, _t, Oe, Ce, pt);
    }
    async function Ke(U, W, Y, ge, Ce, it, $e) {
        if ((ce(), le.delete(U), !ge.route.action && !ge.route.lazy)) {
            let Ue = vr(405, { method: $e.formMethod, pathname: Y, routeId: W });
            Me(U, W, Ue, { flushSync: it });
            return;
        }
        let Oe = A.fetchers.get(U);
        de(U, W5($e, Oe), { flushSync: it });
        let Ge = new AbortController(),
            pt = wc(n.history, Y, Ge.signal, $e);
        ae.set(U, Ge);
        let rn = N,
            _t = await Mc('action', pt, ge, Ce, s, r, c, f.v7_relativeSplatPath);
        if (pt.signal.aborted) {
            ae.get(U) === Ge && ae.delete(U);
            return;
        }
        if (f.v7_fetcherPersist && Q.has(U)) {
            if (Ra(_t) || iu(_t)) {
                de(U, mo(void 0));
                return;
            }
        } else {
            if (Ra(_t))
                if ((ae.delete(U), B > rn)) {
                    de(U, mo(void 0));
                    return;
                } else return K.add(U), de(U, Ec($e)), F(A, _t, { fetcherSubmission: $e });
            if (iu(_t)) {
                Me(U, W, _t.error);
                return;
            }
        }
        if (ba(_t)) throw vr(400, { type: 'defer-action' });
        let Dt = A.navigation.location || A.location,
            Kt = wc(n.history, Dt, Ge.signal),
            Pn = a || o,
            ln = A.navigation.state !== 'idle' ? nu(Pn, A.navigation.location, c) : A.matches;
        Nt(ln, "Didn't find any matches after fetcher action");
        let Ar = ++N;
        H.set(U, Ar);
        let Xo = Ec($e, _t.data);
        A.fetchers.set(U, Xo);
        let [Yr, sr] = JE(
            n.history,
            A,
            ln,
            $e,
            Dt,
            !1,
            j,
            oe,
            te,
            Q,
            le,
            K,
            Pn,
            c,
            { [ge.route.id]: _t.data },
            void 0
        );
        sr
            .filter((Ue) => Ue.key !== U)
            .forEach((Ue) => {
                let Je = Ue.key,
                    ct = A.fetchers.get(Je),
                    mt = Ec(void 0, ct ? ct.data : void 0);
                A.fetchers.set(Je, mt),
                    ae.has(Je) && Ae(Je),
                    Ue.controller && ae.set(Je, Ue.controller);
            }),
            De({ fetchers: new Map(A.fetchers) });
        let O = () => sr.forEach((Ue) => Ae(Ue.key));
        Ge.signal.addEventListener('abort', O);
        let {
            results: $,
            loaderResults: se,
            fetcherResults: ue,
        } = await I(A.matches, ln, Yr, sr, Kt);
        if (Ge.signal.aborted) return;
        Ge.signal.removeEventListener('abort', O),
            H.delete(U),
            ae.delete(U),
            sr.forEach((Ue) => ae.delete(Ue.key));
        let ne = rT($);
        if (ne) {
            if (ne.idx >= Yr.length) {
                let Ue = sr[ne.idx - Yr.length].key;
                K.add(Ue);
            }
            return F(A, ne.result);
        }
        let { loaderData: ze, errors: Re } = tT(A, A.matches, Yr, se, void 0, sr, ue, me);
        if (A.fetchers.has(U)) {
            let Ue = mo(_t.data);
            A.fetchers.set(U, Ue);
        }
        Pe(Ar),
            A.navigation.state === 'loading' && Ar > B
                ? (Nt(R, 'Expected pending action'),
                  G && G.abort(),
                  V(A.navigation.location, {
                      matches: ln,
                      loaderData: ze,
                      errors: Re,
                      fetchers: new Map(A.fetchers),
                  }))
                : (De({
                      errors: Re,
                      loaderData: nT(A.loaderData, ze, ln, Re),
                      fetchers: new Map(A.fetchers),
                  }),
                  (j = !1));
    }
    async function yt(U, W, Y, ge, Ce, it, $e) {
        let Oe = A.fetchers.get(U);
        de(U, Ec($e, Oe ? Oe.data : void 0), { flushSync: it });
        let Ge = new AbortController(),
            pt = wc(n.history, Y, Ge.signal);
        ae.set(U, Ge);
        let rn = N,
            _t = await Mc('loader', pt, ge, Ce, s, r, c, f.v7_relativeSplatPath);
        if (
            (ba(_t) && (_t = (await mR(_t, pt.signal, !0)) || _t),
            ae.get(U) === Ge && ae.delete(U),
            !pt.signal.aborted)
        ) {
            if (Q.has(U)) {
                de(U, mo(void 0));
                return;
            }
            if (Ra(_t))
                if (B > rn) {
                    de(U, mo(void 0));
                    return;
                } else {
                    K.add(U), await F(A, _t);
                    return;
                }
            if (iu(_t)) {
                Me(U, W, _t.error);
                return;
            }
            Nt(!ba(_t), 'Unhandled fetcher deferred data'), de(U, mo(_t.data));
        }
    }
    async function F(U, W, Y) {
        let { submission: ge, fetcherSubmission: Ce, replace: it } = Y === void 0 ? {} : Y;
        W.revalidate && (j = !0);
        let $e = If(U.location, W.location, { _isRedirect: !0 });
        if ((Nt($e, 'Expected a location on the redirect navigation'), t)) {
            let Dt = !1;
            if (W.reloadDocument) Dt = !0;
            else if (fR.test(W.location)) {
                const Kt = n.history.createURL(W.location);
                Dt = Kt.origin !== e.location.origin || Kf(Kt.pathname, c) == null;
            }
            if (Dt) {
                it ? e.location.replace(W.location) : e.location.assign(W.location);
                return;
            }
        }
        G = null;
        let Oe = it === !0 ? Cn.Replace : Cn.Push,
            { formMethod: Ge, formAction: pt, formEncType: rn } = U.navigation;
        !ge && !Ce && Ge && pt && rn && (ge = oT(U.navigation));
        let _t = ge || Ce;
        if (L5.has(W.status) && _t && Or(_t.formMethod))
            await Ee(Oe, $e, {
                submission: Mn({}, _t, { formAction: W.location }),
                preventScrollReset: D,
            });
        else {
            let Dt = L0($e, ge);
            await Ee(Oe, $e, {
                overrideNavigation: Dt,
                fetcherSubmission: Ce,
                preventScrollReset: D,
            });
        }
    }
    async function I(U, W, Y, ge, Ce) {
        let it = await Promise.all([
                ...Y.map((Ge) => Mc('loader', Ce, Ge, W, s, r, c, f.v7_relativeSplatPath)),
                ...ge.map((Ge) =>
                    Ge.matches && Ge.match && Ge.controller
                        ? Mc(
                              'loader',
                              wc(n.history, Ge.path, Ge.controller.signal),
                              Ge.match,
                              Ge.matches,
                              s,
                              r,
                              c,
                              f.v7_relativeSplatPath
                          )
                        : { type: xn.error, error: vr(404, { pathname: Ge.path }) }
                ),
            ]),
            $e = it.slice(0, Y.length),
            Oe = it.slice(Y.length);
        return (
            await Promise.all([
                sT(
                    U,
                    Y,
                    $e,
                    $e.map(() => Ce.signal),
                    !1,
                    A.loaderData
                ),
                sT(
                    U,
                    ge.map((Ge) => Ge.match),
                    Oe,
                    ge.map((Ge) => (Ge.controller ? Ge.controller.signal : null)),
                    !0
                ),
            ]),
            { results: it, loaderResults: $e, fetcherResults: Oe }
        );
    }
    function ce() {
        (j = !0),
            oe.push(...Qe()),
            le.forEach((U, W) => {
                ae.has(W) && (te.push(W), Ae(W));
            });
    }
    function de(U, W, Y) {
        Y === void 0 && (Y = {}),
            A.fetchers.set(U, W),
            De({ fetchers: new Map(A.fetchers) }, { flushSync: (Y && Y.flushSync) === !0 });
    }
    function Me(U, W, Y, ge) {
        ge === void 0 && (ge = {});
        let Ce = jc(A.matches, W);
        ut(U),
            De(
                { errors: { [Ce.route.id]: Y }, fetchers: new Map(A.fetchers) },
                { flushSync: (ge && ge.flushSync) === !0 }
            );
    }
    function xe(U) {
        return (
            f.v7_fetcherPersist && (be.set(U, (be.get(U) || 0) + 1), Q.has(U) && Q.delete(U)),
            A.fetchers.get(U) || I5
        );
    }
    function ut(U) {
        let W = A.fetchers.get(U);
        ae.has(U) && !(W && W.state === 'loading' && H.has(U)) && Ae(U),
            le.delete(U),
            H.delete(U),
            K.delete(U),
            Q.delete(U),
            A.fetchers.delete(U);
    }
    function at(U) {
        if (f.v7_fetcherPersist) {
            let W = (be.get(U) || 0) - 1;
            W <= 0 ? (be.delete(U), Q.add(U)) : be.set(U, W);
        } else ut(U);
        De({ fetchers: new Map(A.fetchers) });
    }
    function Ae(U) {
        let W = ae.get(U);
        Nt(W, 'Expected fetch controller: ' + U), W.abort(), ae.delete(U);
    }
    function Ie(U) {
        for (let W of U) {
            let Y = xe(W),
                ge = mo(Y.data);
            A.fetchers.set(W, ge);
        }
    }
    function ht() {
        let U = [],
            W = !1;
        for (let Y of K) {
            let ge = A.fetchers.get(Y);
            Nt(ge, 'Expected fetcher: ' + Y),
                ge.state === 'loading' && (K.delete(Y), U.push(Y), (W = !0));
        }
        return Ie(U), W;
    }
    function Pe(U) {
        let W = [];
        for (let [Y, ge] of H)
            if (ge < U) {
                let Ce = A.fetchers.get(Y);
                Nt(Ce, 'Expected fetcher: ' + Y),
                    Ce.state === 'loading' && (Ae(Y), H.delete(Y), W.push(Y));
            }
        return Ie(W), W.length > 0;
    }
    function nn(U, W) {
        let Y = A.blockers.get(U) || Sc;
        return Se.get(U) !== W && Se.set(U, W), Y;
    }
    function wt(U) {
        A.blockers.delete(U), Se.delete(U);
    }
    function rt(U, W) {
        let Y = A.blockers.get(U) || Sc;
        Nt(
            (Y.state === 'unblocked' && W.state === 'blocked') ||
                (Y.state === 'blocked' && W.state === 'blocked') ||
                (Y.state === 'blocked' && W.state === 'proceeding') ||
                (Y.state === 'blocked' && W.state === 'unblocked') ||
                (Y.state === 'proceeding' && W.state === 'unblocked'),
            'Invalid blocker state transition: ' + Y.state + ' -> ' + W.state
        );
        let ge = new Map(A.blockers);
        ge.set(U, W), De({ blockers: ge });
    }
    function tt(U) {
        let { currentLocation: W, nextLocation: Y, historyAction: ge } = U;
        if (Se.size === 0) return;
        Se.size > 1 && wu(!1, 'A router only supports one blocker at a time');
        let Ce = Array.from(Se.entries()),
            [it, $e] = Ce[Ce.length - 1],
            Oe = A.blockers.get(it);
        if (
            !(Oe && Oe.state === 'proceeding') &&
            $e({ currentLocation: W, nextLocation: Y, historyAction: ge })
        )
            return it;
    }
    function Qe(U) {
        let W = [];
        return (
            me.forEach((Y, ge) => {
                (!U || U(ge)) && (Y.cancel(), W.push(ge), me.delete(ge));
            }),
            W
        );
    }
    function Lt(U, W, Y) {
        if (((p = U), (_ = W), (v = Y || null), !w && A.navigation === P0)) {
            w = !0;
            let ge = q(A.location, A.matches);
            ge != null && De({ restoreScrollPosition: ge });
        }
        return () => {
            (p = null), (_ = null), (v = null);
        };
    }
    function vt(U, W) {
        return (
            (v &&
                v(
                    U,
                    W.map((ge) => o5(ge, A.loaderData))
                )) ||
            U.key
        );
    }
    function Xt(U, W) {
        if (p && _) {
            let Y = vt(U, W);
            p[Y] = _();
        }
    }
    function q(U, W) {
        if (p) {
            let Y = vt(U, W),
                ge = p[Y];
            if (typeof ge == 'number') return ge;
        }
        return null;
    }
    function Fe(U) {
        (s = {}), (a = vy(U, r, void 0, s));
    }
    return (
        (P = {
            get basename() {
                return c;
            },
            get future() {
                return f;
            },
            get state() {
                return A;
            },
            get routes() {
                return o;
            },
            get window() {
                return e;
            },
            initialize: et,
            subscribe: gt,
            enableScrollRestoration: Lt,
            navigate: we,
            fetch: He,
            revalidate: ve,
            createHref: (U) => n.history.createHref(U),
            encodeLocation: (U) => n.history.encodeLocation(U),
            getFetcher: xe,
            deleteFetcher: at,
            dispose: Xe,
            getBlocker: nn,
            deleteBlocker: wt,
            _internalFetchControllers: ae,
            _internalActiveDeferreds: me,
            _internalSetRoutes: Fe,
        }),
        P
    );
}
function U5(n) {
    return (
        n != null && (('formData' in n && n.formData != null) || ('body' in n && n.body !== void 0))
    );
}
function _y(n, e, t, i, r, s, o, a) {
    let c, f;
    if (o) {
        c = [];
        for (let h of e)
            if ((c.push(h), h.route.id === o)) {
                f = h;
                break;
            }
    } else (c = e), (f = e[e.length - 1]);
    let d = w5(r || '.', M5(c, s), Kf(n.pathname, t) || n.pathname, a === 'path');
    return (
        r == null && ((d.search = n.search), (d.hash = n.hash)),
        (r == null || r === '' || r === '.') &&
            f &&
            f.route.index &&
            !l1(d.search) &&
            (d.search = d.search ? d.search.replace(/^\?/, '?index&') : '?index'),
        i && t !== '/' && (d.pathname = d.pathname === '/' ? t : Oa([t, d.pathname])),
        Zf(d)
    );
}
function KE(n, e, t, i) {
    if (!i || !U5(i)) return { path: t };
    if (i.formMethod && !V5(i.formMethod))
        return { path: t, error: vr(405, { method: i.formMethod }) };
    let r = () => ({ path: t, error: vr(400, { type: 'invalid-body' }) }),
        s = i.formMethod || 'get',
        o = n ? s.toUpperCase() : s.toLowerCase(),
        a = pR(t);
    if (i.body !== void 0) {
        if (i.formEncType === 'text/plain') {
            if (!Or(o)) return r();
            let p =
                typeof i.body == 'string'
                    ? i.body
                    : i.body instanceof FormData || i.body instanceof URLSearchParams
                    ? Array.from(i.body.entries()).reduce((v, _) => {
                          let [w, x] = _;
                          return (
                              '' +
                              v +
                              w +
                              '=' +
                              x +
                              `
`
                          );
                      }, '')
                    : String(i.body);
            return {
                path: t,
                submission: {
                    formMethod: o,
                    formAction: a,
                    formEncType: i.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: p,
                },
            };
        } else if (i.formEncType === 'application/json') {
            if (!Or(o)) return r();
            try {
                let p = typeof i.body == 'string' ? JSON.parse(i.body) : i.body;
                return {
                    path: t,
                    submission: {
                        formMethod: o,
                        formAction: a,
                        formEncType: i.formEncType,
                        formData: void 0,
                        json: p,
                        text: void 0,
                    },
                };
            } catch {
                return r();
            }
        }
    }
    Nt(typeof FormData == 'function', 'FormData is not available in this environment');
    let c, f;
    if (i.formData) (c = yy(i.formData)), (f = i.formData);
    else if (i.body instanceof FormData) (c = yy(i.body)), (f = i.body);
    else if (i.body instanceof URLSearchParams) (c = i.body), (f = eT(c));
    else if (i.body == null) (c = new URLSearchParams()), (f = new FormData());
    else
        try {
            (c = new URLSearchParams(i.body)), (f = eT(c));
        } catch {
            return r();
        }
    let d = {
        formMethod: o,
        formAction: a,
        formEncType: (i && i.formEncType) || 'application/x-www-form-urlencoded',
        formData: f,
        json: void 0,
        text: void 0,
    };
    if (Or(d.formMethod)) return { path: t, submission: d };
    let h = Zs(t);
    return (
        e && h.search && l1(h.search) && c.append('index', ''),
        (h.search = '?' + c),
        { path: Zf(h), submission: d }
    );
}
function O5(n, e) {
    let t = n;
    if (e) {
        let i = n.findIndex((r) => r.route.id === e);
        i >= 0 && (t = n.slice(0, i));
    }
    return t;
}
function JE(n, e, t, i, r, s, o, a, c, f, d, h, p, v, _, w) {
    let x = w ? Object.values(w)[0] : _ ? Object.values(_)[0] : void 0,
        g = n.createURL(e.location),
        S = n.createURL(r),
        M = w ? Object.keys(w)[0] : void 0,
        P = O5(t, M).filter((R, D) => {
            let { route: G } = R;
            if (G.lazy) return !0;
            if (G.loader == null) return !1;
            if (s)
                return G.loader.hydrate
                    ? !0
                    : e.loaderData[G.id] === void 0 && (!e.errors || e.errors[G.id] === void 0);
            if (F5(e.loaderData, e.matches[D], R) || a.some((ee) => ee === R.route.id)) return !0;
            let b = e.matches[D],
                L = R;
            return QE(
                R,
                Mn(
                    { currentUrl: g, currentParams: b.params, nextUrl: S, nextParams: L.params },
                    i,
                    {
                        actionResult: x,
                        defaultShouldRevalidate:
                            o ||
                            g.pathname + g.search === S.pathname + S.search ||
                            g.search !== S.search ||
                            hR(b, L),
                    }
                )
            );
        }),
        A = [];
    return (
        d.forEach((R, D) => {
            if (s || !t.some((ie) => ie.route.id === R.routeId) || f.has(D)) return;
            let G = nu(p, R.path, v);
            if (!G) {
                A.push({
                    key: D,
                    routeId: R.routeId,
                    path: R.path,
                    matches: null,
                    match: null,
                    controller: null,
                });
                return;
            }
            let b = e.fetchers.get(D),
                L = xy(G, R.path),
                ee = !1;
            h.has(D)
                ? (ee = !1)
                : c.includes(D)
                ? (ee = !0)
                : b && b.state !== 'idle' && b.data === void 0
                ? (ee = o)
                : (ee = QE(
                      L,
                      Mn(
                          {
                              currentUrl: g,
                              currentParams: e.matches[e.matches.length - 1].params,
                              nextUrl: S,
                              nextParams: t[t.length - 1].params,
                          },
                          i,
                          { actionResult: x, defaultShouldRevalidate: o }
                      )
                  )),
                ee &&
                    A.push({
                        key: D,
                        routeId: R.routeId,
                        path: R.path,
                        matches: G,
                        match: L,
                        controller: new AbortController(),
                    });
        }),
        [P, A]
    );
}
function F5(n, e, t) {
    let i = !e || t.route.id !== e.route.id,
        r = n[t.route.id] === void 0;
    return i || r;
}
function hR(n, e) {
    let t = n.route.path;
    return (
        n.pathname !== e.pathname ||
        (t != null && t.endsWith('*') && n.params['*'] !== e.params['*'])
    );
}
function QE(n, e) {
    if (n.route.shouldRevalidate) {
        let t = n.route.shouldRevalidate(e);
        if (typeof t == 'boolean') return t;
    }
    return e.defaultShouldRevalidate;
}
async function $E(n, e, t) {
    if (!n.lazy) return;
    let i = await n.lazy();
    if (!n.lazy) return;
    let r = t[n.id];
    Nt(r, 'No route found in manifest');
    let s = {};
    for (let o in i) {
        let c = r[o] !== void 0 && o !== 'hasErrorBoundary';
        wu(
            !c,
            'Route "' +
                r.id +
                '" has a static property "' +
                o +
                '" defined but its lazy function is also returning a value for this property. ' +
                ('The lazy route property "' + o + '" will be ignored.')
        ),
            !c && !r5.has(o) && (s[o] = i[o]);
    }
    Object.assign(r, s), Object.assign(r, Mn({}, e(r), { lazy: void 0 }));
}
async function Mc(n, e, t, i, r, s, o, a, c) {
    c === void 0 && (c = {});
    let f,
        d,
        h,
        p = (w) => {
            let x,
                g = new Promise((S, M) => (x = M));
            return (
                (h = () => x()),
                e.signal.addEventListener('abort', h),
                Promise.race([w({ request: e, params: t.params, context: c.requestContext }), g])
            );
        };
    try {
        let w = t.route[n];
        if (t.route.lazy)
            if (w) {
                let x,
                    g = await Promise.all([
                        p(w).catch((S) => {
                            x = S;
                        }),
                        $E(t.route, s, r),
                    ]);
                if (x) throw x;
                d = g[0];
            } else if ((await $E(t.route, s, r), (w = t.route[n]), w)) d = await p(w);
            else if (n === 'action') {
                let x = new URL(e.url),
                    g = x.pathname + x.search;
                throw vr(405, { method: e.method, pathname: g, routeId: t.route.id });
            } else return { type: xn.data, data: void 0 };
        else if (w) d = await p(w);
        else {
            let x = new URL(e.url),
                g = x.pathname + x.search;
            throw vr(404, { pathname: g });
        }
        Nt(
            d !== void 0,
            'You defined ' +
                (n === 'action' ? 'an action' : 'a loader') +
                ' for route ' +
                ('"' + t.route.id + '" but didn\'t return anything from your `' + n + '` ') +
                'function. Please return a value or `null`.'
        );
    } catch (w) {
        (f = xn.error), (d = w);
    } finally {
        h && e.signal.removeEventListener('abort', h);
    }
    if (H5(d)) {
        let w = d.status;
        if (P5.has(w)) {
            let g = d.headers.get('Location');
            if (
                (Nt(
                    g,
                    'Redirects returned/thrown from loaders/actions must have a Location header'
                ),
                !fR.test(g))
            )
                g = _y(new URL(e.url), i.slice(0, i.indexOf(t) + 1), o, !0, g, a);
            else if (!c.isStaticRequest) {
                let S = new URL(e.url),
                    M = g.startsWith('//') ? new URL(S.protocol + g) : new URL(g),
                    T = Kf(M.pathname, o) != null;
                M.origin === S.origin && T && (g = M.pathname + M.search + M.hash);
            }
            if (c.isStaticRequest) throw (d.headers.set('Location', g), d);
            return {
                type: xn.redirect,
                status: w,
                location: g,
                revalidate: d.headers.get('X-Remix-Revalidate') !== null,
                reloadDocument: d.headers.get('X-Remix-Reload-Document') !== null,
            };
        }
        if (c.isRouteRequest) throw { type: f === xn.error ? xn.error : xn.data, response: d };
        let x;
        try {
            let g = d.headers.get('Content-Type');
            g && /\bapplication\/json\b/.test(g)
                ? d.body == null
                    ? (x = null)
                    : (x = await d.json())
                : (x = await d.text());
        } catch (g) {
            return { type: xn.error, error: g };
        }
        return f === xn.error
            ? { type: f, error: new a1(w, d.statusText, x), headers: d.headers }
            : { type: xn.data, data: x, statusCode: d.status, headers: d.headers };
    }
    if (f === xn.error) return { type: f, error: d };
    if (B5(d)) {
        var v, _;
        return {
            type: xn.deferred,
            deferredData: d,
            statusCode: (v = d.init) == null ? void 0 : v.status,
            headers: ((_ = d.init) == null ? void 0 : _.headers) && new Headers(d.init.headers),
        };
    }
    return { type: xn.data, data: d };
}
function wc(n, e, t, i) {
    let r = n.createURL(pR(e)).toString(),
        s = { signal: t };
    if (i && Or(i.formMethod)) {
        let { formMethod: o, formEncType: a } = i;
        (s.method = o.toUpperCase()),
            a === 'application/json'
                ? ((s.headers = new Headers({ 'Content-Type': a })),
                  (s.body = JSON.stringify(i.json)))
                : a === 'text/plain'
                ? (s.body = i.text)
                : a === 'application/x-www-form-urlencoded' && i.formData
                ? (s.body = yy(i.formData))
                : (s.body = i.formData);
    }
    return new Request(r, s);
}
function yy(n) {
    let e = new URLSearchParams();
    for (let [t, i] of n.entries()) e.append(t, typeof i == 'string' ? i : i.name);
    return e;
}
function eT(n) {
    let e = new FormData();
    for (let [t, i] of n.entries()) e.append(t, i);
    return e;
}
function k5(n, e, t, i, r) {
    let s = {},
        o = null,
        a,
        c = !1,
        f = {};
    return (
        t.forEach((d, h) => {
            let p = e[h].route.id;
            if ((Nt(!Ra(d), 'Cannot handle redirect results in processLoaderData'), iu(d))) {
                let v = jc(n, p),
                    _ = d.error;
                i && ((_ = Object.values(i)[0]), (i = void 0)),
                    (o = o || {}),
                    o[v.route.id] == null && (o[v.route.id] = _),
                    (s[p] = void 0),
                    c || ((c = !0), (a = uR(d.error) ? d.error.status : 500)),
                    d.headers && (f[p] = d.headers);
            } else
                ba(d) ? (r.set(p, d.deferredData), (s[p] = d.deferredData.data)) : (s[p] = d.data),
                    d.statusCode != null && d.statusCode !== 200 && !c && (a = d.statusCode),
                    d.headers && (f[p] = d.headers);
        }),
        i && ((o = i), (s[Object.keys(i)[0]] = void 0)),
        { loaderData: s, errors: o, statusCode: a || 200, loaderHeaders: f }
    );
}
function tT(n, e, t, i, r, s, o, a) {
    let { loaderData: c, errors: f } = k5(e, t, i, r, a);
    for (let d = 0; d < s.length; d++) {
        let { key: h, match: p, controller: v } = s[d];
        Nt(o !== void 0 && o[d] !== void 0, 'Did not find corresponding fetcher result');
        let _ = o[d];
        if (!(v && v.signal.aborted))
            if (iu(_)) {
                let w = jc(n.matches, p == null ? void 0 : p.route.id);
                (f && f[w.route.id]) || (f = Mn({}, f, { [w.route.id]: _.error })),
                    n.fetchers.delete(h);
            } else if (Ra(_)) Nt(!1, 'Unhandled fetcher revalidation redirect');
            else if (ba(_)) Nt(!1, 'Unhandled fetcher deferred data');
            else {
                let w = mo(_.data);
                n.fetchers.set(h, w);
            }
    }
    return { loaderData: c, errors: f };
}
function nT(n, e, t, i) {
    let r = Mn({}, e);
    for (let s of t) {
        let o = s.route.id;
        if (
            (e.hasOwnProperty(o)
                ? e[o] !== void 0 && (r[o] = e[o])
                : n[o] !== void 0 && s.route.loader && (r[o] = n[o]),
            i && i.hasOwnProperty(o))
        )
            break;
    }
    return r;
}
function jc(n, e) {
    return (
        (e ? n.slice(0, n.findIndex((i) => i.route.id === e) + 1) : [...n])
            .reverse()
            .find((i) => i.route.hasErrorBoundary === !0) || n[0]
    );
}
function iT(n) {
    let e =
        n.length === 1
            ? n[0]
            : n.find((t) => t.index || !t.path || t.path === '/') || { id: '__shim-error-route__' };
    return { matches: [{ params: {}, pathname: '', pathnameBase: '', route: e }], route: e };
}
function vr(n, e) {
    let { pathname: t, routeId: i, method: r, type: s } = e === void 0 ? {} : e,
        o = 'Unknown Server Error',
        a = 'Unknown @remix-run/router error';
    return (
        n === 400
            ? ((o = 'Bad Request'),
              r && t && i
                  ? (a =
                        'You made a ' +
                        r +
                        ' request to "' +
                        t +
                        '" but ' +
                        ('did not provide a `loader` for route "' + i + '", ') +
                        'so there is no way to handle the request.')
                  : s === 'defer-action'
                  ? (a = 'defer() is not supported in actions')
                  : s === 'invalid-body' && (a = 'Unable to encode submission body'))
            : n === 403
            ? ((o = 'Forbidden'), (a = 'Route "' + i + '" does not match URL "' + t + '"'))
            : n === 404
            ? ((o = 'Not Found'), (a = 'No route matches URL "' + t + '"'))
            : n === 405 &&
              ((o = 'Method Not Allowed'),
              r && t && i
                  ? (a =
                        'You made a ' +
                        r.toUpperCase() +
                        ' request to "' +
                        t +
                        '" but ' +
                        ('did not provide an `action` for route "' + i + '", ') +
                        'so there is no way to handle the request.')
                  : r && (a = 'Invalid request method "' + r.toUpperCase() + '"')),
        new a1(n || 500, o, new Error(a), !0)
    );
}
function rT(n) {
    for (let e = n.length - 1; e >= 0; e--) {
        let t = n[e];
        if (Ra(t)) return { result: t, idx: e };
    }
}
function pR(n) {
    let e = typeof n == 'string' ? Zs(n) : n;
    return Zf(Mn({}, e, { hash: '' }));
}
function z5(n, e) {
    return n.pathname !== e.pathname || n.search !== e.search
        ? !1
        : n.hash === ''
        ? e.hash !== ''
        : n.hash === e.hash
        ? !0
        : e.hash !== '';
}
function ba(n) {
    return n.type === xn.deferred;
}
function iu(n) {
    return n.type === xn.error;
}
function Ra(n) {
    return (n && n.type) === xn.redirect;
}
function B5(n) {
    let e = n;
    return (
        e &&
        typeof e == 'object' &&
        typeof e.data == 'object' &&
        typeof e.subscribe == 'function' &&
        typeof e.cancel == 'function' &&
        typeof e.resolveData == 'function'
    );
}
function H5(n) {
    return (
        n != null &&
        typeof n.status == 'number' &&
        typeof n.statusText == 'string' &&
        typeof n.headers == 'object' &&
        typeof n.body < 'u'
    );
}
function V5(n) {
    return R5.has(n.toLowerCase());
}
function Or(n) {
    return C5.has(n.toLowerCase());
}
async function sT(n, e, t, i, r, s) {
    for (let o = 0; o < t.length; o++) {
        let a = t[o],
            c = e[o];
        if (!c) continue;
        let f = n.find((h) => h.route.id === c.route.id),
            d = f != null && !hR(f, c) && (s && s[c.route.id]) !== void 0;
        if (ba(a) && (r || d)) {
            let h = i[o];
            Nt(h, 'Expected an AbortSignal for revalidating fetcher deferred result'),
                await mR(a, h, r).then((p) => {
                    p && (t[o] = p || t[o]);
                });
        }
    }
}
async function mR(n, e, t) {
    if ((t === void 0 && (t = !1), !(await n.deferredData.resolveData(e)))) {
        if (t)
            try {
                return { type: xn.data, data: n.deferredData.unwrappedData };
            } catch (r) {
                return { type: xn.error, error: r };
            }
        return { type: xn.data, data: n.deferredData.data };
    }
}
function l1(n) {
    return new URLSearchParams(n).getAll('index').some((e) => e === '');
}
function xy(n, e) {
    let t = typeof e == 'string' ? Zs(e).search : e.search;
    if (n[n.length - 1].route.index && l1(t || '')) return n[n.length - 1];
    let i = lR(n);
    return i[i.length - 1];
}
function oT(n) {
    let { formMethod: e, formAction: t, formEncType: i, text: r, formData: s, json: o } = n;
    if (!(!e || !t || !i)) {
        if (r != null)
            return {
                formMethod: e,
                formAction: t,
                formEncType: i,
                formData: void 0,
                json: void 0,
                text: r,
            };
        if (s != null)
            return {
                formMethod: e,
                formAction: t,
                formEncType: i,
                formData: s,
                json: void 0,
                text: void 0,
            };
        if (o !== void 0)
            return {
                formMethod: e,
                formAction: t,
                formEncType: i,
                formData: void 0,
                json: o,
                text: void 0,
            };
    }
}
function L0(n, e) {
    return e
        ? {
              state: 'loading',
              location: n,
              formMethod: e.formMethod,
              formAction: e.formAction,
              formEncType: e.formEncType,
              formData: e.formData,
              json: e.json,
              text: e.text,
          }
        : {
              state: 'loading',
              location: n,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              json: void 0,
              text: void 0,
          };
}
function G5(n, e) {
    return {
        state: 'submitting',
        location: n,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text,
    };
}
function Ec(n, e) {
    return n
        ? {
              state: 'loading',
              formMethod: n.formMethod,
              formAction: n.formAction,
              formEncType: n.formEncType,
              formData: n.formData,
              json: n.json,
              text: n.text,
              data: e,
          }
        : {
              state: 'loading',
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              json: void 0,
              text: void 0,
              data: e,
          };
}
function W5(n, e) {
    return {
        state: 'submitting',
        formMethod: n.formMethod,
        formAction: n.formAction,
        formEncType: n.formEncType,
        formData: n.formData,
        json: n.json,
        text: n.text,
        data: e ? e.data : void 0,
    };
}
function mo(n) {
    return {
        state: 'idle',
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: n,
    };
}
function j5(n, e) {
    try {
        let t = n.sessionStorage.getItem(dR);
        if (t) {
            let i = JSON.parse(t);
            for (let [r, s] of Object.entries(i || {}))
                s && Array.isArray(s) && e.set(r, new Set(s || []));
        }
    } catch {}
}
function X5(n, e) {
    if (e.size > 0) {
        let t = {};
        for (let [i, r] of e) t[i] = [...r];
        try {
            n.sessionStorage.setItem(dR, JSON.stringify(t));
        } catch (i) {
            wu(!1, 'Failed to save applied view transitions in sessionStorage (' + i + ').');
        }
    }
}
/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function om() {
    return (
        (om = Object.assign
            ? Object.assign.bind()
            : function (n) {
                  for (var e = 1; e < arguments.length; e++) {
                      var t = arguments[e];
                      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
                  }
                  return n;
              }),
        om.apply(this, arguments)
    );
}
const gR = pe.createContext(null),
    vR = pe.createContext(null),
    _R = pe.createContext(null),
    eg = pe.createContext(null),
    tg = pe.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
    yR = pe.createContext(null);
function u1() {
    return pe.useContext(eg) != null;
}
function Y5() {
    return u1() || Nt(!1), pe.useContext(eg).location;
}
function q5(n, e, t, i) {
    u1() || Nt(!1);
    let { navigator: r } = pe.useContext(_R),
        { matches: s } = pe.useContext(tg),
        o = s[s.length - 1],
        a = o ? o.params : {};
    o && o.pathname;
    let c = o ? o.pathnameBase : '/';
    o && o.route;
    let f = Y5(),
        d;
    if (e) {
        var h;
        let x = typeof e == 'string' ? Zs(e) : e;
        c === '/' || ((h = x.pathname) != null && h.startsWith(c)) || Nt(!1), (d = x);
    } else d = f;
    let p = d.pathname || '/',
        v = p;
    if (c !== '/') {
        let x = c.replace(/^\//, '').split('/');
        v = '/' + p.replace(/^\//, '').split('/').slice(x.length).join('/');
    }
    let _ = nu(n, { pathname: v }),
        w = $5(
            _ &&
                _.map((x) =>
                    Object.assign({}, x, {
                        params: Object.assign({}, a, x.params),
                        pathname: Oa([
                            c,
                            r.encodeLocation ? r.encodeLocation(x.pathname).pathname : x.pathname,
                        ]),
                        pathnameBase:
                            x.pathnameBase === '/'
                                ? c
                                : Oa([
                                      c,
                                      r.encodeLocation
                                          ? r.encodeLocation(x.pathnameBase).pathname
                                          : x.pathnameBase,
                                  ]),
                    })
                ),
            s,
            t,
            i
        );
    return e && w
        ? pe.createElement(
              eg.Provider,
              {
                  value: {
                      location: om(
                          { pathname: '/', search: '', hash: '', state: null, key: 'default' },
                          d
                      ),
                      navigationType: Cn.Pop,
                  },
              },
              w
          )
        : w;
}
function Z5() {
    let n = iH(),
        e = uR(n)
            ? n.status + ' ' + n.statusText
            : n instanceof Error
            ? n.message
            : JSON.stringify(n),
        t = n instanceof Error ? n.stack : null,
        r = { padding: '0.5rem', backgroundColor: 'rgba(200,200,200, 0.5)' },
        s = null;
    return pe.createElement(
        pe.Fragment,
        null,
        pe.createElement('h2', null, 'Unexpected Application Error!'),
        pe.createElement('h3', { style: { fontStyle: 'italic' } }, e),
        t ? pe.createElement('pre', { style: r }, t) : null,
        s
    );
}
const K5 = pe.createElement(Z5, null);
class J5 extends pe.Component {
    constructor(e) {
        super(e),
            (this.state = { location: e.location, revalidation: e.revalidation, error: e.error });
    }
    static getDerivedStateFromError(e) {
        return { error: e };
    }
    static getDerivedStateFromProps(e, t) {
        return t.location !== e.location || (t.revalidation !== 'idle' && e.revalidation === 'idle')
            ? { error: e.error, location: e.location, revalidation: e.revalidation }
            : {
                  error: e.error !== void 0 ? e.error : t.error,
                  location: t.location,
                  revalidation: e.revalidation || t.revalidation,
              };
    }
    componentDidCatch(e, t) {
        console.error('React Router caught the following error during render', e, t);
    }
    render() {
        return this.state.error !== void 0
            ? pe.createElement(
                  tg.Provider,
                  { value: this.props.routeContext },
                  pe.createElement(yR.Provider, {
                      value: this.state.error,
                      children: this.props.component,
                  })
              )
            : this.props.children;
    }
}
function Q5(n) {
    let { routeContext: e, match: t, children: i } = n,
        r = pe.useContext(gR);
    return (
        r &&
            r.static &&
            r.staticContext &&
            (t.route.errorElement || t.route.ErrorBoundary) &&
            (r.staticContext._deepestRenderedBoundaryId = t.route.id),
        pe.createElement(tg.Provider, { value: e }, i)
    );
}
function $5(n, e, t, i) {
    var r;
    if (
        (e === void 0 && (e = []),
        t === void 0 && (t = null),
        i === void 0 && (i = null),
        n == null)
    ) {
        var s;
        if ((s = t) != null && s.errors) n = t.matches;
        else return null;
    }
    let o = n,
        a = (r = t) == null ? void 0 : r.errors;
    if (a != null) {
        let d = o.findIndex((h) => h.route.id && (a == null ? void 0 : a[h.route.id]));
        d >= 0 || Nt(!1), (o = o.slice(0, Math.min(o.length, d + 1)));
    }
    let c = !1,
        f = -1;
    if (t && i && i.v7_partialHydration)
        for (let d = 0; d < o.length; d++) {
            let h = o[d];
            if (
                ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (f = d), h.route.id)
            ) {
                let { loaderData: p, errors: v } = t,
                    _ =
                        h.route.loader &&
                        p[h.route.id] === void 0 &&
                        (!v || v[h.route.id] === void 0);
                if (h.route.lazy || _) {
                    (c = !0), f >= 0 ? (o = o.slice(0, f + 1)) : (o = [o[0]]);
                    break;
                }
            }
        }
    return o.reduceRight((d, h, p) => {
        let v,
            _ = !1,
            w = null,
            x = null;
        t &&
            ((v = a && h.route.id ? a[h.route.id] : void 0),
            (w = h.route.errorElement || K5),
            c &&
                (f < 0 && p === 0
                    ? (rH('route-fallback', !1), (_ = !0), (x = null))
                    : f === p && ((_ = !0), (x = h.route.hydrateFallbackElement || null))));
        let g = e.concat(o.slice(0, p + 1)),
            S = () => {
                let M;
                return (
                    v
                        ? (M = w)
                        : _
                        ? (M = x)
                        : h.route.Component
                        ? (M = pe.createElement(h.route.Component, null))
                        : h.route.element
                        ? (M = h.route.element)
                        : (M = d),
                    pe.createElement(Q5, {
                        match: h,
                        routeContext: { outlet: d, matches: g, isDataRoute: t != null },
                        children: M,
                    })
                );
            };
        return t && (h.route.ErrorBoundary || h.route.errorElement || p === 0)
            ? pe.createElement(J5, {
                  location: t.location,
                  revalidation: t.revalidation,
                  component: w,
                  error: v,
                  children: S(),
                  routeContext: { outlet: null, matches: g, isDataRoute: !0 },
              })
            : S();
    }, null);
}
var Sy = (function (n) {
    return (
        (n.UseBlocker = 'useBlocker'),
        (n.UseLoaderData = 'useLoaderData'),
        (n.UseActionData = 'useActionData'),
        (n.UseRouteError = 'useRouteError'),
        (n.UseNavigation = 'useNavigation'),
        (n.UseRouteLoaderData = 'useRouteLoaderData'),
        (n.UseMatches = 'useMatches'),
        (n.UseRevalidator = 'useRevalidator'),
        (n.UseNavigateStable = 'useNavigate'),
        (n.UseRouteId = 'useRouteId'),
        n
    );
})(Sy || {});
function eH(n) {
    let e = pe.useContext(vR);
    return e || Nt(!1), e;
}
function tH(n) {
    let e = pe.useContext(tg);
    return e || Nt(!1), e;
}
function nH(n) {
    let e = tH(),
        t = e.matches[e.matches.length - 1];
    return t.route.id || Nt(!1), t.route.id;
}
function iH() {
    var n;
    let e = pe.useContext(yR),
        t = eH(Sy.UseRouteError),
        i = nH(Sy.UseRouteError);
    return e !== void 0 ? e : (n = t.errors) == null ? void 0 : n[i];
}
const aT = {};
function rH(n, e, t) {
    !e && !aT[n] && (aT[n] = !0);
}
function sH(n) {
    let {
        basename: e = '/',
        children: t = null,
        location: i,
        navigationType: r = Cn.Pop,
        navigator: s,
        static: o = !1,
        future: a,
    } = n;
    u1() && Nt(!1);
    let c = e.replace(/^\/*/, '/'),
        f = pe.useMemo(
            () => ({
                basename: c,
                navigator: s,
                static: o,
                future: om({ v7_relativeSplatPath: !1 }, a),
            }),
            [c, a, s, o]
        );
    typeof i == 'string' && (i = Zs(i));
    let {
            pathname: d = '/',
            search: h = '',
            hash: p = '',
            state: v = null,
            key: _ = 'default',
        } = i,
        w = pe.useMemo(() => {
            let x = Kf(d, c);
            return x == null
                ? null
                : {
                      location: { pathname: x, search: h, hash: p, state: v, key: _ },
                      navigationType: r,
                  };
        }, [c, d, h, p, v, _, r]);
    return w == null
        ? null
        : pe.createElement(
              _R.Provider,
              { value: f },
              pe.createElement(eg.Provider, { children: t, value: w })
          );
}
new Promise(() => {});
function oH(n) {
    let e = { hasErrorBoundary: n.ErrorBoundary != null || n.errorElement != null };
    return (
        n.Component &&
            Object.assign(e, { element: pe.createElement(n.Component), Component: void 0 }),
        n.HydrateFallback &&
            Object.assign(e, {
                hydrateFallbackElement: pe.createElement(n.HydrateFallback),
                HydrateFallback: void 0,
            }),
        n.ErrorBoundary &&
            Object.assign(e, {
                errorElement: pe.createElement(n.ErrorBoundary),
                ErrorBoundary: void 0,
            }),
        e
    );
}
/**
 * React Router DOM v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function am() {
    return (
        (am = Object.assign
            ? Object.assign.bind()
            : function (n) {
                  for (var e = 1; e < arguments.length; e++) {
                      var t = arguments[e];
                      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
                  }
                  return n;
              }),
        am.apply(this, arguments)
    );
}
const aH = '6';
try {
    window.__reactRouterVersion = aH;
} catch {}
function lH(n, e) {
    return D5({
        basename: e == null ? void 0 : e.basename,
        future: am({}, e == null ? void 0 : e.future, { v7_prependBasename: !0 }),
        history: t5({ window: e == null ? void 0 : e.window }),
        hydrationData: (e == null ? void 0 : e.hydrationData) || uH(),
        routes: n,
        mapRouteProperties: oH,
        window: e == null ? void 0 : e.window,
    }).initialize();
}
function uH() {
    var n;
    let e = (n = window) == null ? void 0 : n.__staticRouterHydrationData;
    return e && e.errors && (e = am({}, e, { errors: cH(e.errors) })), e;
}
function cH(n) {
    if (!n) return null;
    let e = Object.entries(n),
        t = {};
    for (let [i, r] of e)
        if (r && r.__type === 'RouteErrorResponse')
            t[i] = new a1(r.status, r.statusText, r.data, r.internal === !0);
        else if (r && r.__type === 'Error') {
            if (r.__subType) {
                let s = window[r.__subType];
                if (typeof s == 'function')
                    try {
                        let o = new s(r.message);
                        (o.stack = ''), (t[i] = o);
                    } catch {}
            }
            if (t[i] == null) {
                let s = new Error(r.message);
                (s.stack = ''), (t[i] = s);
            }
        } else t[i] = r;
    return t;
}
const fH = pe.createContext({ isTransitioning: !1 }),
    dH = pe.createContext(new Map()),
    hH = 'startTransition',
    lT = TP[hH],
    pH = 'flushSync',
    uT = OL[pH];
function mH(n) {
    lT ? lT(n) : n();
}
function Tc(n) {
    uT ? uT(n) : n();
}
class gH {
    constructor() {
        (this.status = 'pending'),
            (this.promise = new Promise((e, t) => {
                (this.resolve = (i) => {
                    this.status === 'pending' && ((this.status = 'resolved'), e(i));
                }),
                    (this.reject = (i) => {
                        this.status === 'pending' && ((this.status = 'rejected'), t(i));
                    });
            }));
    }
}
function vH(n) {
    let { fallbackElement: e, router: t, future: i } = n,
        [r, s] = pe.useState(t.state),
        [o, a] = pe.useState(),
        [c, f] = pe.useState({ isTransitioning: !1 }),
        [d, h] = pe.useState(),
        [p, v] = pe.useState(),
        [_, w] = pe.useState(),
        x = pe.useRef(new Map()),
        { v7_startTransition: g } = i || {},
        S = pe.useCallback(
            (R) => {
                g ? mH(R) : R();
            },
            [g]
        ),
        M = pe.useCallback(
            (R, D) => {
                let {
                    deletedFetchers: G,
                    unstable_flushSync: b,
                    unstable_viewTransitionOpts: L,
                } = D;
                G.forEach((ie) => x.current.delete(ie)),
                    R.fetchers.forEach((ie, j) => {
                        ie.data !== void 0 && x.current.set(j, ie.data);
                    });
                let ee =
                    t.window == null || typeof t.window.document.startViewTransition != 'function';
                if (!L || ee) {
                    b ? Tc(() => s(R)) : S(() => s(R));
                    return;
                }
                if (b) {
                    Tc(() => {
                        p && (d && d.resolve(), p.skipTransition()),
                            f({
                                isTransitioning: !0,
                                flushSync: !0,
                                currentLocation: L.currentLocation,
                                nextLocation: L.nextLocation,
                            });
                    });
                    let ie = t.window.document.startViewTransition(() => {
                        Tc(() => s(R));
                    });
                    ie.finished.finally(() => {
                        Tc(() => {
                            h(void 0), v(void 0), a(void 0), f({ isTransitioning: !1 });
                        });
                    }),
                        Tc(() => v(ie));
                    return;
                }
                p
                    ? (d && d.resolve(),
                      p.skipTransition(),
                      w({
                          state: R,
                          currentLocation: L.currentLocation,
                          nextLocation: L.nextLocation,
                      }))
                    : (a(R),
                      f({
                          isTransitioning: !0,
                          flushSync: !1,
                          currentLocation: L.currentLocation,
                          nextLocation: L.nextLocation,
                      }));
            },
            [t.window, p, d, x, S]
        );
    pe.useLayoutEffect(() => t.subscribe(M), [t, M]),
        pe.useEffect(() => {
            c.isTransitioning && !c.flushSync && h(new gH());
        }, [c]),
        pe.useEffect(() => {
            if (d && o && t.window) {
                let R = o,
                    D = d.promise,
                    G = t.window.document.startViewTransition(async () => {
                        S(() => s(R)), await D;
                    });
                G.finished.finally(() => {
                    h(void 0), v(void 0), a(void 0), f({ isTransitioning: !1 });
                }),
                    v(G);
            }
        }, [S, o, d, t.window]),
        pe.useEffect(() => {
            d && o && r.location.key === o.location.key && d.resolve();
        }, [d, p, r.location, o]),
        pe.useEffect(() => {
            !c.isTransitioning &&
                _ &&
                (a(_.state),
                f({
                    isTransitioning: !0,
                    flushSync: !1,
                    currentLocation: _.currentLocation,
                    nextLocation: _.nextLocation,
                }),
                w(void 0));
        }, [c.isTransitioning, _]),
        pe.useEffect(() => {}, []);
    let T = pe.useMemo(
            () => ({
                createHref: t.createHref,
                encodeLocation: t.encodeLocation,
                go: (R) => t.navigate(R),
                push: (R, D, G) =>
                    t.navigate(R, {
                        state: D,
                        preventScrollReset: G == null ? void 0 : G.preventScrollReset,
                    }),
                replace: (R, D, G) =>
                    t.navigate(R, {
                        replace: !0,
                        state: D,
                        preventScrollReset: G == null ? void 0 : G.preventScrollReset,
                    }),
            }),
            [t]
        ),
        P = t.basename || '/',
        A = pe.useMemo(() => ({ router: t, navigator: T, static: !1, basename: P }), [t, T, P]);
    return pe.createElement(
        pe.Fragment,
        null,
        pe.createElement(
            gR.Provider,
            { value: A },
            pe.createElement(
                vR.Provider,
                { value: r },
                pe.createElement(
                    dH.Provider,
                    { value: x.current },
                    pe.createElement(
                        fH.Provider,
                        { value: c },
                        pe.createElement(
                            sH,
                            {
                                basename: P,
                                location: r.location,
                                navigationType: r.historyAction,
                                navigator: T,
                                future: { v7_relativeSplatPath: t.future.v7_relativeSplatPath },
                            },
                            r.initialized || t.future.v7_partialHydration
                                ? pe.createElement(_H, {
                                      routes: t.routes,
                                      future: t.future,
                                      state: r,
                                  })
                                : e
                        )
                    )
                )
            )
        ),
        null
    );
}
function _H(n) {
    let { routes: e, future: t, state: i } = n;
    return q5(e, void 0, i, t);
}
var cT;
(function (n) {
    (n.UseScrollRestoration = 'useScrollRestoration'),
        (n.UseSubmit = 'useSubmit'),
        (n.UseSubmitFetcher = 'useSubmitFetcher'),
        (n.UseFetcher = 'useFetcher'),
        (n.useViewTransitionState = 'useViewTransitionState');
})(cT || (cT = {}));
var fT;
(function (n) {
    (n.UseFetcher = 'useFetcher'),
        (n.UseFetchers = 'useFetchers'),
        (n.UseScrollRestoration = 'useScrollRestoration');
})(fT || (fT = {}));
const yH = lH([
        { path: '/', element: X.jsx(DI, {}) },
        { path: '/shop', element: X.jsx(zI, {}) },
        { path: '/configurator', element: X.jsx(e5, {}) },
        { path: '/checkout', element: X.jsx(WI, {}) },
    ]),
    xH = I0.createRoot(document.getElementById('root'));
xH.render(X.jsx(Os.StrictMode, { children: X.jsx(vH, { router: yH }) }));
